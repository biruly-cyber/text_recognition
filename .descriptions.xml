<inspections profile="Project Default"><group name="Modularization issues" path="Java"><inspection shortName="InconsistentLanguageLevel" defaultSeverity="WARNING" displayName="Inconsistent language level settings" enabled="false" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports modules which depend on other modules with a higher language level. 
&lt;p&gt;Such dependencies should be removed or the language level of the module be increased.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ModuleWithTooFewClasses" defaultSeverity="WARNING" displayName="Module with too few classes" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports modules that contain too few classes. Overly small modules may indicate a too fragmented design.
Java, Kotlin and Groovy classes are counted.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Minimum number of classes&lt;/b&gt; field to specify the minimum number of classes a module may have.&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassOnlyUsedInOneModule" defaultSeverity="WARNING" displayName="Class only used from one other module" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports classes that:
&lt;ul&gt;
  &lt;li&gt;do not depend on any other class in their module&lt;/li&gt;
  &lt;li&gt;depend on classes from a different module&lt;/li&gt;
  &lt;li&gt;are a dependency only for classes from this other module&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Such classes could be moved into the module on which they depend.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ModuleWithTooManyClasses" defaultSeverity="WARNING" displayName="Module with too many classes" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports modules that contain too many classes. Overly large modules may indicate a lack of design clarity.
Java, Kotlin and Groovy classes are counted.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Maximum number of classes&lt;/b&gt; field to specify the maximum number of classes a module may have.&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassIndependentOfModule" defaultSeverity="WARNING" displayName="Class independent of its module" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports classes that:
&lt;ul&gt;
  &lt;li&gt;do not depend on any other class in their module&lt;/li&gt;
  &lt;li&gt;are not a dependency for any other class in their module&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Such classes are an indication of ad-hoc or incoherent modularisation strategies,
  and may often profitably be moved.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Declaration order" path="C/C++"><inspection shortName="MemberVisibility" defaultSeverity="WARNING" displayName="Member visibility" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the symbols that are inaccessible due to public/private/protected restrictions.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HidesUpperScope" defaultSeverity="WARNING" displayName="Hides upper scope" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the local variables declared in the scope of other local variables or
  parameters with the same name.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionImplicitDeclaration" defaultSeverity="WARNING" displayName="Function implicit declaration" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the functions that are used before they are declared. The purpose is to ensure compatibility with compilers that
require functions to be declared before their usage.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateDeclarations" defaultSeverity="WARNING" displayName="Duplicate declarations" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redefinitions of the symbols.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticnessMismatch" defaultSeverity="WARNING" displayName="Staticness mismatch" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the instance symbols that are accessed from the class context or vice versa.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CannotResolve" defaultSeverity="WARNING" displayName="Cannot resolve" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the unresolved symbols in the code.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Shrinker" path="Android"><inspection shortName="ShrinkerArrayType" defaultSeverity="ERROR" displayName="Invalid using of array type" enabled="true" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  Reports incorrect usage of array type notation.
  &lt;br&gt;
  &lt;code&gt;type[]&lt;/code&gt; should be used for array type, without any spaces.
  &lt;br&gt;
  &lt;br&gt;
  Example: &lt;code&gt;java.lang.Object[]&lt;/code&gt;.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ShrinkerInvalidFlags" defaultSeverity="ERROR" displayName="Invalid flag in shrinker config" enabled="true" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports flags that are invalid in shrinker config.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="R8IgnoredFlags" defaultSeverity="WARNING" displayName="Flags ignored by R8" enabled="true" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports flags that are ignored by R8.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ShrinkerUnresolvedReference" defaultSeverity="ERROR" displayName="Unresolved reference in Shrinker Config file" enabled="true" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unresolved references to class members in Shrinker config.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ShrinkerInnerClassSeparator" defaultSeverity="ERROR" displayName="Invalid separator between class and inner class" enabled="true" language="SHRINKER_CONFIG" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports invalid separator between class and inner class in Shrinker config.
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Inheritance issues" path="Java"><inspection shortName="AbstractMethodOverridesConcreteMethod" defaultSeverity="WARNING" displayName="Abstract method overrides concrete method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;abstract&lt;/code&gt; methods that override concrete super methods.
&lt;p&gt;Methods overridden from &lt;code&gt;java.lang.Object&lt;/code&gt; are not reported by this inspection.&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingOverrideAnnotation" defaultSeverity="INFORMATION" displayName="Missing '@Override' annotation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports methods overriding superclass methods but are not annotated with &lt;code&gt;@java.lang.Override&lt;/code&gt;.
  &lt;p&gt;
  Annotating methods with &lt;code&gt;@java.lang.Override&lt;/code&gt; improves code readability since it shows the intent.
  In addition, the compiler emits an error when a signature of the overridden method doesn't match the superclass method.
  &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;
    class X {
      public String toString() {
        return "hello world";
      }
    }
  &lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;
    class X {
      @Override
      public String toString() {
        return "hello world";
      }
    }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Ignore 'equals()', 'hashCode()' and 'toString()'&lt;/b&gt; option to ignore these
    &lt;code&gt;java.lang.Object&lt;/code&gt; methods: &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt;, and
    &lt;code&gt;toString()&lt;/code&gt;. The risk that these methods will disappear and
    your code won't be compiling anymore due to the &lt;code&gt;@Override&lt;/code&gt;
    annotation is relatively small.
  &lt;/li&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Ignore methods in anonymous classes&lt;/b&gt; option to ignore methods
    in anonymous classes.
  &lt;/li&gt;
  &lt;li&gt;
    Disable the &lt;b&gt;Highlight method when its overriding methods do not all have the '@Override' annotation&lt;/b&gt; option to only
    warn on the methods missing an &lt;code&gt;@Override&lt;/code&gt; annotation, and not on overridden methods where one or more descendants are
    missing an &lt;code&gt;@Override&lt;/code&gt; annotation.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 5 or higher.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AbstractClassWithoutAbstractMethods" defaultSeverity="WARNING" displayName="Abstract class without 'abstract' methods" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;abstract&lt;/code&gt; classes that have no &lt;code&gt;abstract&lt;/code&gt; methods.
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticInheritance" defaultSeverity="WARNING" displayName="Static inheritance" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports interfaces that are implemented only to provide access to constants.
This kind of inheritance is often confusing and may hide important dependency information.
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RefusedBequest" defaultSeverity="WARNING" displayName="Method does not call super method" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that override a particular method without calling &lt;code&gt;super&lt;/code&gt;.
&lt;p&gt;This is also known as a &lt;i&gt;refused bequest&lt;/i&gt;. Such methods
  may represent a failure of abstraction and cause hard-to-trace bugs.&lt;/p&gt;
  &lt;p&gt;The inspection doesn't report default methods and methods overridden
from &lt;code&gt;java.lang.Object&lt;/code&gt;, except for &lt;code&gt;clone()&lt;/code&gt;.
  The &lt;code&gt;clone()&lt;/code&gt; method is expected to call its &lt;code&gt;super&lt;/code&gt;, which will automatically return an object of the correct type.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;pre&gt;&lt;code&gt;
  class A {
    @Override
    public Object clone() { // reported, because it does not call 'super.clone()'
      return new A();
    }
  }
  &lt;/code&gt;&lt;/pre&gt; &lt;/li&gt;
  &lt;li&gt;&lt;pre&gt;&lt;code&gt;
  interface I {
    default void foo() {}
  }

  class A implements I {
    // warning on method when 'Ignore 'default' super methods' and 'Ignore annotated' options are disabled
    @Override
    public void foo(){}
  }
    &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Only report when super method is annotated by&lt;/b&gt; option to ignore &lt;code&gt;super&lt;/code&gt; methods marked with the annotations
    from the provided list. You can manually add annotations to the list.
  &lt;/li&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Ignore empty super methods&lt;/b&gt; option to ignore &lt;code&gt;super&lt;/code&gt; methods that are either empty or only throw an exception.
  &lt;/li&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Ignore 'default' super methods&lt;/b&gt; option to ignore &lt;code&gt;super&lt;/code&gt; methods with the &lt;code&gt;default&lt;/code&gt; keyword.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonProtectedConstructorInAbstractClass" defaultSeverity="WARNING" displayName="Public constructor in abstract class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;public&lt;/code&gt; constructors of &lt;code&gt;abstract&lt;/code&gt; classes.
&lt;p&gt;
  Constructors of &lt;code&gt;abstract&lt;/code&gt; classes can only be called from the constructors of
  their subclasses, declaring them &lt;code&gt;public&lt;/code&gt; may be confusing.
&lt;/p&gt;
&lt;p&gt;The quick-fix makes such constructors protected.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public abstract class&lt;/b&gt; Foo {
    &lt;b&gt;public&lt;/b&gt; Foo () { // warning: has 'public' modifier
        /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public abstract class&lt;/b&gt; Foo {
    &lt;b&gt;protected&lt;/b&gt; Foo () {
        /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;Use the option below to ignore non-public classes.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProblematicVarargsMethodOverride" defaultSeverity="WARNING" displayName="Non-varargs method overrides varargs method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that override a variable arity (a.k.a. varargs) method but replace the variable arity parameter with an array parameter.
Though this code is valid, it may be confusing and should be avoided.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractMethodOverridesAbstractMethod" defaultSeverity="WARNING" displayName="Abstract method overrides abstract method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;abstract&lt;/code&gt; methods that override &lt;code&gt;abstract&lt;/code&gt; methods.
&lt;p&gt;Such methods don't make sense because any concrete child class will have to implement the abstract method anyway.&lt;/p&gt;
&lt;p&gt;
  Methods whose return types, exception declarations, annotations, or modifiers differ from the overridden method are not reported by this inspection.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Ignore methods with different Javadoc than their super methods&lt;/b&gt; option to ignore any abstract methods whose JavaDoc comment differs from their super method.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantMethodOverride" defaultSeverity="WARNING" displayName="Method is identical to its super method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that are identical to their super methods. Such methods have the same signature
as their super method and either have an identical body or only their body consists only of a call to the super method.
These methods are redundant and can be removed.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the checkbox below to run the inspection for the methods that override library methods.
  Checking library methods may slow down the inspection.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractClassExtendsConcreteClass" defaultSeverity="WARNING" displayName="Abstract class extends concrete class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;abstract&lt;/code&gt; classes that extend concrete classes.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractClassNeverImplemented" defaultSeverity="WARNING" displayName="Abstract class which has no concrete subclass" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;abstract&lt;/code&gt; classes that have no concrete subclasses.
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterTypePreventsOverriding" defaultSeverity="WARNING" displayName="Parameter type prevents overriding" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports parameter types of a subclass method that have the same name as
the parameter type of the corresponding super method but belong to a different package.
In these cases, the subclass method cannot override the super method.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;b&gt;public class&lt;/b&gt; A {
 &lt;b&gt;public void&lt;/b&gt; method(Object o) {}
}

&lt;b&gt;public class&lt;/b&gt; B &lt;b&gt;extends&lt;/b&gt; A {
 &lt;b&gt;public void&lt;/b&gt; method(Object o) {} // warning on parameter type
 &lt;b&gt;class&lt;/b&gt; Object {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;b&gt;public class&lt;/b&gt; A {
 &lt;b&gt;public void&lt;/b&gt; method(Object o) {}
}

&lt;b&gt;public class&lt;/b&gt; B &lt;b&gt;extends&lt;/b&gt; A {
 &lt;b&gt;public void&lt;/b&gt; method(java.lang.Object o) {} // new parameter type
 &lt;b&gt;class&lt;/b&gt; Object {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeParameterExtendsFinalClass" defaultSeverity="WARNING" displayName="Type parameter extends 'final' class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports type parameters declared to extend a &lt;code&gt;final&lt;/code&gt; class.
&lt;p&gt;Suggests replacing the type parameter with the type of the specified&lt;code&gt;final&lt;/code&gt; class since
  &lt;code&gt;final&lt;/code&gt; classes cannot be extended.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo() {
    List&amp;lt;? &lt;b&gt;extends&lt;/b&gt; Integer&amp;gt; list; // Warning: the Integer class is a final class
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo() {
    List&amp;lt;Integer&amp;gt; list;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsConcreteCollection" defaultSeverity="WARNING" displayName="Class explicitly extends a 'Collection' class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that extend concrete subclasses of the &lt;code&gt;java.util.Collection&lt;/code&gt; or &lt;code&gt;java.util.Map&lt;/code&gt; classes.
&lt;p&gt;
  Subclassing concrete collection types is a common yet poor practice. It is considerably more brittle than delegating collection calls.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FrequentlyUsedInheritorInspection" defaultSeverity="INFORMATION" displayName="Class may extend a commonly used base class" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes or interfaces that can be replaced with an implementation or extension of a more specific commonly used class or interface.
&lt;p&gt;For this inspection to work, a superclass needs to be in project source files and the project needs to use the IntelliJ IDEA build system.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyInheritor implements A {} // B suggested on the A reference

  interface A {}

  abstract class B implements A {}

  abstract class C1 extends B {}
  abstract class C2 extends B {}
  abstract class C3 extends B {}
  abstract class C4 extends B {}
  abstract class C5 extends B {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;By default, this inspection doesn't highlight issues in the editor but only provides a quick-fix.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitSubclassInspection" defaultSeverity="ERROR" displayName="Final declaration can't be overridden at runtime" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports cases when your code prevents a class from being subclassed by some framework
(for example, Spring or Hibernate) at runtime.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Typical examples of necessary but impossible subclassing:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;final&lt;/code&gt; classes marked with framework-specific annotations (for example, Spring &lt;code&gt;@Configuration&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;final&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt; methods
    marked with framework-specific annotations (for example, Spring &lt;code&gt;@Transactional&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;methods marked with framework-specific annotations inside &lt;code&gt;final&lt;/code&gt; classes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The list of reported cases depends on the frameworks used.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractMethodWithMissingImplementations" defaultSeverity="WARNING" displayName="Abstract method with missing implementations" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;abstract&lt;/code&gt; methods that are not implemented in every concrete subclass.
&lt;p&gt;
  This results in a compile-time error on the subclasses;
  the inspection reports the problem at the point of the abstract method, allowing faster detection of the problem.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsUtilityClass" defaultSeverity="WARNING" displayName="Class extends utility class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that extend a utility class.
&lt;p&gt;
A utility class is a non-empty class in which all fields and methods are static.
  Extending a utility class also allows for inadvertent object instantiation of the
  utility class, because the constructor cannot be made private in order to allow extension.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Ignore if overriding class is a utility class&lt;/b&gt; option to ignore any classes that override a utility class but are
    also utility classes themselves.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsAnnotation" defaultSeverity="WARNING" displayName="Class extends annotation interface" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes declared as an implementation or extension of an annotation
interface.
&lt;p&gt;While it is legal to extend an annotation interface, it is often done by accident,
  and the result can't be used as an annotation.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InterfaceNeverImplemented" defaultSeverity="WARNING" displayName="Interface which has no concrete subclass" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports interfaces that have no concrete subclasses.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Use the list below to add annotations. Interfaces declared with
    one of these annotations will be ignored by the inspection.
  &lt;/li&gt;
  &lt;li&gt;
    Use the checkbox below to ignore interfaces that only declare constant fields.
    Such interfaces may still be usable even without implementations.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Control flow issues" path="Groovy"><inspection shortName="GroovyConstantIfStatement" defaultSeverity="WARNING" displayName="Constant if statement" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; statements with boolean constant as a condition.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (true) {
      // ...
  }
  if (false) {
      // ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConditionalCanBeElvis" defaultSeverity="INFORMATION" displayName="Ternary expression can be replaced with elvis expression" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports ternary expressions which can be replaced by an elvis expression.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def notNull(o, defaultValue) {
      o != null ? o : defaultValue
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def notNull(o, defaultValue) {
      o ?: defaultValue
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyTrivialConditional" defaultSeverity="WARNING" displayName="Redundant conditional expression" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports ternary conditional operators of the form &lt;code&gt;x ? true : false&lt;/code&gt;
or similar, which can be trivially simplified.

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  foo() ? true : false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
foo()
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyLoopStatementThatDoesntLoop" defaultSeverity="WARNING" displayName="Loop statement that doesn't loop" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; statements whose
bodies are guaranteed to execute at most once. While such statements could be written intentionally, they
are usually a symptom of error.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  for (int i in 0..&amp;lt;10) {
    return
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyReturnFromClosureCanBeImplicit" defaultSeverity="WARNING" displayName="'return' statement can be implicit" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports return statements at the end of closures which can be made implicit.
&lt;p&gt;
  Groovy closures implicitly return the value of the last statement in them.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def foo = {
    return 1
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def foo = {
    1
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyIfStatementWithTooManyBranches" defaultSeverity="WARNING" displayName="If statement with too many branches" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; statements with too many branches.
Such statements may be confusing, and are often the sign of inadequate levels of design
abstraction.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (a) {
  print "foo"
} else if (b) {
  print "bar"
} else if (c) {
  print "baz"
} else if (d) {
  print "Too many branches"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 Use the &lt;b&gt;Maximum number of branches&lt;/b&gt; field to specify the maximum number of branches expected.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyFallthrough" defaultSeverity="WARNING" displayName="Fallthrough in 'switch' statement" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;i&gt;fallthrough&lt;/i&gt; in switch statements.  While occasionally useful, fallthrough is often unintended, and may lead to surprising bugs.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
switch(n) {
  case 1:
    print 1
  case 2: // "case 1" fallthrough to "case 2". Statements from "case 2" will be executed immediately after "case 1".
    print 2
    break
  default:
    print "Default"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GroovyUnnecessaryContinue" defaultSeverity="WARNING" displayName="Unnecessary 'continue' statement" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports &lt;code&gt;continue&lt;/code&gt; statements if they are last reachable statements in the loop.
These &lt;code&gt;continue&lt;/code&gt; statements are unnecessary and can be safely removed.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for(int i in array) {
      println(i)
      &lt;b&gt;continue&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for(int i in array) {
      println(i)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;For more information, see the same inspection in Java.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConditionalWithIdenticalBranches" defaultSeverity="WARNING" displayName="Ternary expression with identical branches" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports ternary expressions with identical "then" and "else" branches. Such expressions are almost certainly a programmer error.
&lt;p&gt;The quick-fix replaces the expression with its "then" branch.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  condition ? a.foo() : a.foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a.foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyIfStatementWithIdenticalBranches" defaultSeverity="WARNING" displayName="If statement with identical branches" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; statements with identical "then" and &lt;code&gt;else&lt;/code&gt; branches.
Such statements are almost certainly programmer error.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (condition) {
  print "foo"
} else {
  print "foo"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
print "foo"
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySwitchStatementWithNoDefault" defaultSeverity="WARNING" displayName="Switch statement with no default case" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;switch&lt;/code&gt; statements that do not contain
&lt;code&gt;default&lt;/code&gt; labels.
&lt;p&gt;
  Some coding practices may insist on adding this label to all &lt;code&gt;switch&lt;/code&gt; statements.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConditionalCanBeConditionalCall" defaultSeverity="INFORMATION" displayName="Ternary expression can be replaced with safe call" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports ternary expressions which can be replaced by a safe call.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def charArray(String s) {
      s == null ? null : s.toCharArray()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def charArray(String s) {
      s?.toCharArray()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyBreak" defaultSeverity="WARNING" displayName="'break' statement" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;break&lt;/code&gt; statements outside of &lt;code&gt;switch&lt;/code&gt; statements.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnnecessaryReturn" defaultSeverity="WARNING" displayName="Unnecessary 'return' statement" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports &lt;code&gt;return&lt;/code&gt; statements at the end of constructors and methods returning
&lt;code&gt;void&lt;/code&gt;. These are unnecessary and may be safely removed.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo (String s){
      print(s)
      &lt;b&gt;return&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo (String s){
      print(s)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;For more information, see the same inspection in Java.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyContinue" defaultSeverity="WARNING" displayName="'continue' statement" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;continue&lt;/code&gt; statements.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrFinalVariableAccess" defaultSeverity="WARNING" displayName="Final variable access" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports uninitialized final fields, invalid assignments to final variables, and parameters and fields.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyTrivialIf" defaultSeverity="WARNING" displayName="Redundant 'if' statement" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; statements which can be simplified to single assignment
or
&lt;code&gt;return&lt;/code&gt; statements.

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (foo())
    return true;
  else
    return false;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConstantConditional" defaultSeverity="WARNING" displayName="Constant conditional expression" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports conditional expressions with boolean constant as a condition.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  true ? result1 : result2
  false ? result1 : result2
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Javadoc" path="Java"><inspection shortName="DanglingJavadoc" defaultSeverity="WARNING" displayName="Dangling Javadoc comment" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Javadoc comments that don't belong to any class, method or field.
The Javadoc tool ignores dangling Javadoc comments and doesn't include them in the HTML documentation it generates.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
    /**
     * Dangling comment
     */
    /**
     * Method javadoc
     */
     public void m(){}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix is available to delete such comments completely or convert them into a block comment. After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
    /*
      Dangling comment
    */
    /**
     * Method javadoc
     */
    public void m(){}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore file header comment in JavaDoc format&lt;/b&gt; option to ignore comments at the beginning of Java files.
These are usually copyright messages.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocHtmlLint" defaultSeverity="ERROR" displayName="HTML problems in Javadoc (DocLint)" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the same HTML issues in the Javadoc comments that have been reported by DocLint since Java 8.
&lt;p&gt;The inspection detects the following issues:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Self-closed, unclosed, unknown, misplaced, or empty tag&lt;/li&gt;
  &lt;li&gt;Unknown or wrong attribute&lt;/li&gt;
  &lt;li&gt;Misplaced text&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * Unknown tag: List&amp;lt;String&amp;gt;
 * Unclosed tag: error&amp;lt;/b&amp;gt;
 * Misplaced text or tag: &amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;one&amp;lt;/li&amp;gt;, &amp;lt;li&amp;gt;two&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
 * Wrong or empty attribute: &amp;lt;a href=""&amp;gt;&amp;lt;/a&amp;gt;
 * Self-closed tag: &amp;lt;br/&amp;gt;
 * ...
 */
void sample(){ }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryInheritDoc" defaultSeverity="WARNING" displayName="Unnecessary '{@inheritDoc}' Javadoc comment" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Javadoc comments that contain only an &lt;code&gt;{@inheritDoc}&lt;/code&gt;
tag. Since Javadoc copies the super class' comment if no comment is present, a
comment containing only &lt;code&gt;{@inheritDoc}&lt;/code&gt; adds nothing.
&lt;p&gt;Also, it reports the &lt;code&gt;{@inheritDoc}&lt;/code&gt; usages in invalid locations, for example, in fields.&lt;/p&gt;
&lt;p&gt;Suggests removing the unnecessary Javadoc comment.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example implements Comparable&amp;lt;Example&amp;gt; {
    /**
     * {@inheritDoc}
     */
    @Override
    public int compareTo(Example o) {
      return 0;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example implements Comparable&amp;lt;Example&amp;gt; {
    @Override
    public int compareTo(Example o) {
      return 0;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryJavaDocLink" defaultSeverity="WARNING" displayName="Unnecessary Javadoc link" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Javadoc &lt;code&gt;@see&lt;/code&gt;,
&lt;code&gt;{@link}&lt;/code&gt;, and &lt;code&gt;{@linkplain}&lt;/code&gt;
tags that refer to the method owning the comment, the super method of the
method owning the comment, or the class containing the comment.
&lt;p&gt;Such links are unnecessary and can be safely removed with this inspection's quick-fix. The
  quick-fix will remove the entire Javadoc comment if the tag is its only content.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example {
    /**
     * @see Example#method
     */
    public void method() { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Example {
  public void method() { }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the checkbox below to ignore inline links (&lt;code&gt;{@link}&lt;/code&gt; and &lt;code&gt;{@linkplain}&lt;/code&gt;)
to super methods. Although a link to all super methods is automatically added by the
Javadoc tool, an inline link to the super method may sometimes be needed in texts of the Javadoc comments.

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingJavadoc" defaultSeverity="WARNING" displayName="Missing Javadoc" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports missing Javadoc comments and tags.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * Missing "@param" is reported (if configured).
   */
  public void sample(int param){
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fixes add missing tag or missing Javadoc comment:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * Missing "@param" is reported (if configured).
   * @param param
   */
  public void sample(int param){
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Inspection can be configured to ignore deprecated elements or simple accessor methods like &lt;code&gt;getField()&lt;/code&gt; or &lt;code&gt;setField()&lt;/code&gt;.
&lt;/p&gt;
You can also use options below to configure required tags and minimal required visibility for the specific code elements
like method, field, class, package, module.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocLinkAsPlainText" defaultSeverity="WARNING" displayName="Link specified as plain text" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports links specified as plain text in Javadoc comments.
&lt;p&gt;
  The quick-fix suggests to wrap the link in &amp;lt;a&amp;gt; tag.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
   /**
    * https://en.wikipedia.org/
    */
    void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
   /**
    * &amp;lt;a href="https://en.wikipedia.org/"&amp;gt;https://en.wikipedia.org/&amp;lt;/a&amp;gt;
    */
    void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2022.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="HtmlTagCanBeJavadocTag" defaultSeverity="WARNING" displayName="'&lt;code&gt;...&lt;/code&gt;' can be replaced with '{@code ...}'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; tags in Javadoc comments.
Since Java 5, these tags can be replaced with &lt;code&gt;{@code ...}&lt;/code&gt; constructs.
This allows using angle brackets &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; inside the comment instead of HTML character entities.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @return empty &amp;lt;code&amp;gt;ArrayList&amp;amp;lt;Integer&amp;amp;gt;&amp;lt;/code&amp;gt;
   */
  List&amp;lt;Integer&amp;gt; getList(){ ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @return empty {@code ArrayList&amp;lt;Integer&amp;gt;}
   */
  List&amp;lt;Integer&amp;gt; getList(){ ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocBlankLines" defaultSeverity="WARNING" displayName="Blank line should be replaced with &lt;p&gt; to break lines" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports blank lines in Javadoc comments.
&lt;p&gt;
  Blank lines in Javadoc may signal an intention split the text to different paragraphs. However, the Javadoc tool and IntelliJ IDEA will
  ignore them when rendering documentation comments.
&lt;/p&gt;
&lt;p&gt;
  The quick-fix suggests to replace the blank line with a paragraph tag (&amp;lt;p&amp;gt;).
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    /**
     * Doesn't do anything.
     *
     * Does absolutely nothing
     */
    void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    /**
     * Doesn't do anything.
     * &amp;lt;p&amp;gt;
     * Does absolutely nothing
     */
    void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2022.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PackageDotHtmlMayBePackageInfo" defaultSeverity="WARNING" displayName="'package.html' may be converted to 'package-info.java'" enabled="false" language="HTML" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any &lt;code&gt;package.html&lt;/code&gt; files which are used for documenting packages.
&lt;p&gt;Since JDK 1.5, it is recommended that you use &lt;code&gt;package-info.java&lt;/code&gt; files instead, as such
files can also contain package annotations. This way, package-info.java becomes a
  sole repository for package level annotations and documentation.&lt;/p&gt;
&lt;p&gt;Example: &lt;code&gt;package.html&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    Documentation example.
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied: &lt;code&gt;package-info.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * Documentation example.
 */
package com.sample;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocReference" defaultSeverity="ERROR" displayName="Declaration has problems in Javadoc references" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unresolved references inside Javadoc comments.
&lt;p&gt;In the following example, the &lt;code&gt;someParam&lt;/code&gt; parameter is missing, so it will be highlighted:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class A {
    /**
     * @param someParam description
     **/
    void foo() {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Disable the &lt;b&gt;Report inaccessible symbols&lt;/b&gt; option to ignore the tags that reference missing method parameters,
  classes, fields and methods.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MissingDeprecatedAnnotation" defaultSeverity="WARNING" displayName="Missing '@Deprecated' annotation" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports module declarations, classes, fields, or methods that have the &lt;code&gt;@deprecated&lt;/code&gt;
Javadoc tag but do not have the &lt;code&gt;@java.lang.Deprecated&lt;/code&gt; annotation.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @deprecated use {@code example()} instead
   */
  void sample(){ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * @deprecated use {@code example()} instead
   */
  @Deprecated
  void sample(){ }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection works only if the language level of the project or module is 5 or higher.&lt;/p&gt;
&lt;p&gt;
Use the checkbox below to be warned on the symbols annotated with &lt;code&gt;@Deprecated&lt;/code&gt; without
  an explanation in the &lt;code&gt;@deprecated&lt;/code&gt; Javadoc tag.

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavadocDeclaration" defaultSeverity="WARNING" displayName="Javadoc declaration problems" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Javadoc comments and tags with the following problems:
&lt;ul&gt;
  &lt;li&gt;invalid tag names&lt;/li&gt;
  &lt;li&gt;incomplete tag descriptions&lt;/li&gt;
  &lt;li&gt;duplicated tags&lt;/li&gt;
  &lt;li&gt;missing Javadoc descriptions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * Invalid tag name
   * @poram param description
   */
  public void sample(int param){
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * Pointing to itself {@link #sample(int)}
   */
  public void sample(int param){
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Quick-fix adds the unknown Javadoc tag to the list of user defined additional tags.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use textfield below to define additional Javadoc tags.&lt;/p&gt;
&lt;p&gt;Use first checkbox to ignore duplicated 'throws' tag.&lt;/p&gt;
&lt;p&gt;Use second checkbox to ignore problem with missing or incomplete first sentence in the description.&lt;/p&gt;
&lt;p&gt;Use third checkbox to ignore references pointing to itself.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingPackageInfo" defaultSeverity="WARNING" displayName="Missing 'package-info.java'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports packages that contain classes but do not contain the &lt;code&gt;package-info.java&lt;/code&gt;
or &lt;code&gt;package.html&lt;/code&gt; files and are, thus, missing the package documentation.
&lt;p&gt;The quick-fix creates an initial &lt;code&gt;package-info.java&lt;/code&gt; file.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageInfoWithoutPackage" defaultSeverity="WARNING" displayName="'package-info.java' without 'package' statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;package-info.java&lt;/code&gt; files without a &lt;code&gt;package&lt;/code&gt; statement.
&lt;p&gt;
The Javadoc tool considers such files documentation for the default package even when the file is located somewhere else.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="EditorConfig" path=""><inspection shortName="EditorConfigValueCorrectness" defaultSeverity="ERROR" displayName="Invalid property value" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports property values that do not meet value restrictions. For example, some properties may be only true or false,
others contain only integer numbers etc. If a value has a limited set of variants, use code completion to see all of them.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigKeyCorrectness" defaultSeverity="WARNING" displayName="Unknown property" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports properties that are not supported by the IDE. Note: some ij domain properties may require specific language plugins.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigUnusedDeclaration" defaultSeverity="WARNING" displayName="Unused declaration" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports unused declarations. Such declarations can be removed.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigDeprecatedDescriptor" defaultSeverity="WARNING" displayName="Deprecated property" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports EditorConfig properties that are no longer supported.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigListAcceptability" defaultSeverity="ERROR" displayName="Unexpected value list" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports lists of values that are used in properties in which lists are not supported. In this case, only a single value can be specified.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigRootDeclarationUniqueness" defaultSeverity="ERROR" displayName="Extra top-level declaration" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports multiple top-level declarations. There can be only one optional root=true top-level declaration in the EditorConfig file.
Using multiple top-level declarations is not allowed.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EditorConfigNumerousWildcards" defaultSeverity="WEAK WARNING" displayName="Too many wildcards" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports sections that contain too many wildcards. Using a lot of wildcards may lead to performance issues.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EditorConfigSpaceInHeader" defaultSeverity="WEAK WARNING" displayName="Space in file pattern" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports space characters in wildcard patterns that affect pattern matching.
If these characters are not intentional, they should be removed.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigShadowedOption" defaultSeverity="WARNING" displayName="Overridden property" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports properties that are already defined in other sections.
&lt;p&gt;For example:
&lt;pre&gt;&lt;code&gt;
[*.java]
indent_size=4
[{*.java,*.js}]
indent_size=2
&lt;/code&gt;&lt;/pre&gt;
The second section includes all &lt;code&gt;*.java&lt;/code&gt; files too but it  also redefines indent_size.
As a result the value 2 will be used for files matching &lt;code&gt;*.java&lt;/code&gt;.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigHeaderUniqueness" defaultSeverity="WARNING" displayName="EditorConfig section is not unique" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports sections that define the same file pattern as other sections.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigEmptyHeader" defaultSeverity="ERROR" displayName="Empty header" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports sections with an empty header. Section header must contain file path globs in the format similar to one supported by &lt;code&gt;gitignore&lt;/code&gt;.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigReferenceCorrectness" defaultSeverity="ERROR" displayName="Invalid reference" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports identifiers that are either unknown or have a wrong type.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigCharClassRedundancy" defaultSeverity="WARNING" displayName="Unnecessary character class" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports character classes that consist of a single character.
Such classes can be simplified to a character, for example &lt;code&gt;[a]&lt;/code&gt;&amp;rarr;&lt;code&gt;a&lt;/code&gt;.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigPatternEnumerationRedundancy" defaultSeverity="ERROR" displayName="Unnecessary braces" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports pattern lists that are either empty &lt;code&gt;{}&lt;/code&gt; or contain just one pattern, for example &lt;code&gt;{foo}&lt;/code&gt;.
The braces are needed only if there are two and more, for example: &lt;code&gt;{foo,bar}&lt;/code&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigNoMatchingFiles" defaultSeverity="WARNING" displayName="No matching files" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports sections with wildcard patterns that do not match any files under the directory in
which the &lt;code&gt;.editorconfig&lt;/code&gt; file is located.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigEmptySection" defaultSeverity="WARNING" displayName="Empty section" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports sections that do not contain any EditorConfig properties.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigMissingRequiredDeclaration" defaultSeverity="ERROR" displayName="Required declarations are missing" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports properties that miss the required declarations. Refer to the documentation for more information.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigPartialOverride" defaultSeverity="WEAK WARNING" displayName="Overlapping sections" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports subsets of files specified in the current section that overlap with other subsets in other sections. For example:
&lt;code&gt;[{foo,bar}]&lt;/code&gt; and &lt;code&gt;[{foo,bas}]&lt;/code&gt; both contain foo.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigEncoding" defaultSeverity="WARNING" displayName="File encoding doesn't match EditorConfig charset" enabled="true" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Checks that current file encoding matches the encoding defined in "charset" property of .editorconfig file.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EditorConfigRootDeclarationCorrectness" defaultSeverity="ERROR" displayName="Unexpected top-level declaration" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports unexpected top-level declarations. Top-level declarations other than root=true are not allowed in the EditorConfig file.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EditorConfigCharClassLetterRedundancy" defaultSeverity="WARNING" displayName="Duplicate character class letter" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports wildcard patterns in the EditorConfig section that contain a duplicate character in the character class, for example &lt;code&gt;[aa]&lt;/code&gt;.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigPatternRedundancy" defaultSeverity="WARNING" displayName="Duplicate or redundant pattern" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports file patterns that are redundant as there already are other patterns that define the same scope of files or even a broader one.
For example, in &lt;code&gt;[{*.java,*}]&lt;/code&gt; the first &lt;code&gt;*.java&lt;/code&gt; pattern defines a narrower scope compared to &lt;code&gt;*&lt;/code&gt;.
That is why it is redundant and can be removed.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigUnexpectedComma" defaultSeverity="ERROR" displayName="Unexpected comma" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports commas that cannot be used in the current context. Commas are allowed only as separators for values in lists.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigValueUniqueness" defaultSeverity="ERROR" displayName="Non-unique list value" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports duplicates in lists of values.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigOptionRedundancy" defaultSeverity="WARNING" displayName="Redundant property" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports properties that are redundant when another applicable section already contains the same property and value.
&lt;p&gt;
For example:
&lt;pre&gt;&lt;code&gt;
[*]
indent_size=4
[*.java]
indent_size=4
&lt;/code&gt;&lt;/pre&gt;
are both applicable to &lt;code&gt;*.java&lt;/code&gt; files and define the same &lt;code&gt;indent_size&lt;/code&gt; value.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigPairAcceptability" defaultSeverity="ERROR" displayName="Unexpected key-value pair" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports key-value pairs that are not allowed in the current context.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigShadowingOption" defaultSeverity="WARNING" displayName="Overriding property" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports properties that override the same properties defined earlier in the file.
&lt;p&gt;For example:
&lt;pre&gt;&lt;code&gt;
[*.java]
indent_size=4
[{*.java,*.js}]
indent_size=2
&lt;/code&gt;&lt;/pre&gt;
The second section includes the same files as &lt;code&gt;[*.java]&lt;/code&gt; but also sets indent_size to value 2.
Thus the first declaration &lt;code&gt;indent_size=4&lt;/code&gt;will be ignored.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EditorConfigWildcardRedundancy" defaultSeverity="WARNING" displayName="Redundant wildcard" enabled="true" language="EditorConfig" pluginId="org.editorconfig.editorconfigjetbrains" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports wildcards that become redundant when the ** wildcard is used in the same section.
&lt;p&gt;
The ** wildcard defines a broader set of files than any other wildcard.
That is why, any other wildcard used in the same section has no affect and can be removed.
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Serialization issues" path="Java"><inspection shortName="SerializableWithUnconstructableAncestor" defaultSeverity="WARNING" displayName="Serializable class with unconstructable ancestor" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Serializable&lt;/code&gt; classes whose closest non-serializable ancestor doesn't have
a no-argument constructor. Such classes cannot be deserialized and will fail with an &lt;code&gt;InvalidClassException&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Ancestor {
    private String name;
    Ancestor(String name) {
      this.name = name;
    }
  }

  // warning on this class because the superclass is not
  // serializable, and its constructor takes arguments
  class Descendant extends Ancestor implements Serializable {
    Descendant() {
      super("Bob");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableInnerClassWithNonSerializableOuterClass" defaultSeverity="WARNING" displayName="Serializable non-'static' inner class with non-Serializable outer class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-static inner classes that implement &lt;code&gt;Serializable&lt;/code&gt;
and are declared inside a class that doesn't implement &lt;code&gt;Serializable&lt;/code&gt;.
&lt;p&gt;
  Such classes are unlikely to serialize correctly due to implicit references to the outer class.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
    class Main implements Serializable {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the following options to configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    List classes whose inheritors should not be reported by this inspection.
    This is meant for classes that inherit
    &lt;code&gt;Serializable&lt;/code&gt; from a superclass but are not intended for serialization.
  &lt;/li&gt;
  &lt;li&gt;
    Whether to ignore &lt;code&gt;Serializable&lt;/code&gt; anonymous classes.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableWithSerialVersionUIDField" defaultSeverity="WARNING" displayName="Non-serializable class with 'serialVersionUID'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-&lt;code&gt;Serializable&lt;/code&gt; classes that define a &lt;code&gt;serialVersionUID&lt;/code&gt;
field. A &lt;code&gt;serialVersionUID&lt;/code&gt; field in that context normally indicates an error
because the field will be ignored and the class will not be serialized.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class IWantToSerializeThis {
    private static final long serialVersionUID = 2669293150219020249L;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableInnerClassHasSerialVersionUIDField" defaultSeverity="WARNING" displayName="Serializable non-static inner class without 'serialVersionUID'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-static inner classes that implement &lt;code&gt;java.io.Serializable&lt;/code&gt;, but do not define a &lt;code&gt;serialVersionUID&lt;/code&gt; field.
&lt;p&gt;
  Without a &lt;code&gt;serialVersionUID&lt;/code&gt; field, any change to the class will make previously
  serialized versions unreadable. It is strongly recommended that &lt;code&gt;Serializable&lt;/code&gt;
  non-static inner classes have a &lt;code&gt;serialVersionUID&lt;/code&gt; field, otherwise the default
  serialization algorithm may result in serialized versions being incompatible between
  compilers due to differences in synthetic accessor methods.
&lt;/p&gt;
&lt;p&gt;
  A quick-fix is suggested to add the missing &lt;code&gt;serialVersionUID&lt;/code&gt; field.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
      class Inner implements Serializable {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
      class Inner implements Serializable {
          private static final long serialVersionUID = -7004458730436243902L;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the following options to configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    List classes whose inheritors should not be reported by this inspection.
    This is meant for classes that inherit
    &lt;code&gt;Serializable&lt;/code&gt; from a superclass but are not intended for serialization.
  &lt;/li&gt;
  &lt;li&gt;
    Whether to ignore &lt;code&gt;Serializable&lt;/code&gt; anonymous classes.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TransientFieldInNonSerializableClass" defaultSeverity="WARNING" displayName="Transient field in non-serializable class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;transient&lt;/code&gt; fields in classes that do not implement &lt;code&gt;java.io.Serializable&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class NonSerializableClass {
    private transient String password;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class NonSerializableClass {
    private String password;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExternalizableWithoutPublicNoArgConstructor" defaultSeverity="WARNING" displayName="'Externalizable' class without 'public' no-arg constructor" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Externalizable&lt;/code&gt; classes without a public no-argument constructor.
&lt;p&gt;When an &lt;code&gt;Externalizable&lt;/code&gt; object is reconstructed, an instance is created using the public
  no-arg constructor before the &lt;code&gt;readExternal&lt;/code&gt; method called. If a public
  no-arg constructor is not available, a &lt;code&gt;java.io.InvalidClassException&lt;/code&gt; will be
  thrown at runtime.
  &lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExternalizableWithSerializationMethods" defaultSeverity="WARNING" displayName="Externalizable class with 'readObject()' or 'writeObject()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Externalizable&lt;/code&gt; classes that define &lt;code&gt;readObject()&lt;/code&gt;
or &lt;code&gt;writeObject()&lt;/code&gt; methods. These methods are not called for serialization of
&lt;code&gt;Externalizable&lt;/code&gt; objects.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Crucial implements Externalizable {
    int value;
    private void readObject(ObjectInputStream in) {
      value = in.readInt();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReadObjectAndWriteObjectPrivate" defaultSeverity="WARNING" displayName="'readObject()' or 'writeObject()' not declared 'private'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Serializable&lt;/code&gt; classes where the &lt;code&gt;readObject&lt;/code&gt;
or &lt;code&gt;writeObject&lt;/code&gt; methods are not declared private.
There is no reason these methods should ever have a higher visibility than &lt;code&gt;private&lt;/code&gt;.
&lt;p&gt;
  A quick-fix is suggested to make the corresponding method &lt;code&gt;private&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Test implements Serializable {
    public void readObject(ObjectInputStream stream) {
      /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Test implements Serializable {
    private void readObject(ObjectInputStream stream) {
      /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TransientFieldNotInitialized" defaultSeverity="WARNING" displayName="Transient field is not initialized on deserialization" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;transient&lt;/code&gt; fields that
are initialized during normal object construction, but whose class does not have a
&lt;code&gt;readObject&lt;/code&gt; method.
&lt;p&gt;
  As &lt;code&gt;transient&lt;/code&gt; fields are not serialized they need
  to be initialized separately in a &lt;code&gt;readObject()&lt;/code&gt; method
  during deserialization.
&lt;/p&gt;
&lt;p&gt;
  Any &lt;code&gt;transient&lt;/code&gt; fields that
  are not initialized during normal object construction are considered to use the default
  initialization and are not reported by this inspection.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person implements Serializable {
    transient String name = "Default"; //warning, can actually be a null after deserialization
    transient String surname; //null is considered the default value and not reported
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparatorNotSerializable" defaultSeverity="WARNING" displayName="'Comparator' class not declared 'Serializable'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that implement &lt;code&gt;java.lang.Comparator&lt;/code&gt;,
but do not implement &lt;code&gt;java.io.Serializable&lt;/code&gt;.
&lt;p&gt;
  If a non-serializable comparator is used to construct an ordered collection such
  as a &lt;code&gt;java.util.TreeMap&lt;/code&gt; or &lt;code&gt;java.util.TreeSet&lt;/code&gt;, then the
  collection will also be non-serializable. This can result in unexpected and
  difficult-to-diagnose bugs.
&lt;/p&gt;
&lt;p&gt;
  Since subclasses of &lt;code&gt;java.lang.Comparator&lt;/code&gt; are often stateless,
  simply marking them serializable is a small cost to avoid such issues.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo implements Comparator { // warning
      @Override
      public int compare(Object o1, Object o2) {
          /* ... */
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo implements Comparator, Serializable { // no warning here
      @Override
      public int compare(Object o1, Object o2) {
          /* ... */
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReadObjectInitialization" defaultSeverity="WARNING" displayName="Instance field may not be initialized by 'readObject()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields that are not guaranteed to be initialized after the object is
deserialized by the &lt;code&gt;readObject()&lt;/code&gt; method.
&lt;p&gt;The inspection doesn't report transient fields.&lt;/p&gt;
&lt;p&gt;
  Note: This inspection uses a very conservative control flow algorithm, and may incorrectly report fields
  as uninitialized.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class DataObject implements Serializable {
  String s; // s is not initialized in readObject
  int i;

  private void readObject(ObjectInputStream stream) throws IOException {
    i = stream.readInt();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerialPersistentFieldsWithWrongSignature" defaultSeverity="WARNING" displayName="'serialPersistentFields' field not declared 'private static final ObjectStreamField[]'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Serializable&lt;/code&gt; classes whose &lt;code&gt;serialPersistentFields&lt;/code&gt; field
is not declared as &lt;code&gt;private static final ObjectStreamField[]&lt;/code&gt;.
&lt;p&gt;
  If a &lt;code&gt;serialPersistentFields&lt;/code&gt; field is not declared with those modifiers,
  the serialization behavior will be as if the field was not declared at all.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class List implements Serializable {
    private List next;

    ObjectStreamField[] serialPersistentFields = {new ObjectStreamField("next", List.class)};

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableHasSerializationMethods" defaultSeverity="WARNING" displayName="Serializable class without 'readObject()' and 'writeObject()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Serializable&lt;/code&gt; classes
that do not implement &lt;code&gt;readObject()&lt;/code&gt; and &lt;code&gt;writeObject()&lt;/code&gt; methods.
&lt;p&gt;
  If &lt;code&gt;readObject()&lt;/code&gt; and &lt;code&gt;writeObject()&lt;/code&gt; methods are not implemented,
  the default serialization algorithms are used,
  which may be sub-optimal for performance and compatibility in many environments.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the following options to configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    List classes whose inheritors should not be reported by this inspection.
    This is meant for classes that inherit
    &lt;code&gt;Serializable&lt;/code&gt; from a superclass but are not intended for serialization.
  &lt;/li&gt;
  &lt;li&gt;
    Whether to ignore &lt;code&gt;Serializable&lt;/code&gt; classes without non-static fields.
  &lt;/li&gt;
  &lt;li&gt;
    Whether to ignore &lt;code&gt;Serializable&lt;/code&gt; anonymous classes.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableWithSerializationMethods" defaultSeverity="WARNING" displayName="Non-serializable class with 'readObject()' or 'writeObject()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-&lt;code&gt;Serializable&lt;/code&gt; classes that define &lt;code&gt;readObject()&lt;/code&gt;
or &lt;code&gt;writeObject()&lt;/code&gt; methods. Such methods in that context normally indicate an error.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class SampleClass {
    private void readObject(ObjectInputStream str) {}
    private void writeObject(ObjectOutputStream str) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableRecordContainsIgnoredMembers" defaultSeverity="WARNING" displayName="'record' contains ignored members" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports serialization methods or fields defined in a &lt;code&gt;record&lt;/code&gt; class.
Serialization methods include &lt;code&gt;writeObject()&lt;/code&gt;, &lt;code&gt;readObject()&lt;/code&gt;, &lt;code&gt;readObjectNoData()&lt;/code&gt;, &lt;code&gt;writeExternal()&lt;/code&gt;, and
  &lt;code&gt;readExternal()&lt;/code&gt; and the field &lt;code&gt;serialPersistentFields&lt;/code&gt;.
  These members are not used for the serialization or deserialization of records and therefore unnecessary.
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record R1() implements Serializable {
    // The field is ignored during record serialization
    @Serial
    private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];

    // The method is ignored during record serialization
    @Serial
    private void writeObject(ObjectOutputStream out) throws IOException {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
  record R2() implements Externalizable {
    // The method is ignored during record serialization
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
    }

    // The method is ignored during record serialization
    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 14 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2020.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableFieldInSerializableClass" defaultSeverity="WARNING" displayName="Non-serializable field in a 'Serializable' class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-serializable fields in classes that implement &lt;code&gt;java.io.Serializable&lt;/code&gt;. Such fields will result
in runtime exceptions if the object is serialized.
&lt;p&gt;
  Fields declared
  &lt;code&gt;transient&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;
  are not reported, nor are fields of classes that have a &lt;code&gt;writeObject&lt;/code&gt; method defined.
&lt;/p&gt;
&lt;p&gt;
  This inspection assumes fields of the types
  &lt;code&gt;java.util.Collection&lt;/code&gt; and
  &lt;code&gt;java.util.Map&lt;/code&gt; to be
  &lt;code&gt;Serializable&lt;/code&gt;, unless the types
  they are declared in are non-&lt;code&gt;Serializable&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class NonSerializableClass {}

  public class SerializableClass implements Serializable {
      NonSerializableClass clazz; // warning: Non-serializable field 'clazz' in a Serializable class
      static NonSerializableClass staticClazz; // no warnings
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the following options to configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    List classes whose inheritors should not be reported by this inspection.
    This is meant for classes that inherit
    &lt;code&gt;Serializable&lt;/code&gt; from a superclass but are not intended for serialization.
  &lt;/li&gt;
  &lt;li&gt;
    List annotations that will make the inspection ignore the annotated fields.
  &lt;/li&gt;
  &lt;li&gt;
    Whether to ignore fields initialized with an anonymous class.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableObjectPassedToObjectStream" defaultSeverity="WARNING" displayName="Non-serializable object passed to 'ObjectOutputStream'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-&lt;code&gt;Serializable&lt;/code&gt; objects used as arguments to
&lt;code&gt;java.io.ObjectOutputStream.write()&lt;/code&gt;. Such calls will result in runtime exceptions.
&lt;p&gt;
  This inspection assumes objects of the types &lt;code&gt;java.util.Collection&lt;/code&gt; and
  &lt;code&gt;java.util.Map&lt;/code&gt; to be &lt;code&gt;Serializable&lt;/code&gt;, unless the types
  they are declared in are non-&lt;code&gt;Serializable&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class IWantToSerializeThis {
    public static void main(String[] args) throws IOException {
      try(var stream = new ObjectOutputStream(Files.newOutputStream(Paths.get("output")))) {
        // Warning -- will fail with NotSerializableException
        stream.writeObject(new IWantToSerializeThis());
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingSerialAnnotation" defaultSeverity="WARNING" displayName="'@Serial' annotation could be used" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods and fields in the &lt;code&gt;Serializable&lt;/code&gt; and &lt;code&gt;Externalizable&lt;/code&gt;
classes that are suitable to be annotated with the &lt;code&gt;java.io.Serial&lt;/code&gt; annotation. The quick-fix adds the annotation.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Main implements Serializable {
  private static final long serialVersionUID = 7874493593505141603L;

  private void writeObject(ObjectOutputStream out) throws IOException {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Serializable {
    @Serial
    private static final long serialVersionUID = 7874493593505141603L;

    @Serial
    private void writeObject(ObjectOutputStream out) throws IOException {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Externalizable {
    protected Object readResolve() throws ObjectStreamException {
      return "SomeObject";
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Externalizable {
    @Serial
    protected Object readResolve() throws ObjectStreamException {
        return "SomeObject";
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For more information about all possible cases, refer the documentation for &lt;code&gt;java.io.Serial&lt;/code&gt;.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 14 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2020.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerialVersionUIDNotStaticFinal" defaultSeverity="WARNING" displayName="'serialVersionUID' field not declared 'private static final long'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Serializable&lt;/code&gt; classes whose &lt;code&gt;serialVersionUID&lt;/code&gt; field
is not declared &lt;code&gt;private static final long&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SampleClass implements Serializable {
    private long serialVersionUID = 1; // field of a Serializable class is not declared 'private static final long'

    public SampleClass() {
        System.out.println(serialVersionUID);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReadResolveAndWriteReplaceProtected" defaultSeverity="WARNING" displayName="'readResolve()' or 'writeReplace()' not declared 'protected'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that implement &lt;code&gt;java.io.Serializable&lt;/code&gt; where the &lt;code&gt;readResolve()&lt;/code&gt;
or &lt;code&gt;writeReplace()&lt;/code&gt; methods are not declared &lt;code&gt;protected&lt;/code&gt;.
&lt;p&gt;
  Declaring &lt;code&gt;readResolve()&lt;/code&gt; and &lt;code&gt;writeReplace()&lt;/code&gt; methods &lt;code&gt;private&lt;/code&gt;
  can force subclasses to silently ignore them, while declaring them
  &lt;code&gt;public&lt;/code&gt; allows them to be invoked by untrusted code.
&lt;/p&gt;
&lt;p&gt;
  If the containing class is declared &lt;code&gt;final&lt;/code&gt;, these methods can be declared &lt;code&gt;private&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class ClassWithSerialization implements Serializable {
    public Object writeReplace() { // warning: 'writeReplace()' not declared protected
        ...
    }
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableStoresNonSerializable" defaultSeverity="WARNING" displayName="'Serializable' object implicitly stores non-'Serializable' object" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any references to local non-&lt;code&gt;Serializable&lt;/code&gt; variables
outside &lt;code&gt;Serializable&lt;/code&gt; lambdas, local and anonymous classes.
&lt;p&gt;
  When a local variable is referenced from an anonymous class, its value
  is stored in an implicit field of that class. The same happens
  for local classes and lambdas. If the variable is of a
  non-&lt;code&gt;Serializable&lt;/code&gt; type, serialization will fail.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface A extends Serializable {
      abstract void foo();
  }
  class B {}
  class C {
      void foo() {
          B b = new B();
          A a = new A() {
              @Override
              public void foo() {
                  System.out.println(b); // warning
              }
          };
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerialAnnotationUsedOnWrongMember" defaultSeverity="WARNING" displayName="'@Serial' annotation used on wrong member" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods and fields in the &lt;code&gt;Serializable&lt;/code&gt; and &lt;code&gt;Externalizable&lt;/code&gt;
classes that are not suitable to be annotated with the &lt;code&gt;java.io.Serial&lt;/code&gt; annotation.
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Test implements Serializable {
  @Serial // The annotated field is not a part of serialization mechanism because it's not final
  private static long serialVersionUID = 7874493593505141603L;

  @Serial // The annotated method is not a part of the serialization mechanism because it's not private
  void writeObject(ObjectOutputStream out) throws IOException {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
class Test implements Externalizable {
  @Serial // The annotated method is not a part of the serialization mechanism as it's inside Externalizable class
  private void writeObject(ObjectOutputStream out) throws IOException {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For information about all valid cases, refer the documentation for &lt;code&gt;java.io.Serial&lt;/code&gt;.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 14 or higher.
&lt;p&gt;&lt;small&gt;New in 2020.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSerializableObjectBoundToHttpSession" defaultSeverity="WARNING" displayName="Non-serializable object bound to 'HttpSession'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports objects of classes not implementing &lt;code&gt;java.io.Serializable&lt;/code&gt; used as arguments to
&lt;code&gt;javax.servlet.http.HttpSession.setAttribute()&lt;/code&gt; or
&lt;code&gt;javax.servlet.http.HttpSession.putValue()&lt;/code&gt;.
&lt;p&gt;
  Such objects will not be serialized if the &lt;code&gt;HttpSession&lt;/code&gt; is passivated or migrated,
  and may result in difficult-to-diagnose bugs.
&lt;/p&gt;
&lt;p&gt;
  This inspection assumes objects of the types &lt;code&gt;java.util.Collection&lt;/code&gt; and
  &lt;code&gt;java.util.Map&lt;/code&gt; to be &lt;code&gt;Serializable&lt;/code&gt;,
  unless type parameters are non-&lt;code&gt;Serializable&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(HttpSession session) {
      session.setAttribute("foo", new NonSerializable());
  }
  static class NonSerializable {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Pattern validation" path=""><inspection shortName="PatternNotApplicable" defaultSeverity="ERROR" displayName="Pattern Annotation not applicable" enabled="true" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports when a &lt;code&gt;@Pattern&lt;/code&gt; annotation is applied to an element with a type other than &lt;code&gt;String&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Pattern("\\d\\d") &lt;b&gt;int&lt;/b&gt; i;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PatternOverriddenByNonAnnotatedMethod" defaultSeverity="WARNING" displayName="Non-annotated Method overrides @Pattern Method" enabled="true" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports when a method without any &lt;code&gt;@Pattern&lt;/code&gt; annotation overrides a &lt;code&gt;@Pattern&lt;/code&gt; annotated method.
This does not prevent error-highlighting inside the editor, however the overriding method will not be checked at runtime.
&lt;p&gt;
A quick fix is provided to add a &lt;code&gt;@Pattern&lt;/code&gt; annotation that matches the one from the superclass method. This ensures the
runtime-check instrumentation works correctly.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Parent {
    abstract @Pattern("\\d\\d-\\d\\d\\d") String getId();
  }
  class Child extends Parent {
    @Override String getId() { // warning here
      return "12-345";
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PatternValidation" defaultSeverity="WARNING" displayName="Validate annotated patterns" enabled="true" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports expressions passed as arguments for &lt;code&gt;@Pattern&lt;/code&gt; parameters and
returned from &lt;code&gt;@Pattern&lt;/code&gt;-annotated methods that do not match the specified pattern.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Pattern("\\d\\d-\\d\\d\\d") String getId() {
    &lt;b&gt;return&lt;/b&gt; "1";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Android Lint: Usability" path="Android/Lint/Usability"><inspection shortName="AndroidLintConvertToWebp" defaultSeverity="WARNING" displayName="Convert to WebP" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Convert to WebP&lt;br&gt;&lt;br&gt;The WebP format is typically more compact than PNG and JPEG. As of Android 4.2.1 it supports transparency and lossless conversion as well. Note that there is a quickfix in the IDE which lets you perform conversion.&lt;br/&gt;
&lt;br/&gt;
Previously, launcher icons were required to be in the PNG format but that restriction is no longer there, so lint now flags these.&lt;br&gt;&lt;br&gt;Issue id: ConvertToWebp&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconLauncherShape" defaultSeverity="WARNING" displayName="The launcher icon shape should use a distinct silhouette" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;The launcher icon shape should use a distinct silhouette&lt;br&gt;&lt;br&gt;According to the Android Design Guide (&lt;a href="https://material.io/design/iconography/"&gt;https://material.io/design/iconography/&lt;/a&gt;) your launcher icons should "use a distinct silhouette", a "three-dimensional, front view, with a slight perspective as if viewed from above, so that users perceive some depth."&lt;br/&gt;
&lt;br/&gt;
The unique silhouette implies that your launcher icon should not be a filled square.&lt;br&gt;&lt;br&gt;Issue id: IconLauncherShape&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconXmlAndPng" defaultSeverity="WARNING" displayName="Icon is specified both as .xml file and as a bitmap" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon is specified both as &lt;code&gt;.xml&lt;/code&gt; file and as a bitmap&lt;br&gt;&lt;br&gt;If a drawable resource appears as an &lt;code&gt;.xml&lt;/code&gt; file in the &lt;code&gt;drawable/&lt;/code&gt; folder, it's usually not intentional for it to also appear as a bitmap using the same name; generally you expect the drawable XML file to define states and each state has a corresponding drawable bitmap.&lt;br&gt;&lt;br&gt;Issue id: IconXmlAndPng&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyFractions" defaultSeverity="WARNING" displayName="Fraction string can be replaced with fraction character" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Fraction string can be replaced with fraction character&lt;br&gt;&lt;br&gt;You can replace certain strings, such as 1/2, and 1/4, with dedicated characters for these, such as  (&amp;amp;#189;) and  (&amp;amp;#188;). This can help make the text more readable.&lt;br&gt;&lt;br&gt;Issue id: TypographyFractions&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Number_Forms"&gt;https://en.wikipedia.org/wiki/Number_Forms&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconExtension" defaultSeverity="WARNING" displayName="Icon format does not match the file extension" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon format does not match the file extension&lt;br&gt;&lt;br&gt;Ensures that icons have the correct file extension (e.g. a &lt;code&gt;.png&lt;/code&gt; file is really in the PNG format and not for example a GIF file named &lt;code&gt;.png&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: IconExtension&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMonochromeLauncherIcon" defaultSeverity="WARNING" displayName="Monochrome icon is not defined" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Monochrome icon is not defined&lt;br&gt;&lt;br&gt;If &lt;code&gt;android:roundIcon&lt;/code&gt; and &lt;code&gt;android:icon&lt;/code&gt; are both in your manifest, you must either remove the reference to &lt;code&gt;android:roundIcon&lt;/code&gt; if it is not needed; or, supply the monochrome icon in the drawable defined by the &lt;code&gt;android:roundIcon&lt;/code&gt; and &lt;code&gt;android:icon&lt;/code&gt; attribute.&lt;br/&gt;
&lt;br/&gt;
For example, if &lt;code&gt;android:roundIcon&lt;/code&gt; and &lt;code&gt;android:icon&lt;/code&gt; are both in the manifest, a launcher might choose to use &lt;code&gt;android:roundIcon&lt;/code&gt; over &lt;code&gt;android:icon&lt;/code&gt; to display the adaptive app icon. Therefore, your themed application iconwill not show if your monochrome attribute is not also specified in &lt;code&gt;android:roundIcon&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: MonochromeLauncherIcon&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconColors" defaultSeverity="WARNING" displayName="Icon colors do not follow the recommended visual style" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon colors do not follow the recommended visual style&lt;br&gt;&lt;br&gt;Notification icons and Action Bar icons should only white and shades of gray. See the Android Design Guide for more details. Note that the way Lint decides whether an icon is an action bar icon or a notification icon is based on the filename prefix: &lt;code&gt;ic_menu_&lt;/code&gt; for action bar icons, &lt;code&gt;ic_stat_&lt;/code&gt; for notification icons etc. These correspond to the naming conventions documented in &lt;a href="https://material.io/design/iconography/"&gt;https://material.io/design/iconography/&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: IconColors&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconMixedNinePatch" defaultSeverity="WARNING" displayName="Clashing PNG and 9-PNG files" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Clashing PNG and 9-PNG files&lt;br&gt;&lt;br&gt;If you accidentally name two separate resources &lt;code&gt;file.png&lt;/code&gt; and &lt;code&gt;file.9.png&lt;/code&gt;, the image file and the nine patch file will both map to the same drawable resource, &lt;code&gt;@drawable/file&lt;/code&gt;, which is probably not what was intended.&lt;br&gt;&lt;br&gt;Issue id: IconMixedNinePatch&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconLocation" defaultSeverity="WARNING" displayName="Image defined in density-independent drawable folder" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Image defined in density-independent drawable folder&lt;br&gt;&lt;br&gt;The res/drawable folder is intended for density-independent graphics such as shapes defined in XML. For bitmaps, move it to &lt;code&gt;drawable-mdpi&lt;/code&gt; and consider providing higher and lower resolution versions in &lt;code&gt;drawable-ldpi&lt;/code&gt;, &lt;code&gt;drawable-hdpi&lt;/code&gt; and &lt;code&gt;drawable-xhdpi&lt;/code&gt;. If the icon &lt;b&gt;really&lt;/b&gt; is density independent (for example a solid color) you can place it in &lt;code&gt;drawable-nodpi&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: IconLocation&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/practices/screens_support.html"&gt;https://developer.android.com/guide/practices/screens_support.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAllCaps" defaultSeverity="WARNING" displayName="Combining textAllCaps and markup" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Combining textAllCaps and markup&lt;br&gt;&lt;br&gt;The textAllCaps text transform will end up calling &lt;code&gt;toString&lt;/code&gt; on the &lt;code&gt;CharSequence&lt;/code&gt;, which has the net effect of removing any markup such as &lt;code&gt;&amp;lt;b&gt;&lt;/code&gt;. This check looks for usages of strings containing markup that also specify &lt;code&gt;textAllCaps=true&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AllCaps&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconDensities" defaultSeverity="WARNING" displayName="Icon densities validation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon densities validation&lt;br&gt;&lt;br&gt;Icons will look best if a custom version is provided for each of the major screen density classes (low, medium, high, extra high). This lint check identifies icons which do not have complete coverage across the densities.&lt;br/&gt;
&lt;br/&gt;
Low density is not really used much anymore, so this check ignores the ldpi density. To force lint to include it, set the environment variable &lt;code&gt;ANDROID_LINT_INCLUDE_LDPI=true&lt;/code&gt;. For more information on current density usage, see &lt;a href="https://developer.android.com/about/dashboards"&gt;https://developer.android.com/about/dashboards&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: IconDensities&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/practices/screens_support.html"&gt;https://developer.android.com/guide/practices/screens_support.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyOther" defaultSeverity="WARNING" displayName="Other typographical problems" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Other typographical problems&lt;br&gt;&lt;br&gt;This check looks for miscellaneous typographical problems and offers replacement                     sequences that will make the text easier to read and your application more                     polished.&lt;br&gt;&lt;br&gt;Issue id: TypographyOther&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGifUsage" defaultSeverity="WARNING" displayName="Using .gif format for bitmaps is discouraged" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;.gif&lt;/code&gt; format for bitmaps is discouraged&lt;br&gt;&lt;br&gt;The &lt;code&gt;.gif&lt;/code&gt; file format is discouraged. Consider using &lt;code&gt;.png&lt;/code&gt; (preferred) or &lt;code&gt;.jpg&lt;/code&gt; (acceptable) instead.&lt;br&gt;&lt;br&gt;Issue id: GifUsage&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource.html#Bitmap"&gt;https://developer.android.com/guide/topics/resources/drawable-resource.html#Bitmap&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyEllipsis" defaultSeverity="WARNING" displayName="Ellipsis string can be replaced with ellipsis character" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Ellipsis string can be replaced with ellipsis character&lt;br&gt;&lt;br&gt;You can replace the string "..." with a dedicated ellipsis character, ellipsis character (u2026, &amp;amp;#8230;). This can help make the text more readable.&lt;br&gt;&lt;br&gt;Issue id: TypographyEllipsis&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Ellipsis"&gt;https://en.wikipedia.org/wiki/Ellipsis&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyDashes" defaultSeverity="WARNING" displayName="Hyphen can be replaced with dash" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hyphen can be replaced with dash&lt;br&gt;&lt;br&gt;The "n dash" (u2013, &amp;amp;#8211;) and the "m dash" (u2014, &amp;amp;#8212;) characters are used for ranges (n dash) and breaks (m dash). Using these instead of plain hyphens can make text easier to read and your application will look more polished.&lt;br&gt;&lt;br&gt;Issue id: TypographyDashes&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Dash"&gt;https://en.wikipedia.org/wiki/Dash&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypographyQuotes" defaultSeverity="WARNING" displayName="Straight quotes can be replaced with curvy quotes" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Straight quotes can be replaced with curvy quotes&lt;br&gt;&lt;br&gt;Straight single quotes and double quotes, when used as a pair, can be replaced by "curvy quotes" (or directional quotes). This can make the text more readable. Note that you should never use grave accents and apostrophes to quote, `like this'. (Also note that you should not use curvy quotes for code fragments.)&lt;br&gt;&lt;br&gt;Issue id: TypographyQuotes&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Quotation_mark"&gt;https://en.wikipedia.org/wiki/Quotation_mark&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingApplicationIcon" defaultSeverity="WARNING" displayName="Missing application icon" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing application icon&lt;br&gt;&lt;br&gt;You should set an icon for the application as whole because there is no default. This attribute must be set as a reference to a drawable resource containing the image (for example &lt;code&gt;@drawable/icon&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: MissingApplicationIcon&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/studio/publish/preparing#publishing-configure"&gt;https://developer.android.com/studio/publish/preparing#publishing-configure&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMipmapIcons" defaultSeverity="WARNING" displayName="Use Mipmap Launcher Icons" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use Mipmap Launcher Icons&lt;br&gt;&lt;br&gt;Launcher icons should be provided in the &lt;code&gt;mipmap&lt;/code&gt; resource directory. This is the same as the &lt;code&gt;drawable&lt;/code&gt; resource directory, except resources in the &lt;code&gt;mipmap&lt;/code&gt; directory will not get stripped out when creating density-specific APKs.&lt;br/&gt;
&lt;br/&gt;
In certain cases, the Launcher app may use a higher resolution asset (than would normally be computed for the device) to display large app shortcuts. If drawables for densities other than the device's resolution have been stripped out, then the app shortcut could appear blurry.&lt;br/&gt;
&lt;br/&gt;
To fix this, move your launcher icons from `drawable-`dpi to `mipmap-`dpi and change references from @drawable/ and R.drawable to @mipmap/ and R.mipmap.&lt;br/&gt;
&lt;br/&gt;
In Android Studio this lint warning has a quickfix to perform this automatically.&lt;br&gt;&lt;br&gt;Issue id: MipmapIcons&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconExpectedSize" defaultSeverity="WARNING" displayName="Icon has incorrect size" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon has incorrect size&lt;br&gt;&lt;br&gt;There are predefined sizes (for each density) for launcher icons. You should follow these conventions to make sure your icons fit in with the overall look of the platform.&lt;br&gt;&lt;br&gt;Issue id: IconExpectedSize&lt;br&gt;&lt;br&gt;&lt;a href="https://material.io/design/iconography/"&gt;https://material.io/design/iconography/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconMissingDensityFolder" defaultSeverity="WARNING" displayName="Missing density folder" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing density folder&lt;br&gt;&lt;br&gt;Icons will look best if a custom version is provided for each of the major screen density classes (low, medium, high, extra-high, extra-extra-high). This lint check identifies folders which are missing, such as &lt;code&gt;drawable-hdpi&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Low density is not really used much anymore, so this check ignores the ldpi density. To force lint to include it, set the environment variable &lt;code&gt;ANDROID_LINT_INCLUDE_LDPI=true&lt;/code&gt;. For more information on current density usage, see &lt;a href="https://developer.android.com/about/dashboards"&gt;https://developer.android.com/about/dashboards&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: IconMissingDensityFolder&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/practices/screens_support.html"&gt;https://developer.android.com/guide/practices/screens_support.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconDuplicatesConfig" defaultSeverity="WARNING" displayName="Identical bitmaps across various configurations" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Identical bitmaps across various configurations&lt;br&gt;&lt;br&gt;If an icon is provided under different configuration parameters such as &lt;code&gt;drawable-hdpi&lt;/code&gt; or &lt;code&gt;-v11&lt;/code&gt;, they should typically be different. This detector catches cases where the same icon is provided in different configuration folder which is usually not intentional.&lt;br&gt;&lt;br&gt;Issue id: IconDuplicatesConfig&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconNoDpi" defaultSeverity="WARNING" displayName="Icon appears in both -nodpi and dpi folders" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon appears in both &lt;code&gt;-nodpi&lt;/code&gt; and dpi folders&lt;br&gt;&lt;br&gt;Bitmaps that appear in &lt;code&gt;drawable-nodpi&lt;/code&gt; folders will not be scaled by the Android framework. If a drawable resource of the same name appears &lt;b&gt;both&lt;/b&gt; in a &lt;code&gt;-nodpi&lt;/code&gt; folder as well as a dpi folder such as &lt;code&gt;drawable-hdpi&lt;/code&gt;, then the behavior is ambiguous and probably not intentional. Delete one or the other, or use different names for the icons.&lt;br&gt;&lt;br&gt;Issue id: IconNoDpi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWebpUnsupported" defaultSeverity="ERROR" displayName="WebP Unsupported" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WebP Unsupported&lt;br&gt;&lt;br&gt;The WebP format requires Android 4.0 (API 15). Certain features, such as lossless encoding and transparency, requires Android 4.2.1 (API 18; API 17 is 4.2.0.)&lt;br&gt;&lt;br&gt;Issue id: WebpUnsupported&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconDuplicates" defaultSeverity="WARNING" displayName="Duplicated icons under different names" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicated icons under different names&lt;br&gt;&lt;br&gt;If an icon is repeated under different names, you can consolidate and just use one of the icons and delete the others to make your application smaller. However, duplicated icons usually are not intentional and can sometimes point to icons that were accidentally overwritten or accidentally not updated.&lt;br&gt;&lt;br&gt;Issue id: IconDuplicates&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIconDipSize" defaultSeverity="WARNING" displayName="Icon density-independent size validation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Icon density-independent size validation&lt;br&gt;&lt;br&gt;Checks the all icons which are provided in multiple densities, all compute to roughly the same density-independent pixel (&lt;code&gt;dip&lt;/code&gt;) size. This catches errors where images are either placed in the wrong folder, or icons are changed to new sizes but some folders are forgotten.&lt;br&gt;&lt;br&gt;Issue id: IconDipSize&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSquareAndRoundTilePreviews" defaultSeverity="WARNING" displayName="TileProvider does not have round and square previews" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TileProvider does not have round and square previews&lt;br&gt;&lt;br&gt;Tile projects should specify preview resources for different screen shapes. The preview resource is specified in the manifest under tile service. And you have to make sure they have resources for different screen shapes.&lt;br&gt;&lt;br&gt;Issue id: SquareAndRoundTilePreviews&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Screen sizes" path="Android/Lint"><inspection shortName="ButtonSize" defaultSeverity="WARNING" displayName="Button size" enabled="true" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
Detects layouts where a button is wider than the recommended 320dp.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BottomAppBar" defaultSeverity="WARNING" displayName="Bottom app bar" enabled="true" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
Detects layouts where a BottomAppBar is used on non-compact screens.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Overlap" defaultSeverity="WARNING" displayName="Overlap" enabled="true" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
Detects layouts where a view is at least 50% covered by another sibling view.
The analysis is restricted to covered text views as they are the most likely to be wrongly covered by another view.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BottomNav" defaultSeverity="WARNING" displayName="Bottom nav" enabled="true" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
Detects layouts where a BottomNavigationView is wider than 600dp.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocaleText" defaultSeverity="WARNING" displayName="Locale text" enabled="true" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
Detects layouts with text that behaves differently in different locales.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WearMargin" defaultSeverity="WARNING" displayName="Wear margins" enabled="true" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
Detects layouts where views are too close to the side of Wear OS devices.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AccessibilityTestFramework" defaultSeverity="WARNING" displayName="Accessibility" enabled="true" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
Detects layouts with accessibility issues.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Bounds" defaultSeverity="WARNING" displayName="Bounds" enabled="true" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
Detects layouts where a child view is not fully contained within the bounds of its parent.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LongText" defaultSeverity="WARNING" displayName="Long text" enabled="true" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
Detects layouts where a line of text is longer than 120 characters.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TextFieldSize" defaultSeverity="WARNING" displayName="Text field size" enabled="true" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;!--
  ~ Copyright (C) 2022 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
Detects layouts where a text field is wider than the recommended 488dp.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Nullability problems" path="Java/Probable bugs"><inspection shortName="UnsatisfiedRange" defaultSeverity="WARNING" displayName="Return value is outside of declared range" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports numeric values returned from methods that don't conform to the declared method return range.
You can declare method return range using a number of annotations:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;org.jetbrains.annotations.Range&lt;/code&gt; from JetBrains annotations package (specify 'from' and 'to')&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.checkerframework.common.value.qual.IntRange&lt;/code&gt; from Checker Framework annotations package (specify 'from' and 'to')&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.checkerframework.checker.index.qual.GTENegativeOne&lt;/code&gt; from Checker Framework annotations package (range is '&gt;= -1')&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.checkerframework.checker.index.qual.NonNegative&lt;/code&gt; from Checker Framework annotations package (range is '&gt;= 0')&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.checkerframework.checker.index.qual.Positive&lt;/code&gt; from Checker Framework annotations package (range is '&gt; 0')&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.Nonnegative&lt;/code&gt; from JSR 305 annotations package (range is '&gt;= 0')&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.validation.constraints.Min&lt;/code&gt; (specify minimum value)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.validation.constraints.Max&lt;/code&gt; (specify maximum value)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Range(from = 0, to = Integer.MAX_VALUE) int getValue() {
    // Warning: -1 is outside of declared range
    return -1;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2021.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReturnNull" defaultSeverity="WARNING" displayName="Return of 'null'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;return&lt;/code&gt; statements with &lt;code&gt;null&lt;/code&gt; return values.
While occasionally useful, this construct may make the code more prone
to failing with a &lt;code&gt;NullPointerException&lt;/code&gt;.
&lt;p&gt;
  If a method is designed to return &lt;code&gt;null&lt;/code&gt;, it is suggested to mark it with the
  &lt;code&gt;@Nullable&lt;/code&gt; annotation - such methods will be ignored by this inspection.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    public String getName () {
      return null;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    @Nullable
    public String getName () {
      return null;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  If the return type is &lt;code&gt;java.util.Optional&lt;/code&gt;, an additional quick-fix to convert
  &lt;code&gt;null&lt;/code&gt; to &lt;code&gt;Optional.empty()&lt;/code&gt; is suggested.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the following options to configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Whether to ignore &lt;code&gt;private&lt;/code&gt; methods.
    This will also ignore return of &lt;code&gt;null&lt;/code&gt; from anonymous classes and lambdas.
  &lt;/li&gt;
  &lt;li&gt;
    Whether &lt;code&gt;null&lt;/code&gt; values on array returns, collection
    object returns, plain object returns, or a combination of the three should be reported.
    Return of &lt;code&gt;null&lt;/code&gt; in methods with return type &lt;code&gt;java.util.Optional&lt;/code&gt; are always reported.
  &lt;/li&gt;
  &lt;li&gt;
    Click &lt;b&gt;Configure annotations&lt;/b&gt; to specify which annotations should be considered 'nullable'.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NullableProblems" defaultSeverity="WARNING" displayName="@NotNull/@Nullable problems" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports problems related to nullability annotations.
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Overriding methods are not annotated:
    &lt;pre&gt;&lt;code&gt;
abstract class A {
  @NotNull abstract String m();
}
class B extends A {
    String m() { return "empty string"; }
}
    &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;Annotated primitive types: &lt;code&gt;@NotNull int myFoo;&lt;/code&gt; &lt;/li&gt;
  &lt;li&gt;Both &lt;code&gt;@Nullable&lt;/code&gt; and &lt;code&gt;@NotNull&lt;/code&gt; are present on the same member: &lt;code&gt;@Nullable @NotNull String myFooString;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Collection of nullable elements is assigned into a collection of non-null elements:
    &lt;pre&gt;&lt;code&gt;
void testList(List&amp;lt;@Nullable String&gt; nullableList) {
   List&amp;lt;@NotNull String&gt; list2 = nullableList;
}
    &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Configure Annotations&lt;/b&gt; button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.&lt;/p&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 5 or higher, 
  and nullability annotations are available on the classpath.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NotNullFieldNotInitialized" defaultSeverity="WARNING" displayName="@NotNull field is not initialized" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields annotated as not-null that are not initialized in the constructor.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyClass {
  private @NotNull String value;

  public void setValue(@NotNull String value) {
    this.value = value;
  }

  public @NotNull String getValue() {
    return value;
  }
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  Such fields may violate the not-null constraint. In the example above, the &lt;code&gt;setValue&lt;/code&gt; parameter is annotated as not-null, but
  &lt;code&gt;getValue&lt;/code&gt; may return null if the setter was not called.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore fields which could be initialized implicitly&lt;/b&gt; option to control whether a warning should be issued if the field could be initialized implicitly
    (e.g. via a dependency injection).&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore fields initialized in setUp() method&lt;/b&gt; option to control whether a warning should be issued if the field is written in the test case &lt;code&gt;setUp()&lt;/code&gt; method.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Internationalization" path="Java"><inspection shortName="StringTokenizer" defaultSeverity="WARNING" displayName="Use of 'StringTokenizer'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of the &lt;code&gt;StringTokenizer&lt;/code&gt; class. Excessive use of &lt;code&gt;StringTokenizer&lt;/code&gt; is incorrect
in an internationalized environment.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryUnicodeEscape" defaultSeverity="WARNING" displayName="Unnecessary unicode escape sequence" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary unicode escape sequences. For example, when the file encoding can handle the character without escaping it.
Unicode control characters are not reported by this inspection (except for a line feed and a tab).
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String s = "\u0062";&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TimeToString" defaultSeverity="WARNING" displayName="Call to 'Time.toString()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;toString()&lt;/code&gt; calls on &lt;code&gt;java.sql.Time&lt;/code&gt; objects. Such calls are usually incorrect in an internationalized
environment.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MagicCharacter" defaultSeverity="WARNING" displayName="Magic character" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports character literals that are used without constant declaration. These characters might result in
bad code readability. Also, there might be errors if a character is changed only in one location
but not everywhere in code.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char c = 'c';&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenation" defaultSeverity="WARNING" displayName="String concatenation" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;String&lt;/code&gt; concatenations. Concatenation might be incorrect in an internationalized environment
and could be replaced by usages of &lt;code&gt;java.text.MessageFormat&lt;/code&gt; or similar classes.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToSuspiciousStringMethod" defaultSeverity="WARNING" displayName="Call to suspicious 'String' method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls of:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;equals()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;equalsIgnoreCase()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;compareTo()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;compareToIgnoreCase()&lt;/code&gt; and&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;trim()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  on &lt;code&gt;String&lt;/code&gt; objects.
  Comparison of internationalized strings should probably use a &lt;code&gt;java.text.Collator&lt;/code&gt; instead.
  &lt;code&gt;String.trim()&lt;/code&gt; only removes control characters between 0x00 and 0x20.
  The &lt;code&gt;String.strip()&lt;/code&gt; method introduced in Java 11 is more Unicode aware and can be used as a replacement.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbsoluteAlignmentInUserInterface" defaultSeverity="WARNING" displayName="Absolute alignment in AWT/Swing code" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of absolute alignment constants from AWT and Swing. Internationalized applications use relative alignment because it respects the locale component orientation settings.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  JPanel panel = new JPanel(new BorderLayout(2, 2));
  JLabel label = new JLabel("Hello World");
  panel.add(label, BorderLayout.NORTH);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  JPanel panel = new JPanel(new BorderLayout(2, 2));
  JLabel label = new JLabel("Hello World");
  panel.add(label, BorderLayout.PAGE_START);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NumericToString" defaultSeverity="WARNING" displayName="Call to 'Number.toString()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;toString()&lt;/code&gt; calls on objects of a class extending &lt;code&gt;Number&lt;/code&gt;.
Such calls are usually incorrect in an internationalized environment and some locale specific formatting should be used instead.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Double d) {
    System.out.println(d.toString());
  }
&lt;/code&gt;&lt;/pre&gt;
A possible way to fix this problem could be:
&lt;pre&gt;&lt;code&gt;
  void print(Double d) {
    System.out.printf("%f%n", d);
  }
&lt;/code&gt;&lt;/pre&gt;
This formats the number using the default locale which is set during the startup of the JVM and is based on the host environment.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimpleDateFormatWithoutLocale" defaultSeverity="WARNING" displayName="'SimpleDateFormat' without locale" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instantiations of &lt;code&gt;java.util.SimpleDateFormat&lt;/code&gt; that do not specify &lt;code&gt;java.util.Locale&lt;/code&gt;.
These calls might be incorrect in an internationalized environment.
&lt;p&gt;&lt;code&gt;Example:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new SimpleDateFormat("yyyy");&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DateToString" defaultSeverity="WARNING" displayName="Call to 'Date.toString()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;toString()&lt;/code&gt; calls on &lt;code&gt;java.util.Date&lt;/code&gt; objects. Such calls are usually incorrect in an internationalized
environment.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HardCodedStringLiteral" defaultSeverity="WARNING" displayName="Hardcoded strings" enabled="false" language="UAST" pluginId="com.intellij.java-i18n" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any instances of hardcoded &lt;code&gt;String&lt;/code&gt; literals.
&lt;p&gt;Hardcoded &lt;code&gt;String&lt;/code&gt; literals are probably errors in an
internationalized environment. This inspection won't report empty strings and strings consisting only of whitespaces. A quick-fix is available
to transform a string literal into a &lt;code&gt;java.util.ResourceBundle.getString()&lt;/code&gt; method call.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use inspection's options to further specialize whether this inspection should report strings in:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Assert statements like in &lt;code&gt;assert str.equals("message")&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Exception constructor calls like in &lt;code&gt;new Exception("message")&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;JUnit assert calls like in &lt;code&gt;assertEquals(str, "message")&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;The only argument to a method returning String like in &lt;code&gt;getStringByKey("key")&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Literals with value of legal and existing class name like &lt;code&gt;Class.forName("java.lang.Object")&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Literals with value of legal and existing property key &lt;code&gt;bundle.getString("authentication.failed")&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CharacterComparison" defaultSeverity="WARNING" displayName="Character comparison" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports ordinal comparisons of &lt;code&gt;char&lt;/code&gt; values. In an internationalized environment, such comparisons are rarely correct.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitDefaultCharsetUsage" defaultSeverity="WARNING" displayName="Implicit platform default charset" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method and constructor calls that implicitly use the platform default charset. These calls can produce different results on
systems that use different default charsets. It might result in unexpected behaviour.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void foo(byte[] bytes) {
  String s = new String(bytes);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;You can use a quick-fix that specifies the explicit UTF-8 charset if the corresponding overloaded method is available.
  After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void foo(byte[] bytes) {
  String s = new String(bytes, StandardCharsets.UTF_8);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateStringLiteralInspection" defaultSeverity="WARNING" displayName="Duplicate string literal" enabled="false" language="JAVA" pluginId="com.intellij.java-i18n" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports all string literals that are replicated unchanged throughout the project.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C1 { String CONST1 = "duplicate string"; }
  class C2 { String CONST2 = "duplicate string"; }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Min string length&lt;/b&gt; field to set the minimal string length required to detect duplicates.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore @PropertyKey expressions&lt;/b&gt; option to ignore strings passed as arguments to methods annotated with
    &lt;code&gt;org.jetbrains.annotations.PropertyKey&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertToBasicLatin" defaultSeverity="INFORMATION" displayName="Non-Basic Latin character" enabled="true" language="JAVA" pluginId="com.intellij.java-i18n" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-Basic Latin characters in literals and suggests replacing them with unicode entities.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  //  2021
  char c = '';
  String s = "";
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // &amp;amp;copy; 2021
  char c = '\u00a9';
  String s = "\u00c1\u00ee";
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringToUpperWithoutLocale" defaultSeverity="WARNING" displayName="Call to 'String.toUpperCase()' or 'toLowerCase()' without locale" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;toUpperCase()&lt;/code&gt; or &lt;code&gt;toLowerCase()&lt;/code&gt; calls on &lt;code&gt;String&lt;/code&gt; objects that do not specify a
&lt;code&gt;java.util.Locale&lt;/code&gt;. In these cases the default system locale is used, which can cause problems in an internationalized
environment.
&lt;p&gt;
  For example the code &lt;code&gt;"i".toUpperCase().equals("I")&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; in the Turkish and Azerbaijani locales, where
  the dotted and dotless 'i' are separate letters. Calling &lt;code&gt;toUpperCase()&lt;/code&gt; on an English string containing an 'i', when running
  in a Turkish locale, will return incorrect results. Alternatively, when dealing with strings that should be treated as locale-independent,
  like HTML tags, this can lead to errors.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DialogTitleCapitalization" defaultSeverity="WARNING" displayName="Incorrect string capitalization" enabled="true" language="UAST" pluginId="com.intellij.java-i18n" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
Reports strings in method parameters and return values annotated with &lt;code&gt;@Nls&lt;/code&gt; and having the capitalization parameter
to conform to capitalization rules existing in most platform UI guidelines.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void setTitle(@NlsContexts.DialogTitle String title) {}
  setTitle("This is sentence capitalization but should be title"); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  setTitle("This Is Sentence Capitalization but Should Be Title"); 
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="TOML" path=""><inspection shortName="TomlUnresolvedReference" defaultSeverity="WARNING" displayName="Unresolved reference" enabled="true" language="TOML" pluginId="org.toml.lang" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unresolved references in TOML files.
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Version control" path=""><inspection shortName="IgnoreFileDuplicateEntry" defaultSeverity="WARNING" displayName="Ignore file duplicates" enabled="true" language="IgnoreLang" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports duplicate entries (patters) in the ignore file (e.g. .gitignore, .hgignore).
Duplicate entries in these files are redundant and can be removed.

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;
    # Output directories
    /out/
    /target/
    &lt;b&gt;&lt;span style="color: #BE9117; "&gt;/out/&lt;/span&gt;&lt;/b&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="TestNG" path="Java"><inspection shortName="ConvertOldAnnotations" defaultSeverity="WARNING" displayName="Old TestNG annotation @Configuration is used" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports TestNG &lt;code&gt;org.testng.annotations.Configuration&lt;/code&gt; annotations.
&lt;p&gt;It's better to configure a test suite with the modern &lt;code&gt;@BeforeXXX&lt;/code&gt;/&lt;code&gt;@AfterXXX&lt;/code&gt; annotations.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Test {
    @Configuration(beforeSuite = true, afterTest = true)
    public void afterBefore(){
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Test {
    @AfterTest()
    @BeforeSuite()
    public void afterBefore(){
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ExpectedExceptionNeverThrownTestNG" defaultSeverity="WARNING" displayName="Expected exception never thrown in test method body" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports checked exceptions expected by a TestNG test method that are never thrown inside the method body.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test(expectedExceptions = Exception.class) // warning: Expected 'Exception' never thrown
  public void testEngineIsRunning() {
    assertTrue(engine.isRunning());
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UndeclaredTests" defaultSeverity="WARNING" displayName="Undeclared test" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports test classes that are not registered in &lt;code&gt;testing.xml&lt;/code&gt;. This is often a mistake because such tests won't be executed.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DataProviderReturnType" defaultSeverity="ERROR" displayName="Invalid data provider return type" enabled="true" language="JAVA" pluginId="TestNG-J" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods marked with &lt;code&gt;@DataProvider&lt;/code&gt; annotation that doesn't return &lt;code&gt;Object[][]&lt;/code&gt; or &lt;code&gt;Iterator&amp;lt;Object&amp;gt;&lt;/code&gt;.
If another type is returned, TestNG throws an exception.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class TestNgTest {
  @DataProvider(name = "Languages")
  List&amp;ltString&amp;gt getData() {
    return List.of("Java", "Kotlin");
  }

  @Test(dataProvider = "Languages")
  public void testData(String language) {
    System.out.println(language);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="dependsOnMethodTestNG" defaultSeverity="WARNING" displayName="Illegal method name passed to 'dependsOnMethods'" enabled="true" language="JAVA" pluginId="TestNG-J" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
Reports illegal method names passed to the &lt;code&gt;dependsOnMethods&lt;/code&gt; attribute in the &lt;code&gt;@Test&lt;/code&gt; annotation.
&lt;p&gt;A method name is considered illegal if it can't be resolved into a valid, accessible &lt;code&gt;@Test&lt;/code&gt; annotated method in the current class
  or any of its parent classes.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class SampleTest {
    @Test(dependsOnMethods = "testSpellignError")
    public void testSample() {}
    @Test
    public void testSpellingError(){}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;
</inspection><inspection shortName="JUnitTestNG" defaultSeverity="WARNING" displayName="JUnit Test can be converted to TestNG" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any JUnit-based test class that can be converted into TestNG based unit test.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import org.junit.Test;
import static org.junit.Assert.*;

public class ExampleTest {
  @Test
  public void testExample(){
    assertEquals(2 + 2, 4);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import org.testng.Assert;
import org.testng.annotations.Test;

public class ExampleTest {
  @Test
  public void testExample(){
    Assert.assertEquals(4, 2 + 2);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertJavadoc" defaultSeverity="WARNING" displayName="TestNG Javadoc can be converted to annotations" enabled="false" language="JAVA" pluginId="TestNG-J" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
Asserts your TestNG tests with Javadoc annotations and converts them to JDK annotations.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
    * @testng.before-test
  */
  public void sample() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @BeforeTest
  public void sample() {}
&lt;/code&gt;&lt;/pre&gt;
    &lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="MalformedDataProvider" defaultSeverity="WARNING" displayName="Data provider problems" enabled="true" language="JAVA" pluginId="TestNG-J" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
Reports references to data provider methods that do not exist or are not accessible.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class InstanceDataProviderFromForeignClass {
  // method data() doesn't exist in class A
  @Test(dataProvider = "data", dataProviderClass = A.class)
  public void test() {
  }
}
class A { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
//the needed data() method is created in class A
class A {
  @DataProvider
  public Object[][] data() {
    return new Object[][]{};
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="groupsTestNG" defaultSeverity="WARNING" displayName="Undefined group name" enabled="true" language="JAVA" pluginId="TestNG-J" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
Reports undefined group names passed to the &lt;code&gt;dependsOnGroups&lt;/code&gt; or &lt;code&gt;groups&lt;/code&gt; attributes in the &lt;code&gt;@Test&lt;/code&gt; annotation.
&lt;p&gt;The quick-fix adds an undefined name to a list of known groups.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Defined Groups&lt;/b&gt; field to define a comma-separated list of known groups.&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="DuplicatedDataProviderNames" defaultSeverity="ERROR" displayName="Duplicated data provider names" enabled="true" language="JAVA" pluginId="TestNG-J" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;TestNG&lt;/code&gt; data providers with equal names if &lt;code&gt;org.testng.TestNGException&lt;/code&gt; has occurred.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class DuplicatedDataProviders {
    @DataProvider
    public Object[][] intTestData() { // duplicate 1
      return new Integer[][]{
        new Integer[]{1, 1},
      };
    }

    @DataProvider(name = "intTestData")
    public Object[][] someTestData() { // duplicate 2
      return new Integer[][]{
        new Integer[]{1, 1},
      };
    }

    @Test(dataProvider = "intTestData")
    public void testIsOK(Integer key, Integer value) {
      assertEquals(key, value);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Functions" path="C/C++"><inspection shortName="FieldMustBeInitialized" defaultSeverity="WARNING" displayName="Field must be initialized" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the class fields which are const, have a reference type or have no default constructor and are not initialized in constructor(s).
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KRUnspecifiedParameters" defaultSeverity="WARNING" displayName="Passing arguments to function with K&amp;R unspecified parameters syntax" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the usages of functions with K&amp;R unspecified parameters syntax where a non-empty argument list is used.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HidingNonVirtualFunction" defaultSeverity="WARNING" displayName="Hiding non-virtual function" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the functions that hide non-virtual functions with the same signature declared in the base class.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;
class Base {
  public:
    void operate() {}
};

class Derived : public Base {
  public:
    void operate() {}
}
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DerivedFunctionsReturnTypeMismatch" defaultSeverity="WARNING" displayName="Derived functions return type mismatch" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the overridden virtual functions that have different (non-covariant) return types comparing to the base function's types.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NotImplementedFunctions" defaultSeverity="WARNING" displayName="Not implemented functions" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the functions that were declared in a class but have no implementations.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;
class Test {
  public:
    void setUp();
};
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionParameterCountMismatch" defaultSeverity="WARNING" displayName="Function parameter count mismatch" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the calls to the functions and macros that have the wrong number of arguments.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NoDefaultBaseConstructor" defaultSeverity="WARNING" displayName="No default base constructor" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the classes that don't explicitly initialize the base class without a default constructor.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Data flow" path="Groovy"><inspection shortName="GroovyMissingReturnStatement" defaultSeverity="WARNING" displayName="Missing return statement" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports missing &lt;code&gt;return&lt;/code&gt; statements at the end of methods with a non-&lt;b&gt;void&lt;/b&gt; return type.
The end of method should be reachable by the method's execution flow.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
String foo(int a) {
  if (a &gt; 0) {
    return "more than zero"
  }
} // foo(-1) will return 'null'

int bar(int a) {
  if (a &gt; 0) {
    return a
  }
} // bar(-1) will fall with runtime exception
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyVariableCanBeFinal" defaultSeverity="WARNING" displayName="Variable can be final" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports parameters or local variables that may have a final modifier added.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def list = [1,2,3]
  return list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:
&lt;pre&gt;&lt;code&gt;
  final def list = [1,2,3]
  return list
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;For more information, see the same inspection in Java.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnusedAssignment" defaultSeverity="WARNING" displayName="Unused assignment" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports the cases where a variable is redundant as its value is never used after its assignment.&lt;/p&gt;
&lt;p&gt;If the variable is unused, we recommend removing it to shorten the code and to avoid redundant allocations.&lt;/p&gt;
&lt;p&gt;The following cases are reported:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the variable never gets read after assignment&lt;/li&gt;
  &lt;li&gt;the value is always overwritten with another assignment before the next variable read&lt;/li&gt;
  &lt;li&gt;the variable initializer is redundant (for one of the above two reasons)&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt; For more info see the same inspection in Java.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyVariableNotAssigned" defaultSeverity="WARNING" displayName="Variable not assigned" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports variables that might not have been initialized.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnusedIncOrDec" defaultSeverity="WARNING" displayName="Unused incrementing or decrementing" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports unused incrementing and decrementing expressions.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Plugin DevKit" path=""><inspection shortName="ComponentRegistrationProblems" defaultSeverity="ERROR" displayName="Component type mismatch" enabled="true" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports incorrect registration of plugin components
(Components and Actions) both in code and in the &lt;code&gt;plugin.xml&lt;/code&gt; descriptor.
&lt;p&gt;
  The following problems are reported:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Unresolved component/action implementation-classes (&lt;code&gt;plugin.xml&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Unresolved component interface-classes (&lt;code&gt;plugin.xml&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Component implementation-class is not assignable to its interface-class (&lt;code&gt;plugin.xml&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Incorrect component registration, e.g. &lt;code&gt;ProjectComponent&lt;/code&gt; is registered as Application Component,
    or the class doesn't implement any component interface at all (&lt;code&gt;plugin.xml&lt;/code&gt; and Java code)
  &lt;/li&gt;
  &lt;li&gt;Incorrect class modifiers: Action classes must be &lt;code&gt;public&lt;/code&gt; and must have a public
    no-argument constructor. Additionally, Action and Component implementation classes
    must not be abstract (&lt;code&gt;plugin.xml&lt;/code&gt; and Java code)
  &lt;/li&gt;
  &lt;li&gt;Duplicate interface-class: A class may only be used once as interface-class (&lt;code&gt;plugin.xml&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Check Plugin Descriptor (plugin.xml)&lt;/b&gt; option to disable checks in &lt;code&gt;plugin.xml&lt;/code&gt; descriptor.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Check Java Actions&lt;/b&gt; option to disable checks in Action code.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Check Java Code&lt;/b&gt; option to disable all checks in code.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DevKitPropertiesQuotesValidation" defaultSeverity="WARNING" displayName="Quotes validation in properties files" enabled="true" language="Properties" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports wrong number of quotes around parameter in property value.
&lt;p&gt;
  If parameters are present in the property value, then the value will be passed as a pattern to &lt;code&gt;java.text.MessageFormat&lt;/code&gt;.
  This means that single quotes are used for escaping. Thus to keep a quote visible, it must be duplicated:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;'{0}'&lt;/code&gt; &amp;rarr; &lt;code&gt;{0}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;''{0}''&lt;/code&gt; &amp;rarr; &lt;code&gt;'$value$'&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  When using choice format, nested formats are evaluated as formats themselves, and second double quotes are required.
  When passing &lt;code&gt;1&lt;/code&gt;:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;{0, choice, 0#no|#1''{0}'' file}&lt;/code&gt; &amp;rarr; &lt;code&gt;{0} files&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;{0, choice, 0#no|#1''''{0}'''' file}&lt;/code&gt; &amp;rarr; &lt;code&gt;'$number_of_files$' files&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Dependency issues" path="Java"><inspection shortName="ClassWithTooManyDependencies" defaultSeverity="WARNING" displayName="Class with too many dependencies" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports classes that are directly dependent on too many other classes in the project.
&lt;p&gt;Modifications to any dependency of such classes may require changing the class, thus making it prone to instability.&lt;/p&gt;
&lt;p&gt;Only top-level classes are reported.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Maximum number of dependencies&lt;/b&gt; field to specify the maximum allowed number of dependencies for a class.&lt;/p&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithTooManyTransitiveDependents" defaultSeverity="WARNING" displayName="Class with too many transitive dependents" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports a class on which too many other classes are directly or indirectly dependent.
&lt;p&gt;Any modification to such a class may require changing many other classes, which may be expensive.&lt;/p&gt;
&lt;p&gt;Only top-level classes are reported.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Maximum number of transitive dependents&lt;/b&gt; field to specify the maximum allowed number of direct or indirect dependents
  for a class.&lt;/p&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithTooManyDependents" defaultSeverity="WARNING" displayName="Class with too many dependents" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports a class on which too many other classes are directly dependent.
&lt;p&gt;Any modification to such a class may require changing many other classes, which may be expensive.&lt;/p&gt;
&lt;p&gt;Only top-level classes are reported.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the field below to specify the maximum allowed number of dependents for a class.&lt;/p&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithTooManyTransitiveDependencies" defaultSeverity="WARNING" displayName="Class with too many transitive dependencies" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports classes that are directly or indirectly dependent on too many other classes.
&lt;p&gt;Modifications to any dependency of such a class may require changing the class thus making it prone to instability.&lt;/p&gt;
&lt;p&gt;Only top-level classes are reported.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Maximum number of transitive dependencies&lt;/b&gt; field to specify the maximum allowed number of direct or indirect dependencies
  for a class.&lt;/p&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CyclicPackageDependency" defaultSeverity="WARNING" displayName="Cyclic package dependency" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports packages that are mutually or cyclically dependent on other packages.
&lt;p&gt;Such cyclic dependencies make code fragile and hard to maintain.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CyclicClassDependency" defaultSeverity="WARNING" displayName="Cyclic class dependency" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports classes that are mutually or cyclically dependent on other classes.
&lt;p&gt;Such cyclic dependencies make code fragile and hard to maintain.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Room" path="Android"><inspection shortName="AndroidUnresolvedRoomSqlReference" defaultSeverity="ERROR" displayName="Unresolved reference in Room SQL" enabled="true" language="RoomSql" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Checks Room SQL queries for unresolved references.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AndroidRoomQuestionMarkBindParameter" defaultSeverity="ERROR" displayName="'?' used as parameter in a Room query." enabled="true" language="RoomSql" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Room SQL queries that use unnamed query parameters (e.g. &lt;code&gt;WHERE id = ?&lt;/code&gt;). This is not supported by the Room query
analyzer which requires named query parameters (e.g. &lt;code&gt;WHERE id = :id&lt;/code&gt;) that correspond to arguments of the method annotated with
&lt;code&gt;@Query&lt;/code&gt;.
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Threading issues" path="Groovy"><inspection shortName="GroovySynchronizationOnNonFinalField" defaultSeverity="WARNING" displayName="Synchronization on non-final field" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;synchronized&lt;/code&gt; statements where the lock expression
is a non-&lt;code&gt;final&lt;/code&gt; field.
&lt;p&gt;
  Such statements are unlikely to have useful semantics, as different
  threads may be locking on different objects even when operating on the same object.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNotifyWhileNotSynchronized" defaultSeverity="WARNING" displayName="'notify()' or 'notifyAll()' while not synced" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;notify()&lt;/code&gt; and &lt;code&gt;notifyAll()&lt;/code&gt; not within a corresponding
synchronized statement or synchronized method.
&lt;p&gt;
  Calling these methods on an object
  without holding a lock on that object will result in an &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; being thrown.
  Such a construct is not necessarily an error, as the necessary lock may be acquired before
  the containing method is called, but it's worth looking at.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySynchronizationOnThis" defaultSeverity="WARNING" displayName="Synchronization on 'this'" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports synchronization which uses &lt;code&gt;this&lt;/code&gt; as its lock expression.
&lt;p&gt;
  Constructs reported include &lt;code&gt;synchronized&lt;/code&gt;
  blocks which lock &lt;code&gt;this&lt;/code&gt;, and calls to &lt;code&gt;wait()&lt;/code&gt;
  &lt;code&gt;notify()&lt;/code&gt; or &lt;code&gt;notifyAll()&lt;/code&gt; which target &lt;code&gt;wait()&lt;/code&gt;.
  Such constructs, like synchronized methods, make it hard to track just who is locking on a given
  object, and make possible "denial of service" attacks on objects. As an alternative, consider
  locking on a private instance variable, access to which can be completely controlled.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySystemRunFinalizersOnExit" defaultSeverity="WARNING" displayName="Call to System.runFinalizersOnExit()" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;System.runFinalizersOnExit()&lt;/code&gt;.
&lt;p&gt;
  This call is one of the most dangerous in the Java language. It is inherently non-thread-safe,
  may result in data corruption, deadlock, and may affect parts of the program far removed from its call point.
  It is deprecated, and its use is strongly discouraged.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnsynchronizedMethodOverridesSynchronizedMethod" defaultSeverity="WARNING" displayName="Unsynchronized method overrides synchronized method" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports non-&lt;b&gt;synchronized&lt;/b&gt; methods overriding &lt;b&gt;synchronized&lt;/b&gt; methods.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Base {
      &lt;b&gt;synchronized&lt;/b&gt; void foo() {
          // ...
      }
  }
  class Derived extends Base {
      @Override
      &lt;b&gt;void foo()&lt;/b&gt; {
          super.foo()
            // ...
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the non-synchronized method &lt;code&gt;foo()&lt;/code&gt; in class &lt;code&gt;Bar&lt;/code&gt; overrides synchronized method.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDoubleCheckedLocking" defaultSeverity="WARNING" displayName="Double-checked locking" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports double-checked locking.
&lt;p&gt;
  Double-checked locking tries to initialize a field on demand and in a thread-safe manner, while avoiding the cost of synchronization.
  Unfortunately it is not thread safe when used on a field that is not declared &lt;code&gt;volatile&lt;/code&gt;.
  When using Java 1.4 or older, double-checked locking doesn't work even with a &lt;code&gt;volatile&lt;/code&gt; field.
  See &lt;a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"&gt;the article&lt;/a&gt; for an explanation of the problem.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      private Helper helper = null

      Helper getHelper() {
          if (helper == null)
              synchronized(this) {
                  if (helper == null) {
                      helper = new Helper()
                  }
              }
          }
          return helper;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAccessToStaticFieldLockedOnInstance" defaultSeverity="WARNING" displayName="Access to static field locked on instance data" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports accesses to a non-constant static field which is
locked on either &lt;code&gt;this&lt;/code&gt; or an instance field of &lt;code&gt;this&lt;/code&gt;.
&lt;p&gt;
  Locking a static field on instance data does not prevent the field from being
  modified by other instances, and thus may result in surprising race conditions.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static String s;
  def foo() {
      synchronized (this) {
          System.out.println(s); // warning
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNestedSynchronizedStatement" defaultSeverity="WARNING" displayName="Nested 'synchronized' statement" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports nested &lt;code&gt;synchronized&lt;/code&gt; statements.
&lt;p&gt;
  Nested &lt;code&gt;synchronized&lt;/code&gt; statements
  are either redundant (if the lock objects are identical) or prone to deadlock.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyWhileLoopSpinsOnField" defaultSeverity="WARNING" displayName="While loop spins on field" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports &lt;code&gt;while&lt;/code&gt; loops, which spin on the
  value of a non-&lt;code&gt;volatile&lt;/code&gt; field, waiting for it to be changed by another thread.&lt;/p&gt;
&lt;p&gt;
In addition to being potentially extremely CPU intensive when little work is done inside the loop, such
loops likely have different semantics than intended. The Java Memory Model allows that loop to never complete even
if another thread changes the field's value.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SpinsOnField {
      boolean ready = false;

      void run() {
          // the loop may never complete even after
          // markAsReady call from the other thread
          while (!ready) {
          }
          // do some work
      }

      void markAsReady() {
          ready = true;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
Additionally since Java 9, calling &lt;code&gt;Thread.onSpinWait()&lt;/code&gt; inside spin loop
on a &lt;code&gt;volatile&lt;/code&gt; field is recommended, which may significantly improve performance on some hardware.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the checkbox below to have this inspection report only empty &lt;code&gt;while&lt;/code&gt; loops.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyWaitWhileNotSynchronized" defaultSeverity="WARNING" displayName="'wait()' while not synced" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports calls to &lt;code&gt;wait()&lt;/code&gt; not made inside a corresponding synchronized
  statement or synchronized method.&lt;/p&gt;
&lt;p&gt;Calling &lt;code&gt;wait()&lt;/code&gt; on an object
without holding a lock on that object will result in an &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; being thrown.
Such a construct is not necessarily an error, as the necessary lock may be acquired before
the containing method is called, but its worth looking at.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySynchronizedMethod" defaultSeverity="WARNING" displayName="Synchronized method" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the &lt;code&gt;synchronized&lt;/code&gt; modifier on methods.
&lt;p&gt;
  Some coding standards
  prohibit the use of the &lt;code&gt;synchronized&lt;/code&gt; modifier, in favor of &lt;code&gt;synchronized&lt;/code&gt; statements.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyEmptySyncBlock" defaultSeverity="WARNING" displayName="Empty 'synchronized' block" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;synchronized&lt;/code&gt; statements
with empty bodies. While theoretically this may be the semantics intended, this construction is
confusing, and often the result of a typo.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
synchronized(lock) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnconditionalWait" defaultSeverity="WARNING" displayName="Unconditional 'wait' call" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports &lt;b&gt;wait()&lt;/b&gt;
being called unconditionally within a synchronized context.
Normally, &lt;b&gt;wait()&lt;/b&gt; is
used to block a thread until some condition is true. If &lt;b&gt;wait()&lt;/b&gt;
is called unconditionally, that often indicates that the condition was checked before a lock was
acquired. In that case, a data race may occur, with the condition becoming true between the time
it was checked and the time the lock was acquired. While constructs found by this inspection
  are not necessarily incorrect, they are certainly worth examining.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyBusyWait" defaultSeverity="WARNING" displayName="Busy wait" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.lang.Thread.sleep()&lt;/code&gt; that occur inside loops.
&lt;p&gt;
  Such calls are indicative of "busy-waiting". Busy-waiting is often inefficient, and may result in unexpected deadlocks
  as busy-waiting threads do not release locked resources.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyWaitCallNotInLoop" defaultSeverity="WARNING" displayName="'wait()' not in loop" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports calls to &lt;code&gt;wait()&lt;/code&gt; not made inside a loop.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wait()&lt;/code&gt; is normally used to suspend a thread until a condition is true, and that condition should be checked after the &lt;code&gt;wait()&lt;/code&gt;
  returns. A loop is the clearest way to achieve this.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyPublicFieldAccessedInSynchronizedContext" defaultSeverity="WARNING" displayName="Non-private field accessed in synchronized context" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-&lt;code&gt;final&lt;/code&gt;, non-&lt;code&gt;private&lt;/code&gt; fields which are accessed in a synchronized context.
&lt;p&gt;
  A non-private field cannot be guaranteed to always be accessed in a synchronized manner, and such "partially synchronized"
  access may result in unexpectedly inconsistent data structures. Accesses in constructors an initializers are ignored
  for purposes of this inspection.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySynchronizationOnVariableInitializedWithLiteral" defaultSeverity="WARNING" displayName="Synchronization on variable initialized with literal" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports synchronized blocks which lock on an object which is initialized with a literal.
&lt;p&gt;
  String literals are interned and &lt;code&gt;Number&lt;/code&gt; literals can be allocated from a cache. Because of
  this, it is possible that some other part of the system which uses an object initialized with the same
  literal, is actually holding a reference to the exact same object. This can create unexpected dead-lock
  situations, if the string was thought to be private.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyThreadStopSuspendResume" defaultSeverity="WARNING" displayName="Call to Thread.stop(), Thread.suspend(), or Thread.resume()" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Thread.stop()&lt;/code&gt;,&lt;code&gt;Thread.suspend()&lt;/code&gt;, or &lt;code&gt;Thread.resume()&lt;/code&gt;.
&lt;p&gt;
  These calls are inherently prone to data corruption and deadlock, and their use is strongly
  discouraged.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Embedded" path="Java/Performance"><inspection shortName="ArrayLengthInLoopCondition" defaultSeverity="WARNING" displayName="Array.length in loop condition" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports accesses to the &lt;code&gt;.length&lt;/code&gt; property of an array in the condition part of a
loop statement. In highly resource constrained environments, such calls may
have adverse performance implications.
&lt;p&gt;
  This inspection is intended for Java ME and other highly resource constrained environments.
  Applying the results of this inspection without consideration might have negative effects on code clarity and design.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object[] x) {
    for (int i = 0; i &amp;lt; x.length; i++) { /**/ }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InterfaceWithOnlyOneDirectInheritor" defaultSeverity="WARNING" displayName="Interface with a single direct inheritor" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports interfaces that have precisely one direct inheritor.
While such interfaces may offer admirable clarity of design,
in memory-constrained or bandwidth-limited environments,
they needlessly increase the total footprint of the application. Consider
merging the interface with its inheritor.
&lt;p&gt;
  This inspection is intended for Java ME and other highly resource constrained environments.
  Applying the results of this inspection without consideration might have negative effects on code clarity and design.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConnectionResource" defaultSeverity="WARNING" displayName="Connection opened but not safely closed" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Java ME &lt;code&gt;javax.microedition.io.Connection&lt;/code&gt; resources that are not opened in front of a &lt;code&gt;try&lt;/code&gt; block and
closed in the corresponding &lt;code&gt;finally&lt;/code&gt; block. Such resources may be inadvertently leaked if an exception is thrown before the
resource is closed.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void example() throws IOException {
    Connection c = Connector.open("foo");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyLargePrimitiveArrayInitializer" defaultSeverity="WARNING" displayName="Overly large initializer for array of primitive type" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports array initializer expressions for primitive
arrays that contain too many elements. Such initializers may result in overly large
class files because code must be generated to initialize each array element. In memory
or bandwidth constrained environments, it may be more efficient to load large arrays
of primitives from resource files.
&lt;p&gt;
  This inspection is intended for Java ME and other highly resource constrained environments.
  Applying the results of this inspection without consideration might have negative effects on code clarity and design.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to specify the maximum number of elements to allow in primitive array initializers.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultiplyOrDivideByPowerOfTwo" defaultSeverity="WARNING" displayName="Multiplication or division by power of two" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports multiplication of an integer value by a constant integer that can be represented as a power of two. Such
expressions can be replaced with right or left shift operations
for a possible performance improvement.
&lt;p&gt;
  Note that this inspection is not relevant for modern JVMs (e. g.,
  HotSpot or OpenJ9) because their JIT compilers will perform this optimization.
  It might only be useful in some embedded systems where no JIT compilation is performed.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = x * 4;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix is suggested to replace the multiplication or division operation with the shift operation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = x &amp;lt;&amp;lt; 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to make the inspection also report division by a power of two.
  Note that replacing a power of two division with a shift does not work for negative numbers.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RecordStoreResource" defaultSeverity="WARNING" displayName="'RecordStore' opened but not safely closed" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Java ME &lt;code&gt;javax.microedition.rms.RecordStore&lt;/code&gt; resources that are not opened in front
of a &lt;code&gt;try&lt;/code&gt; block and closed in the corresponding &lt;code&gt;finally&lt;/code&gt; block.
&lt;p&gt;Such resources may be inadvertently leaked if an exception is thrown before the resource is closed.&lt;/p&gt;
&lt;p&gt;
  This inspection is intended for Java ME and other highly resource constrained environments.
  Applying the results of this inspection without consideration might have negative effects on code clarity and design.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo1() throws RecordStoreException {
      RecordStore rs = RecordStore.openRecordStore("bar", true); // warning
  }
  void foo2() throws RecordStoreException {
      RecordStore rs = RecordStore.openRecordStore("bar", true); // no warning
      try {
          /* ... */
      } finally {
          rs.closeRecordStore();
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodCallInLoopCondition" defaultSeverity="WARNING" displayName="Method call in loop condition" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method calls in the condition part of a
loop statement. In highly resource constrained environments, such calls may
have adverse performance implications.
&lt;p&gt;
  Applying the results of this inspection without consideration might have negative effects on code clarity and design.
  This inspection is intended for Java ME and other highly resource constrained environments.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "example";
  for (int i = 0; i &amp;lt; s.length(); i++) {
    System.out.println(s.charAt(i));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "example";
  int length = s.length();
  for (int i = 0; i &amp;lt; length; i++) {
    System.out.println(s.charAt(i));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to ignore calls to common Java iteration methods like &lt;code&gt;Iterator.hasNext()&lt;/code&gt;
  and known methods with side-effects like &lt;code&gt;Atomic*.compareAndSet&lt;/code&gt;.
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SingleCharacterStartsWith" defaultSeverity="WARNING" displayName="Single character 'startsWith()' or 'endsWith()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;String.startsWith()&lt;/code&gt; and
&lt;code&gt;String.endsWith()&lt;/code&gt; where single character string literals are passed as an argument.
&lt;p&gt;
  A quick-fix is suggested to replace such calls with more efficiently implemented &lt;code&gt;String.charAt()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  However, the performance gain of such change is minimal and the code becomes less readable because of the extra non-zero length check,
  so it is recommended to apply the quick-fix only inside tight loops.
&lt;/p&gt;
&lt;p&gt;
  This inspection is intended for Java ME and other highly resource constrained environments.
  Applying the results of this inspection without consideration might have negative effects on code clarity and design.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean startsWithX(String s) {
    return s.startsWith("x");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean startsWithX(String s) {
    return !s.isEmpty() &amp;&amp; s.charAt(0) == 'x';
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckForOutOfMemoryOnLargeArrayAllocation" defaultSeverity="WARNING" displayName="Large array allocation with no OutOfMemoryError check" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports large array allocations which do not check
for &lt;code&gt;java.lang.OutOfMemoryError&lt;/code&gt;. In memory
constrained environments, allocations of large data objects should probably
be checked for memory depletion.
&lt;p&gt;
  This inspection is intended for Java ME and other highly resource constrained environments.
  Applying the results of this inspection without consideration might have negative effects on code clarity and design.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to specify the maximum number of elements to allow in unchecked array allocations.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AbstractClassWithOnlyOneDirectInheritor" defaultSeverity="WARNING" displayName="Abstract class with a single direct inheritor" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports abstract classes that have precisely one
direct inheritor. While such classes may offer admirable clarity of design,
in memory-constrained or bandwidth-limited environments, they needlessly increase
the total footprint of the application. Consider merging the abstract class with its inheritor.
&lt;p&gt;
  This inspection is intended for Java ME and other highly resource constrained environments.
  Applying the results of this inspection without consideration might have negative effects on code clarity and design.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Base {} // will be reported

  class Inheritor extends Base {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PrivateMemberAccessBetweenOuterAndInnerClass" defaultSeverity="WARNING" displayName="Synthetic accessor call" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports references from a nested class to non-constant &lt;code&gt;private&lt;/code&gt; members of an outer class.
For such references, javac will generate package-private synthetic accessor methods,
which may compromise the security because members appearing to be private will in fact be accessible from the entire package.
&lt;p&gt;
  A nested class and its outer class are compiled to separate
  class files. The Java virtual machine normally prohibits access from a class to private fields and methods of
  another class. To enable access from a nested class to private members of an outer class, javac creates a package-private
  synthetic accessor method.
&lt;/p&gt;
&lt;p&gt;
  By making the &lt;code&gt;private&lt;/code&gt; member package-private instead, the actual accessibility is made explicit.
  This also saves a little bit of memory, which may improve performance in resource constrained environments.
&lt;/p&gt;
&lt;p&gt;
  This inspection only reports if the language level of the project or module is 10 or lower.
  Under Java 11 and higher accessor methods are not generated anymore,
  because of nest-based access control (&lt;a href="https://openjdk.java.net/jeps/181"&gt;JEP 181&lt;/a&gt;).
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
    private void x() {}

    class Inner {
      void y() {
        x();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
    void x() {}

    class Inner {
      void y() {
        x();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Shell script" path=""><inspection shortName="ShellCheck" defaultSeverity="ERROR" displayName="ShellCheck" enabled="true" language="Shell Script" pluginId="com.jetbrains.sh" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports shell script bugs detected by the integrated &lt;a href="https://github.com/koalaman/shellcheck"&gt;ShellCheck&lt;/a&gt; static analysis tool.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 9" path="Java/Java language level migration aids"><inspection shortName="JavaRequiresAutoModule" defaultSeverity="WARNING" displayName="Dependencies on automatic modules" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of automatic modules in a &lt;code&gt;requires&lt;/code&gt; directive.
&lt;p&gt;An automatic
module is unreliable since it can depend on the types on the class path,
and its name and exported packages can change if it's
  converted into an explicit module.&lt;/p&gt;
&lt;p&gt;Corresponds to &lt;code&gt;-Xlint:requires-automatic&lt;/code&gt; and &lt;code&gt;-Xlint:requires-transitive-automatic&lt;/code&gt; Javac options.
The first option increases awareness of when automatic modules are used.
The second warns the authors of a module that they're putting the users of that module at risk by establishing implied readability to an automatic module.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  //module-info.java
  module org.printer {
    requires transitive drivers.corp.org; // reported in case 'drivers.corp.org' is an automatic module
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Highlight only transitive dependencies&lt;/b&gt; option to warn only about transitive dependencies.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java9CollectionFactory" defaultSeverity="WEAK WARNING" displayName="Immutable collection creation can be replaced with collection factory call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;java.util.Collections&lt;/code&gt; unmodifiable collection calls
that can be converted to newer collection factory methods.
These can be replaced with e.g. &lt;code&gt;List.of()&lt;/code&gt; or &lt;code&gt;Set.of()&lt;/code&gt; introduced in Java 9
or &lt;code&gt;List.copyOf()&lt;/code&gt; introduced in Java 10.

&lt;p&gt;Note that in contrast to &lt;code&gt;java.util.Collections&lt;/code&gt; methods, Java 9 collection factory methods:
&lt;ul&gt;
  &lt;li&gt;Do not accept &lt;code&gt;null&lt;/code&gt; values.
  &lt;li&gt;Require unique set elements and map keys.
  &lt;li&gt;Do not accept &lt;code&gt;null&lt;/code&gt; arguments to query methods like &lt;code&gt;List.contains()&lt;/code&gt; or &lt;code&gt;Map.get()&lt;/code&gt; of the collections returned.
&lt;/ul&gt;
&lt;p&gt;When these cases are violated, exceptions are thrown.
  This can change the semantics of the code after the migration.&lt;/p&gt;
&lt;p&gt;Example:
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&gt; even = Collections.unmodifiableList(
    Arrays.asList(2, 4, 6, 8, 10, 2));
  List&amp;lt;Integer&gt; evenCopy = Collections.unmodifiableList(
    new ArrayList&amp;lt;&gt;(list1));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&gt; even = List.of(2, 4, 6, 8, 10, 2);
  List&amp;lt;Integer&gt; evenCopy = List.copyOf(list);
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 9 or higher.
&lt;p&gt;
Use the &lt;b&gt;Do not warn when content is non-constant&lt;/b&gt; option to report only in cases when the supplied arguments are compile-time constants.
This reduces the chances that the behavior changes,
because it's not always possible to statically check whether original elements are unique and not &lt;code&gt;null&lt;/code&gt;.
&lt;p&gt;
  Use the &lt;b&gt;Suggest 'Map.ofEntries'&lt;/b&gt; option to suggest replacing unmodifiable maps with more than 10 entries with  &lt;code&gt;Map.ofEntries()&lt;/code&gt;.
&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceNullCheck" defaultSeverity="WARNING" displayName="Null check can be replaced with method call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports null checks that can be replaced with an &lt;code&gt;Objects&lt;/code&gt;/&lt;code&gt;Stream&lt;/code&gt; static method.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if (message == null) {
  application.messageStorage().save(new EmptyMessage());
} else {
  application.messageStorage().save(message);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  application.messageStorage()
    .save(Objects.requireNonNullElseGet(message, () -&gt; new EmptyMessage()));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Don't warn if length of replacement bigger than original&lt;/b&gt; option to ignore the cases when the replacement is longer than the
  original code.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2017.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Testing" path="Android/Lint"><inspection shortName="AndroidLintIgnoreWithoutReason" defaultSeverity="WARNING" displayName="@Ignore without Reason" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;@Ignore without Reason&lt;br&gt;&lt;br&gt;Ignoring a test without a reason makes it difficult to figure out the problem later. Please define an explicit reason why it is ignored, and when it can be resolved.&lt;br&gt;&lt;br&gt;Issue id: IgnoreWithoutReason&lt;br&gt;&lt;br&gt;Available options:&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;allow-comments&lt;/b&gt; (default is true):&lt;br/&gt;
Whether to allow a comment next to the @Ignore tag to be considered providing a reason.&lt;br/&gt;
&lt;br/&gt;
Normally you have to specify an annotation argument to the &lt;code&gt;@Ignore&lt;/code&gt; annotation, but with this option you can configure whether it should also allow ignore reasons to specified by a comment adjacent to the ignore tag.&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="IgnoreWithoutReason"&gt;
        &amp;lt;option name="allow-comments" value="true" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Method metrics" path="Groovy"><inspection shortName="GroovyMethodParameterCount" defaultSeverity="WARNING" displayName="Method with too many parameters" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods with too many parameters. Method with too many parameters
is a good sign that refactoring is necessary. Methods whose signatures are inherited from
library classes are ignored by this inspection.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Maximum number of parameters:&lt;/b&gt; field to specify the maximum acceptable number of parameters a method might have.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMultipleReturnPointsPerMethod" defaultSeverity="WARNING" displayName="Method with multiple return points" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods with too many return points. Methods with too
many return points may be confusing, and hard to refactor.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  int foo(int a) {
    if (a &gt; 0) {
      return a
    }
    if (a &amp;lt; 0) return -a
    return 0
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the field provided below to specify the maximum acceptable number of return points a method
  might have.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOverlyComplexMethod" defaultSeverity="WARNING" displayName="Overly complex method" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that have too high a cyclomatic complexity.
&lt;p&gt;
  Cyclomatic
  complexity is basically a measurement of the number of branching points in a method. Methods with too high
  a cyclomatic complexity may be confusing and difficult to test.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 Use the &lt;b&gt;Method complexity limit&lt;/b&gt; field to specify the maximum acceptable cyclomatic complexity a method might have.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMethodWithMoreThanThreeNegations" defaultSeverity="WARNING" displayName="Method with more than three negations" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods with three or more negation operations (&lt;code&gt;!&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;).
Such methods may be unnecessarily confusing.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOverlyNestedMethod" defaultSeverity="WARNING" displayName="Overly nested method" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods whose bodies are too deeply nested.
&lt;p&gt;
  Methods with too much statement
  nesting may be confusing, and are a good sign that refactoring may be necessary.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 Use the &lt;b&gt;Maximum nesting depth&lt;/b&gt; field to specify the maximum acceptable nesting depth a method might have.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOverlyLongMethod" defaultSeverity="WARNING" displayName="Overly long method" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that are too long.
&lt;p&gt;
  Methods that are too long
  may be confusing, and are a good sign that refactoring is necessary.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Maximum statements per method&lt;/b&gt; field to specify the maximum acceptable number of non-comment source
  statements a method might have.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Description file" path="Plugin DevKit"><inspection shortName="InspectionDescriptionNotFoundInspection" defaultSeverity="WARNING" displayName="Inspection description checker" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports inspections that are missing an HTML description file, i.e. a file containing a text like this.
&lt;p&gt;
  The &lt;b&gt;Create description file&lt;/b&gt; quick-fix creates a template HTML description file.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IntentionDescriptionNotFoundInspection" defaultSeverity="WARNING" displayName="Intention description checker" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports intentions that are missing an HTML description file, &lt;code&gt;before.template&lt;/code&gt; file or &lt;code&gt;after.template&lt;/code&gt; file.
These are shown in &lt;a href="settings://preferences.intentionPowerPack"&gt;Settings | Editor | Intentions&lt;/a&gt;.
&lt;p&gt;
  The &lt;b&gt;Create description file&lt;/b&gt; quick-fix creates a template HTML description file.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PostfixTemplateDescriptionNotFound" defaultSeverity="WARNING" displayName="Postfix template description checker" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports postfix templates missing an HTML description file, &lt;code&gt;before.template&lt;/code&gt; file or &lt;code&gt;after.template&lt;/code&gt; file.
These are shown in &lt;a href="settings://reference.settingsdialog.IDE.editor.postfix.templates"&gt;Settings | Editor | General | Postfix Completion&lt;/a&gt;.
&lt;p&gt;
  The &lt;b&gt;Create description file&lt;/b&gt; quick-fix creates a template HTML description file.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Other" path="Groovy"><inspection shortName="TypeCustomizer" defaultSeverity="WARNING" displayName="Type customizer inspection" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports files which can be custom type checkers and are not added to compiler resources yet.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GrMethodMayBeStatic" defaultSeverity="WARNING" displayName="Method can be made 'static'" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods which may safely be made &lt;code&gt;static&lt;/code&gt;.
&lt;p&gt;
  A method may be &lt;code&gt;static&lt;/code&gt; if it is not &lt;code&gt;synchronized&lt;/code&gt;,
  it does not reference any of its class' instance methods and instance fields,
  and it is not overridden in a subclass.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Compiler issues" path="Java"><inspection shortName="PreviewFeature" defaultSeverity="WARNING" displayName="Preview Feature warning" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of Preview Feature APIs, i.e. of a module, package, class, interface, method, constructor, field, or enum constant
in the &lt;code&gt;java.*&lt;/code&gt; or &lt;code&gt;javax.*&lt;/code&gt; namespace annotated with &lt;code&gt;@PreviewFeature&lt;/code&gt;.
&lt;p&gt;
  A preview feature is a new feature of the Java language, Java Virtual Machine, or Java SE API that is fully specified, fully implemented,
  and is yet impermanent. The notion of a preview feature is defined in &lt;a href="https://openjdk.java.net/jeps/12"&gt;JEP 12&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
  If some piece of code depends on a preview API, it may stop compiling in future JDK versions if the feature is changed or removed.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;The inspection only reports if the language level of the project or module is &lt;b&gt;Preview&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2021.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UNCHECKED_WARNING" defaultSeverity="WARNING" displayName="Unchecked warning" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code on which an unchecked warning will be issued by the javac compiler.
Every unchecked warning may potentially trigger &lt;code&gt;ClassCastException&lt;/code&gt; at runtime.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List items = Arrays.asList("string", "string");
  List&amp;lt;Integer&amp;gt; numbers = Collections.unmodifiableList(items); // unchecked assignment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix tries to generify the containing file,
  which may expose any problems in the editor and during compilation that previously only appeared at runtime:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; items = Arrays.asList("string", "string");
  List&amp;lt;Integer&amp;gt; numbers = Collections.unmodifiableList(items); // incompatible types
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizeOnValueBasedClass" defaultSeverity="WARNING" displayName="Value-based warnings" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports attempts to synchronize on an instance of a value-based class that produce compile-time warnings and raise
run-time exceptions starting from Java 16.
&lt;p&gt;
  For example, &lt;code&gt;java.lang.Double&lt;/code&gt; is annotated with &lt;code&gt;jdk.internal.ValueBased&lt;/code&gt;, so the following code will
  produce a compile-time warning:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Double d = 20.0;
synchronized (d) { ... } // javac warning
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2021.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavacQuirks" defaultSeverity="WARNING" displayName="Javac quirks" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports known Javac issues, performance problems, and incompatibilities.
For example, type inference may be slow when it has to process many nested calls.
&lt;p&gt;The following code triggers a warning, as vararg method call has 50+ poly arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Arrays.asList(
      Arrays.asList("a", "b"),
      ...
      Arrays.asList("a100", "b100"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix adds explicit type arguments, which makes compilation and IDE processing much faster:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  //noinspection RedundantTypeArguments
  Arrays.&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;asList(
      Arrays.asList("a", "b"),
      ...
      Arrays.asList("a100", "b100"));
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Compliance" path="Android/Lint"><inspection shortName="AndroidLintExpiringTargetSdkVersion" defaultSeverity="ERROR" displayName="TargetSdkVersion Soon Expiring" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TargetSdkVersion Soon Expiring&lt;br&gt;&lt;br&gt;In the second half of 2018, Google Play will require that new apps and app updates target API level 26 or higher. This will be required for new apps in August 2018, and for updates to existing apps in November 2018.&lt;br/&gt;
&lt;br/&gt;
Configuring your app to target a recent API level ensures that users benefit from significant security and performance improvements, while still allowing your app to run on older Android versions (down to the &lt;code&gt;minSdkVersion&lt;/code&gt;).&lt;br/&gt;
&lt;br/&gt;
This lint check starts warning you some months &lt;b&gt;before&lt;/b&gt; these changes go into effect if your &lt;code&gt;targetSdkVersion&lt;/code&gt; is 25 or lower. This is intended to give you a heads up to update your app, since depending on your current &lt;code&gt;targetSdkVersion&lt;/code&gt; the work can be nontrivial.&lt;br/&gt;
&lt;br/&gt;
To update your &lt;code&gt;targetSdkVersion&lt;/code&gt;, follow the steps from "Meeting Google Play requirements for target API level", &lt;a href="https://developer.android.com/distribute/best-practices/develop/target-sdk.html"&gt;https://developer.android.com/distribute/best-practices/develop/target-sdk.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: ExpiringTargetSdkVersion&lt;br&gt;&lt;br&gt;&lt;a href="https://support.google.com/googleplay/android-developer/answer/113469#targetsdk"&gt;https://support.google.com/googleplay/android-developer/answer/113469#targetsdk&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOutdatedLibrary" defaultSeverity="WARNING" displayName="Outdated Library" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Outdated Library&lt;br&gt;&lt;br&gt;Your app is using an outdated version of a library. This may cause violations of Google Play policies (see &lt;a href="https://play.google.com/about/monetization-ads/ads/"&gt;https://play.google.com/about/monetization-ads/ads/&lt;/a&gt;) and/or may affect your app&amp;#8217;s visibility on the Play Store.&lt;br/&gt;
&lt;br/&gt;
Please try updating your app with an updated version of this library, or remove it from your app.&lt;br&gt;&lt;br&gt;Issue id: OutdatedLibrary&lt;br&gt;&lt;br&gt;&lt;a href="https://play.google.com/sdks"&gt;https://play.google.com/sdks&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPlaySdkIndexNonCompliant" defaultSeverity="ERROR" displayName="Library has policy issues in SDK Index" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Library has policy issues in SDK Index&lt;br&gt;&lt;br&gt;This library version has policy issues that will block publishing in the Google Play Store.&lt;br&gt;&lt;br&gt;Issue id: PlaySdkIndexNonCompliant&lt;br&gt;&lt;br&gt;&lt;a href="https://play.google.com/sdks"&gt;https://play.google.com/sdks&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExpiredTargetSdkVersion" defaultSeverity="ERROR" displayName="TargetSdkVersion No Longer Supported" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TargetSdkVersion No Longer Supported&lt;br&gt;&lt;br&gt;As of the second half of 2018, Google Play requires that new apps and app updates target API level 26 or higher.&lt;br/&gt;
&lt;br/&gt;
Configuring your app to target a recent API level ensures that users benefit from significant security and performance improvements, while still allowing your app to run on older Android versions (down to the &lt;code&gt;minSdkVersion&lt;/code&gt;).&lt;br/&gt;
&lt;br/&gt;
To update your &lt;code&gt;targetSdkVersion&lt;/code&gt;, follow the steps from "Meeting Google Play requirements for target API level", &lt;a href="https://developer.android.com/distribute/best-practices/develop/target-sdk.html"&gt;https://developer.android.com/distribute/best-practices/develop/target-sdk.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: ExpiredTargetSdkVersion&lt;br&gt;&lt;br&gt;&lt;a href="https://support.google.com/googleplay/android-developer/answer/113469#targetsdk"&gt;https://support.google.com/googleplay/android-developer/answer/113469#targetsdk&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintQueryAllPackagesPermission" defaultSeverity="ERROR" displayName="Using the QUERY_ALL_PACKAGES permission" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using the QUERY_ALL_PACKAGES permission&lt;br&gt;&lt;br&gt;If you need to query or interact with other installed apps, you should be using a &lt;code&gt;&amp;lt;queries&gt;&lt;/code&gt; declaration in your manifest. Using the QUERY_ALL_PACKAGES permission in order to see all installed apps is rarely necessary, and most apps on Google Play are not allowed to have this permission.&lt;br&gt;&lt;br&gt;Issue id: QueryAllPackagesPermission&lt;br&gt;&lt;br&gt;&lt;a href="https://g.co/dev/packagevisibility"&gt;https://g.co/dev/packagevisibility&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="YAML" path=""><inspection shortName="YAMLUnusedAnchor" defaultSeverity="WARNING" displayName="Unused anchor" enabled="true" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unused anchors.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  some_key: &amp;some_anchor
    key1: value1
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLSchemaDeprecation" defaultSeverity="WEAK WARNING" displayName="Deprecated YAML key" enabled="true" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports deprecated keys in YAML files.
&lt;p&gt;Deprecation is checked only if there exists a JSON schema associated with the corresponding YAML file.&lt;/p&gt;
&lt;p&gt;Note that the deprecation mechanism is not defined in the JSON Schema specification yet,
and this inspection uses a non-standard &lt;code&gt;deprecationMessage&lt;/code&gt; extension.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Scheme deprecation example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  {
    "properties": {
      "SomeDeprecatedProperty": {
        "deprecationMessage": "Baz",
        "description": "Foo bar"
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;The following is an example with the corresponding warning:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  SomeDeprecatedProperty: some value
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLUnresolvedAlias" defaultSeverity="ERROR" displayName="Unresolved alias" enabled="true" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unresolved aliases in YAML files.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  some_key: *unknown_alias
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLSchemaValidation" defaultSeverity="WARNING" displayName="Validation by JSON Schema" enabled="true" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports inconsistencies between a YAML file and a JSON Schema if the schema is specified.
&lt;p&gt;&lt;b&gt;Scheme example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  {
    "properties": {
      "SomeNumberProperty": {
        "type": "number"
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;The following is an example with the corresponding warning:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  SomeNumberProperty: hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLRecursiveAlias" defaultSeverity="ERROR" displayName="Recursive alias" enabled="true" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports recursion in YAML aliases.
&lt;p&gt;Alias can't be recursive and be used inside the data referenced by a corresponding anchor.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  some_key: &amp;some_anchor
    sub_key1: value1
    sub_key2: *some_anchor
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="YAMLDuplicatedKeys" defaultSeverity="ERROR" displayName="Duplicated YAML keys" enabled="true" language="yaml" pluginId="org.jetbrains.plugins.yaml" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports duplicated keys in YAML files.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  same_key: some value
  same_key: another value
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Internationalization" path=""><inspection shortName="LossyEncoding" defaultSeverity="WARNING" displayName="Lossy encoding" enabled="true" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;

Reports characters that cannot be displayed because of the current document encoding.
&lt;p&gt;Examples:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If you type international characters in a document with the &lt;b&gt;US-ASCII&lt;/b&gt; charset, some characters will be lost on save.&lt;/li&gt;
  &lt;li&gt;If you load a &lt;b&gt;UTF-8&lt;/b&gt;-encoded file using the &lt;b&gt;ISO-8859-1&lt;/b&gt; one-byte charset, some characters will be displayed incorrectly.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can fix this by changing the file encoding
either by specifying the encoding directly in the file, e.g. by editing &lt;code&gt;encoding=&lt;/code&gt; attribute in the XML prolog of XML file,
  or by changing the corresponding options in &lt;b&gt;Settings | Editor | File Encodings&lt;/b&gt;.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonAsciiCharacters" defaultSeverity="WARNING" displayName="Non-ASCII characters" enabled="true" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code elements that use non-ASCII symbols in an unusual context.

&lt;p&gt;Example:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Non-ASCII characters used in identifiers, strings, or comments.&lt;/li&gt;
  &lt;li&gt;Identifiers written in different languages, such as &lt;code&gt;my&lt;b&gt;&lt;/b&gt;ollection&lt;/code&gt; with the
    letter &lt;code&gt;&lt;b&gt;C&lt;/b&gt;&lt;/code&gt; written in Cyrillic.&lt;/li&gt;
  &lt;li&gt;Comments or strings containing Unicode symbols, such as long dashes and arrows.&lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Naming conventions" path="Groovy"><inspection shortName="GroovyInstanceVariableNamingConvention" defaultSeverity="WARNING" displayName="Instance variable naming convention" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instance variables whose names are too short, too long, or do not follow
the specified regular expression pattern.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 Use the fields provided below to specify minimum length, maximum length and regular expression expected for
  instance variable names.&lt;/p&gt;
&lt;p&gt;Regular expressions should be specified in the standard &lt;code&gt;java.util.regex&lt;/code&gt; format.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyParameterNamingConvention" defaultSeverity="WARNING" displayName="Method parameter naming convention" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method parameters whose names are either too short, too
long, or do not follow
the specified regular expression pattern.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the fields provided below to specify minimum length, maximum length and regular expression
  expected for method parameter names.&lt;/p&gt;
&lt;p&gt;Regular expressions should be specified in the standard &lt;code&gt;java.util.regex&lt;/code&gt; format.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyLocalVariableNamingConvention" defaultSeverity="WARNING" displayName="Local variable naming convention" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local variables whose names are too short, too long, or do not follow
the specified regular expression pattern.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the fields provided below to specify minimum length, maximum length and regular expression expected for local variables names.&lt;/p&gt;
&lt;p&gt;Regular expressions should be specified in the standard &lt;code&gt;java.util.regex&lt;/code&gt; format.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NewGroovyClassNamingConvention" defaultSeverity="WARNING" displayName="Class naming convention" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports classes whose names are too short, too long, or do not follow
  the specified regular expression pattern.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;For each class type, specify the minimum length, maximum length, and the regular expression expected for class names using the
  provided input fields.&lt;/p&gt;
&lt;p&gt;Regular expressions should be specified in the standard &lt;code&gt;java.util.regex&lt;/code&gt; format.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyStaticMethodNamingConvention" defaultSeverity="WARNING" displayName="Static method naming convention" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports static methods whose names are too short, too long, or do not follow
the specified regular expression pattern.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the fields provided below to specify minimum length, maximum length and regular expression expected for static method names.&lt;/p&gt;
&lt;p&gt;Regular expressions should be specified in the standard &lt;code&gt;java.util.regex&lt;/code&gt; format.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInstanceMethodNamingConvention" defaultSeverity="WARNING" displayName="Instance method naming convention" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instance methods whose names are too short, too long, or do not follow
the specified regular expression pattern. Instance methods that override library
methods are ignored by this inspection.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the fields provided below to specify minimum length, maximum length and regular expression expected for instance method names.&lt;/p&gt;
&lt;p&gt;Regular expressions should be specified in the standard &lt;code&gt;java.util.regex&lt;/code&gt; format.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConstantNamingConvention" defaultSeverity="WARNING" displayName="Constant naming convention" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports constant with names which don't match the specified convention.
&lt;p&gt;Constants are fields of immutable type declared with &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;final&lt;/code&gt; modifiers.&lt;/p&gt;
Reports constants whose names are either too short, too long, or do not follow
the specified regular expression pattern.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Pattern&lt;/b&gt; field to specify &lt;code&gt;java.util.regex.Pattern&lt;/code&gt; which a constant name is expected to match.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Min length&lt;/b&gt; field to specify the minimum length of a constant name.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Max length&lt;/b&gt; field to specify the maximum length of a constant name.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyStaticVariableNamingConvention" defaultSeverity="WARNING" displayName="Static variable naming convention" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;static&lt;/code&gt; variables whose names are too short, too long,
or do not follow
the specified regular expression pattern.
&lt;p&gt;
  Constants, i.e. variables of immutable type declared
  &lt;code&gt;static final&lt;/code&gt;, are not checked by this inspection
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 Use the fields provided below to specify minimum length, maximum length and regular expression expected for static variable names.
&lt;p&gt;Regular expressions should be specified in the standard &lt;code&gt;java.util.regex&lt;/code&gt; format.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Android Lint: Accessibility" path="Android/Lint"><inspection shortName="AndroidLintClickableViewAccessibility" defaultSeverity="WARNING" displayName="Accessibility in Custom Views" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Accessibility in Custom Views&lt;br&gt;&lt;br&gt;If a &lt;code&gt;View&lt;/code&gt; that overrides &lt;code&gt;onTouchEvent&lt;/code&gt; or uses an &lt;code&gt;OnTouchListener&lt;/code&gt; does not also implement &lt;code&gt;performClick&lt;/code&gt; and call it when clicks are detected, the &lt;code&gt;View&lt;/code&gt; may not handle accessibility actions properly. Logic handling the click actions should ideally be placed in &lt;code&gt;View#performClick&lt;/code&gt; as some accessibility services invoke &lt;code&gt;performClick&lt;/code&gt; when a click action should occur.&lt;br&gt;&lt;br&gt;Issue id: ClickableViewAccessibility&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLabelFor" defaultSeverity="WARNING" displayName="Missing accessibility label" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing accessibility label&lt;br&gt;&lt;br&gt;Editable text fields should provide an &lt;code&gt;android:hint&lt;/code&gt; or, provided your &lt;code&gt;minSdkVersion&lt;/code&gt; is at least 17, they may be referenced by a view with a &lt;code&gt;android:labelFor&lt;/code&gt; attribute.&lt;br/&gt;
&lt;br/&gt;
When using &lt;code&gt;android:labelFor&lt;/code&gt;, be sure to provide an &lt;code&gt;android:text&lt;/code&gt; or an &lt;code&gt;android:contentDescription&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If your view is labeled but by a label in a different layout which includes this one, just suppress this warning from lint.&lt;br&gt;&lt;br&gt;Issue id: LabelFor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintContentDescription" defaultSeverity="WARNING" displayName="Image without contentDescription" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Image without &lt;code&gt;contentDescription&lt;/code&gt;&lt;br&gt;&lt;br&gt;Non-textual widgets like ImageViews and ImageButtons should use the &lt;code&gt;contentDescription&lt;/code&gt; attribute to specify a textual description of the widget such that screen readers and other accessibility tools can adequately describe the user interface.&lt;br/&gt;
&lt;br/&gt;
Note that elements in application screens that are purely decorative and do not provide any content or enable a user action should not have accessibility content descriptions. In this case, just suppress the lint warning with a tools:ignore="ContentDescription" attribute.&lt;br/&gt;
&lt;br/&gt;
Note that for text fields, you should not set both the &lt;code&gt;hint&lt;/code&gt; and the &lt;code&gt;contentDescription&lt;/code&gt; attributes since the hint will never be shown. Just set the &lt;code&gt;hint&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: ContentDescription&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/accessibility/apps#special-cases"&gt;https://developer.android.com/guide/topics/ui/accessibility/apps#special-cases&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGetContentDescriptionOverride" defaultSeverity="ERROR" displayName="Overriding getContentDescription() on a View" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Overriding &lt;code&gt;getContentDescription()&lt;/code&gt; on a View&lt;br&gt;&lt;br&gt;Overriding &lt;code&gt;getContentDescription()&lt;/code&gt; may prevent some accessibility services from properly navigating content exposed by your view. Instead, call &lt;code&gt;setContentDescription()&lt;/code&gt; when the content description needs to be changed.&lt;br&gt;&lt;br&gt;Issue id: GetContentDescriptionOverride&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintKeyboardInaccessibleWidget" defaultSeverity="WARNING" displayName="Keyboard inaccessible widget" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Keyboard inaccessible widget&lt;br&gt;&lt;br&gt;A widget that is declared to be clickable but not declared to be focusable is not accessible via the keyboard. Please add the &lt;code&gt;focusable&lt;/code&gt; attribute as well.&lt;br&gt;&lt;br&gt;Issue id: KeyboardInaccessibleWidget&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Android Lint: Performance" path="Android/Lint/Performance"><inspection shortName="AndroidLintDuplicateStrings" defaultSeverity="WARNING" displayName="Duplicate Strings" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate Strings&lt;br&gt;&lt;br&gt;Duplicate strings can make applications larger unnecessarily.&lt;br/&gt;
&lt;br/&gt;
This lint check looks for duplicate strings, including differences for strings where the only difference is in capitalization. Title casing and all uppercase can all be adjusted in the layout or in code.&lt;br&gt;&lt;br&gt;Issue id: DuplicateStrings&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/widget/TextView.html#attr_android:inputType"&gt;https://developer.android.com/reference/android/widget/TextView.html#attr_android:inputType&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Declaration redundancy" path="Java"><inspection shortName="FinalMethodInFinalClass" defaultSeverity="WARNING" displayName="'final' method in 'final' class" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;final&lt;/code&gt; methods in &lt;code&gt;final&lt;/code&gt; classes.
&lt;p&gt;Since &lt;code&gt;final&lt;/code&gt; classes cannot be inherited, marking a method as &lt;code&gt;final&lt;/code&gt;
  may be unnecessary and confusing.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;record Bar(int a, int b) {
  public final int sum() { 
     return a + b;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;record Bar(int a, int b) {
  public int sum() { 
     return a + b;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As shown in the example, a class can be marked as &lt;code&gt;final&lt;/code&gt; explicitly or implicitly.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AccessStaticViaInstance" defaultSeverity="WARNING" displayName="Access static member via instance reference" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports references to &lt;code&gt;static&lt;/code&gt; methods and fields via a class instance rather than the class itself.
&lt;p&gt;Even though referring to static members via instance variables is allowed by The Java Language Specification,
  this makes the code confusing as the reader may think that the result of the method depends on the instance.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the instance variable with the class name.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s1 = s.valueOf(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = String.valueOf(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SameParameterValue" defaultSeverity="WARNING" displayName="Method parameter value is always the same constant" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports method parameters that always have the same constant value.

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static void printPoint(int x, int y) { // x is always 0
    System.out.println(x + ", " + y);
  }

  public static void main(String[] args) {
    printPoint(0, 1);
    printPoint(0, 2);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix inlines the constant value. This may simplify the method implementation.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignore when inline parameter initializer would not succeed&lt;/b&gt; option to suppress the inspections when:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the parameter is modified inside the method.&lt;/li&gt;
  &lt;li&gt;the parameter value that is being passed is a reference to an inaccessible field (only in Java).&lt;/li&gt;
  &lt;li&gt;the parameter is a vararg (only in Java).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  Use the &lt;b&gt;Maximal reported method visibility&lt;/b&gt; option to control the maximum visibility of methods to be reported.
&lt;/p&gt;
&lt;p&gt;
  Use the &lt;b&gt;Minimal reported method usage count&lt;/b&gt; field to specify the minimal number of method usages with the same parameter value.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="unused" defaultSeverity="WARNING" displayName="Unused declaration" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports classes, methods, or fields in the specified inspection scope that are not used or unreachable from entry points.
&lt;p&gt; An entry point can be the main method, tests, classes mentioned outside the specified scope, classes accessible from
  &lt;code&gt;module-info.java&lt;/code&gt;, and so on. You can also configure custom entry points by using name patterns or annotations.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Department {
    private Organization myOrganization;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, &lt;code&gt;Department&lt;/code&gt; explicitly references &lt;code&gt;Organization&lt;/code&gt; but if &lt;code&gt;Department&lt;/code&gt; class itself is unused, then inspection will report both classes. &lt;/p&gt;
&lt;p&gt;
  The inspection also reports parameters that are not used by their methods and all method implementations and overriders, as well as local
  variables that are declared but not used.
&lt;/p&gt;
&lt;p&gt;
  &lt;b&gt;Note:&lt;/b&gt; Some unused members may not be reported during in-editor code highlighting. For performance reasons, a non-private member is
  checked only when its name rarely occurs in the project.
  To see all results, run the inspection by selecting &lt;b&gt;Code | Inspect Code&lt;/b&gt; or &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; from the main menu.
&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the visibility settings below to configure members to be reported. For example, configuring report &lt;code&gt;private&lt;/code&gt; methods only means
  that &lt;code&gt;public&lt;/code&gt; methods of &lt;code&gt;private&lt;/code&gt; inner class will be reported but &lt;code&gt;protected&lt;/code&gt; methods of top level class
  will be ignored.&lt;/p&gt;
&lt;p&gt;
  Use the &lt;b&gt;entry points&lt;/b&gt; tab to configure entry points to be considered during the inspection run.&lt;/p&gt;
&lt;p&gt; You can add entry points manually when inspection results are ready.&lt;/p&gt;
&lt;p&gt; If your code uses unsupported frameworks, there are several options:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If the framework relies on annotations, use the &lt;b&gt;Annotations...&lt;/b&gt; button to configure the framework's annotations.&lt;/li&gt;
  &lt;li&gt;If the framework doesn't rely on annotations, try to configure class name patterns that are expected by the framework.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This way the annotated code accessible by the framework internals will be treated as used.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyMethod" defaultSeverity="WARNING" displayName="Empty method" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports empty methods that can be removed.
&lt;p&gt;Methods are considered empty if they are empty themselves and if they are overridden or
 implemented by empty methods only. Note that methods containing only comments and the &lt;code&gt;super()&lt;/code&gt; call with own parameters are
  also considered empty.&lt;/p&gt;
&lt;p&gt;The inspection ignores methods with special annotations, for example, the &lt;code&gt;javax.ejb.Init&lt;/code&gt; and &lt;code&gt;javax.ejb.Remove&lt;/code&gt; EJB annotations .&lt;/p&gt;
&lt;p&gt;The quick-fix safely removes unnecessary methods.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Comments and javadoc count as content&lt;/b&gt; option to select whether methods with comments should be treated as non-empty.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Additional special annotations&lt;/b&gt; option to configure additional annotations that should be ignored by this inspection.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedLabel" defaultSeverity="WARNING" displayName="Unused label" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports labels that are not targets of any &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; statements.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  label: &lt;b&gt;for&lt;/b&gt; (int i = 0; i &amp;lt; 10; i++) {
    &lt;b&gt;if&lt;/b&gt; (i == 3) {
      &lt;b&gt;break&lt;/b&gt;;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied, the label is removed:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;for&lt;/b&gt; (int i = 0; i &amp;lt; 10; i++) {
    &lt;b&gt;if&lt;/b&gt; (i == 3) {
      &lt;b&gt;break&lt;/b&gt;;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantRecordConstructor" defaultSeverity="WARNING" displayName="Redundant record constructor" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant constructors declared inside Java records.
&lt;p&gt;&lt;b&gt;Example 1:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record Point(int x, int y) {
    public Point {} // could be removed
  }
  
  record Point(int x, int y) {
    public Point(int x, int y) { // could be removed
      this.x = x;
      this.y = y;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix removes the redundant constructors.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example 2:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
   // could be converted to compact constructor
  record Range(int from, int to) {
    public Range(int from, int to) {
      if (from &gt; to) throw new IllegalArgumentException();
      this.from = from;
      this.to = to;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix converts this code into a compact constructor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 16 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2020.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantLambdaParameterType" defaultSeverity="INFORMATION" displayName="Redundant lambda parameter types" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports lambda formal parameter types that are redundant because they can be inferred from the context.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Map&amp;lt;String, Integer&amp;gt; map = ...
  map.forEach((String s, Integer i) -&gt; log.info(s + "=" + i));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix removes the parameter types from the lambda.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Map&amp;lt;String, Integer&amp;gt; map = ...
  map.forEach((s, i) -&gt; log.info(s + "=" + i));
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WeakerAccess" defaultSeverity="WARNING" displayName="Declaration access can be weaker" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports all fields, methods or classes, found in the specified inspection
scope that may have their access modifier narrowed down.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Sample {
    void foo() {
        bar("foo", "foo");
    }
    void bar(String x, String y) { } // can be private
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the inspection's options to define the rules for the modifier change suggestions.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SillyAssignment" defaultSeverity="WARNING" displayName="Variable is assigned to itself" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignments of a variable to itself.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix removes the assigment.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrivialFunctionalExpressionUsage" defaultSeverity="WARNING" displayName="Trivial usage of functional expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports functional interface methods calls that are directly invoked on the definition of the lambda, method reference, or anonymous class.
Such method calls can be replaced with the body of the functional interface implementation.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean contains(List&amp;lt;String&amp;gt; names, String name) {
    return ((Predicate&amp;lt;String&amp;gt;)x -&gt; {
      return names.contains(x);
    }).test(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the quick-fix is applied, the method call changes to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean contains(List&amp;lt;String&amp;gt; names, String name) {
    return names.contains(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SameReturnValue" defaultSeverity="WARNING" displayName="Method returns the same value" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports methods and method hierarchies in which the return value always appears to
be the same constant.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedLibrary" defaultSeverity="WARNING" displayName="Unused library" enabled="false" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports libraries attached to the specified inspection scope that
are not used directly in code.
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DefaultAnnotationParam" defaultSeverity="WARNING" displayName="Default annotation parameter value" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports annotation parameters that are assigned to their &lt;code&gt;default&lt;/code&gt; value.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @interface Test {
      Class&amp;lt;?&gt; expected() default Throwable.class;
  }

  @Test(expected = Throwable.class)
  void testSmth() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test()
  void testSmth() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyInitializer" defaultSeverity="WARNING" displayName="Empty class initializer" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports empty class initializer blocks.
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CanBeFinal" defaultSeverity="WARNING" displayName="Declaration can have 'final' modifier" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports all fields, methods, or classes found in the specified inspection scope that may have the &lt;code&gt;final&lt;/code&gt; modifier added to their
declarations.
&lt;p&gt;Final classes can't be extended, final methods can't be overridden, and final fields can't be reassigned.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Report classes&lt;/b&gt; and &lt;b&gt;Report methods&lt;/b&gt; options to define which declarations are to be reported.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnnecessaryModuleDependencyInspection" defaultSeverity="WARNING" displayName="Unnecessary module dependency" enabled="true" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports dependencies on modules that are not used. The quick-fix safely removes such unused dependencies.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantThrows" defaultSeverity="WARNING" displayName="Redundant 'throws' clause" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports exceptions that are declared in a method's signature but never thrown by the method itself or its implementations and derivatives.
&lt;p&gt;The inspection ignores methods related to the serialization, for example methods &lt;code&gt;readObject()&lt;/code&gt; or &lt;code&gt;writeObject()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void method() throws InterruptedException {
    System.out.println();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix removes unnecessary exceptions from the declaration and normalizes the redundant &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt; statements:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void method() {
    System.out.println();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;b&gt;Note:&lt;/b&gt; Some exceptions might not be reported during in-editor highlighting.
  For performance reasons, a non-private method is checked only when its name rarely occurs in the project.
  To see all results, run the inspection by selecting  &lt;b&gt;Code | Inspect Code&lt;/b&gt; or &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; from the main menu.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore exceptions thrown by entry points methods&lt;/b&gt; option to ignore exceptions thrown by entry points methods.
  Entry points methods are configured the following inspection: &lt;b&gt;Editor | Inspections | Java | Declaration redundancy | Unused declaration&lt;/b&gt;.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionalExpressionCanBeFolded" defaultSeverity="WARNING" displayName="Functional expression can be folded" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method references or lambda expressions that point to a method of their own functional interface type and hence can be
replaced with their qualifiers removing unnecessary object allocation.

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  SwingUtilities.invokeLater(r::run);
  SwingUtilities.invokeAndWait(() -&gt; r.run());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  SwingUtilities.invokeLater(r);
  SwingUtilities.invokeAndWait(r);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports only if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantImplements" defaultSeverity="WARNING" displayName="Redundant interface declaration" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes declaring that they implement or extend an interface, when
that interface is already declared as &lt;code&gt;implemented&lt;/code&gt; by a superclass or extended by another interface
of that class. Such declarations are unnecessary and may be safely removed.
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java9RedundantRequiresStatement" defaultSeverity="WARNING" displayName="Redundant 'requires' directive in module-info" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports redundant &lt;code&gt;requires&lt;/code&gt; directives in Java Platform Module System &lt;code&gt;module-info.java&lt;/code&gt; files.
A &lt;code&gt;requires&lt;/code&gt; directive is redundant when a module &lt;code&gt;A&lt;/code&gt; requires a module &lt;code&gt;B&lt;/code&gt;,
but the code in module &lt;code&gt;A&lt;/code&gt; doesn't import any packages or classes from &lt;code&gt;B&lt;/code&gt;.
Furthermore, all modules have an implicitly declared dependence on the &lt;code&gt;java.base&lt;/code&gt; module,
therefore a &lt;code&gt;requires java.base;&lt;/code&gt; directive is always redundant.
&lt;p&gt;
  The quick-fix deletes the redundant &lt;code&gt;requires&lt;/code&gt; directive.
  If the deleted dependency re-exported modules that are actually used, the fix adds a &lt;code&gt;requires&lt;/code&gt; directives for these modules.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 9 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2017.1&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedReturnValue" defaultSeverity="WARNING" displayName="Method can be made 'void'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports methods whose return values are never used when called.
The return type of such methods can be made &lt;code&gt;void&lt;/code&gt;.
&lt;p&gt;Methods annotated with Error Prone's or AssertJ's &lt;code&gt;@CanIgnoreReturnValue&lt;/code&gt; annotation will not be reported.
  The quick-fix updates the method signature and removes &lt;code&gt;return&lt;/code&gt; statements from inside the method.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // reported if visibility setting is Protected or Public
  protected String myToUpperCase(String s) {
    return s.toUpperCase();
  }

  // simple setter, reporting depends on setting
  public String setStr(String str) {
    myStr = str;
    return myStr;
  }

  void test() {
    setStr("value");          // return value is unused
    myToUpperCase("result");  // return value is unused
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied to both methods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    protected void myToUpperCase(String s) {
      // 'return' removed completely
      // as 's.toUpperCase()' has no side effect
    }

    public void setStr(String str) {
      myStr = str;
      // 'return' removed
    }
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;b&gt;NOTE:&lt;/b&gt; Some methods might not be reported during in-editor highlighting due to performance reasons.
  To see all results, run the inspection using &lt;b&gt;Code | Inspect Code&lt;/b&gt; or &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt;&gt;
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore simple setters&lt;/b&gt; option to ignore unused return values from simple setter calls.&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Maximal reported method visibility&lt;/b&gt; option to control the maximum visibility of methods to be reported.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DuplicateThrows" defaultSeverity="WARNING" displayName="Duplicate throws" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports duplicate exceptions in a method &lt;code&gt;throws&lt;/code&gt; list.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f() throws Exception, Exception {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f() throws Exception {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignore exceptions subclassing others &lt;/b&gt; option to ignore exceptions subclassing other exceptions.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantExplicitClose" defaultSeverity="WARNING" displayName="Redundant 'close()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary calls to &lt;code&gt;close()&lt;/code&gt; at the end of a try-with-resources block and suggests removing them.
&lt;p&gt;&lt;b&gt;Example&lt;/b&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try(MyAutoCloseable ac = new MyAutoCloseable()) {
    foo();
    ac.close();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try(MyAutoCloseable ac = new MyAutoCloseable()) {
    foo();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProtectedMemberInFinalClass" defaultSeverity="WARNING" displayName="'protected' member in 'final' class" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;protected&lt;/code&gt; members in &lt;code&gt;final&lt;/code&gt;classes.
&lt;p&gt;Since &lt;code&gt;final&lt;/code&gt; classes cannot be inherited, marking the method as &lt;code&gt;protected&lt;/code&gt;
  may be confusing. It is better to declare such members as &lt;code&gt;private&lt;/code&gt; or package-visible instead.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;record Bar(int a, int b) {
  protected int sum() { 
     return a + b;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;record Bar(int a, int b) {
  int sum() { 
     return a + b;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As shown in the example, a class can be marked as &lt;code&gt;final&lt;/code&gt; explicitly or implicitly.&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Compose preview" path=""><inspection shortName="PreviewFontScaleMustBeGreaterThanZero" defaultSeverity="ERROR" displayName="Non-positive fontScale parameter" enabled="true" language="kotlin" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false"></inspection><inspection shortName="PreviewMustBeTopLevelFunction" defaultSeverity="ERROR" displayName="Preview must be a top level declarations or in a top level class with a default constructor." enabled="true" language="kotlin" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false"></inspection><inspection shortName="PreviewDimensionRespectsLimit" defaultSeverity="WARNING" displayName="Preview dimension has a maximum limit" enabled="true" language="kotlin" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false"></inspection><inspection shortName="PreviewPickerAnnotation" defaultSeverity="ERROR" displayName="Preview device parameter must have valid syntax" enabled="true" language="kotlin" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false"></inspection><inspection shortName="TransitionPropertiesLabel" defaultSeverity="WARNING" displayName="Transition property label parameter not set" enabled="true" language="kotlin" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false"></inspection><inspection shortName="UpdateTransitionLabel" defaultSeverity="WARNING" displayName="Transition label parameter not set" enabled="true" language="kotlin" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false"></inspection><inspection shortName="PreviewApiLevelMustBeValid" defaultSeverity="ERROR" displayName="Preview apiLevel must correspond to a supported API level" enabled="true" language="kotlin" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false"></inspection><inspection shortName="PreviewAnnotationInFunctionWithParameters" defaultSeverity="ERROR" displayName="Preview used on a Composable function with parameters" enabled="true" language="kotlin" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false"></inspection><inspection shortName="PreviewNotSupportedInUnitTestFiles" defaultSeverity="ERROR" displayName="Preview is not supported in unit test files." enabled="true" language="kotlin" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false"></inspection><inspection shortName="PreviewNeedsComposableAnnotation" defaultSeverity="ERROR" displayName="Preview used on a non-Composable function" enabled="true" language="kotlin" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false"></inspection><inspection shortName="PreviewMultipleParameterProviders" defaultSeverity="ERROR" displayName="Multiple @PreviewParameter are not allowed." enabled="true" language="kotlin" pluginId="com.android.tools.design" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false"></inspection></group><group name="Android Lint: Correctness" path="Android/Lint/Correctness"><inspection shortName="AndroidLintPluralsCandidate" defaultSeverity="WARNING" displayName="Potential Plurals" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Potential Plurals&lt;br&gt;&lt;br&gt;This lint check looks for potential errors in internationalization where you have translated a message which involves a quantity and it looks like other parts of the string may need grammatical changes.&lt;br/&gt;
&lt;br/&gt;
For example, rather than something like this:
&lt;pre&gt;
  &amp;lt;string name="try_again"&gt;Try again in %d seconds.&amp;lt;/string&gt;
&lt;/pre&gt;
you should be using a plural:
&lt;pre&gt;
   &amp;lt;plurals name="try_again"&gt;
        &amp;lt;item quantity="one"&gt;Try again in %d second&amp;lt;/item&gt;
        &amp;lt;item quantity="other"&gt;Try again in %d seconds&amp;lt;/item&gt;
    &amp;lt;/plurals&gt;
&lt;/pre&gt;
This will ensure that in other languages the right set of translations are provided for the different quantity classes.&lt;br/&gt;
&lt;br/&gt;
(This check depends on some heuristics, so it may not accurately determine whether a string really should be a quantity. You can use tools:ignore to filter out false positives.&lt;br&gt;&lt;br&gt;Issue id: PluralsCandidate&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html#Plurals"&gt;https://developer.android.com/guide/topics/resources/string-resource.html#Plurals&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUntranslatable" defaultSeverity="WARNING" displayName="Translated Untranslatable" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Translated Untranslatable&lt;br&gt;&lt;br&gt;Strings can be marked with &lt;code&gt;translatable=false&lt;/code&gt; to indicate that they are not intended to be translated, but are present in the resource file for other purposes (for example for non-display strings that should vary by some other configuration qualifier such as screen size or API level).&lt;br/&gt;
&lt;br/&gt;
There are cases where translators accidentally translate these strings anyway, and lint will flag these occurrences with this lint check.&lt;br&gt;&lt;br&gt;Issue id: Untranslatable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPermissionImpliesUnsupportedChromeOsHardware" defaultSeverity="ERROR" displayName="Permission Implies Unsupported Chrome OS Hardware" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission Implies Unsupported Chrome OS Hardware&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-permission&gt;&lt;/code&gt; element should not require a permission that implies an unsupported Chrome OS hardware feature. Google Play assumes that certain hardware related permissions indicate that the underlying hardware features are required by default. To fix the issue, consider declaring the corresponding uses-feature element with &lt;code&gt;required="false"&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: PermissionImpliesUnsupportedChromeOsHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/arc/manifest.html#implied-features"&gt;https://developer.android.com/topic/arc/manifest.html#implied-features&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringFormatMatches" defaultSeverity="ERROR" displayName="String.format string doesn't match the XML format string" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;String.format&lt;/code&gt; string doesn't match the XML format string&lt;br&gt;&lt;br&gt;This lint check ensures the following:&lt;br/&gt;
(1) If there are multiple translations of the format string, then all translations use the same type for the same numbered arguments&lt;br/&gt;
(2) The usage of the format string in Java is consistent with the format string, meaning that the parameter types passed to String.format matches those in the format string.&lt;br&gt;&lt;br&gt;Issue id: StringFormatMatches&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringEscaping" defaultSeverity="ERROR" displayName="Invalid string escapes" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid string escapes&lt;br&gt;&lt;br&gt;Apostrophes (') must always be escaped (with a \\), unless they appear in a string which is itself escaped in double quotes (").&lt;br&gt;&lt;br&gt;Issue id: StringEscaping&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingTranslation" defaultSeverity="ERROR" displayName="Incomplete translation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incomplete translation&lt;br&gt;&lt;br&gt;If an application has more than one locale, then all the strings declared in one language should also be translated in all other languages.&lt;br/&gt;
&lt;br/&gt;
If the string should &lt;b&gt;not&lt;/b&gt; be translated, you can add the attribute &lt;code&gt;translatable="false"&lt;/code&gt; on the &lt;code&gt;&amp;lt;string&gt;&lt;/code&gt; element, or you can define all your non-translatable strings in a resource file called &lt;code&gt;donottranslate.xml&lt;/code&gt;. Or, you can ignore the issue with a &lt;code&gt;tools:ignore="MissingTranslation"&lt;/code&gt; attribute.&lt;br/&gt;
&lt;br/&gt;
You can tell lint (and other tools) which language is the default language in your &lt;code&gt;res/values/&lt;/code&gt; folder by specifying &lt;code&gt;tools:locale="languageCode"&lt;/code&gt; for the root &lt;code&gt;&amp;lt;resources&gt;&lt;/code&gt; element in your resource file. (The &lt;code&gt;tools&lt;/code&gt; prefix refers to the namespace declaration &lt;code&gt;http://schemas.android.com/tools&lt;/code&gt;.)&lt;br&gt;&lt;br&gt;Issue id: MissingTranslation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingQuantity" defaultSeverity="ERROR" displayName="Missing quantity translation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing quantity translation&lt;br&gt;&lt;br&gt;Different languages have different rules for grammatical agreement with quantity. In English, for example, the quantity 1 is a special case. We write "1 book", but for any other quantity we'd write "n books". This distinction between singular and plural is very common, but other languages make finer distinctions.&lt;br/&gt;
&lt;br/&gt;
This lint check looks at each translation of a &lt;code&gt;&amp;lt;plural&gt;&lt;/code&gt; and makes sure that all the quantity strings considered by the given language are provided by this translation.&lt;br/&gt;
&lt;br/&gt;
For example, an English translation must provide a string for &lt;code&gt;quantity="one"&lt;/code&gt;. Similarly, a Czech translation must provide a string for &lt;code&gt;quantity="few"&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: MissingQuantity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html#Plurals"&gt;https://developer.android.com/guide/topics/resources/string-resource.html#Plurals&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsupportedChromeOsHardware" defaultSeverity="ERROR" displayName="Unsupported Chrome OS Hardware Feature" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsupported Chrome OS Hardware Feature&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-feature&gt;&lt;/code&gt; element should not require this unsupported Chrome OS hardware feature. Any uses-feature not explicitly marked with &lt;code&gt;required="false"&lt;/code&gt; is necessary on the device to be installed on. Ensure that any features that might prevent it from being installed on a Chrome OS device are reviewed and marked as not required in the manifest.&lt;br&gt;&lt;br&gt;Issue id: UnsupportedChromeOsHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/arc/manifest.html#incompat-entries"&gt;https://developer.android.com/topic/arc/manifest.html#incompat-entries&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringFormatCount" defaultSeverity="WARNING" displayName="Formatting argument types incomplete or inconsistent" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Formatting argument types incomplete or inconsistent&lt;br&gt;&lt;br&gt;When a formatted string takes arguments, it usually needs to reference the same arguments in all translations (or all arguments if there are no translations.&lt;br/&gt;
&lt;br/&gt;
There are cases where this is not the case, so this issue is a warning rather than an error by default. However, this usually happens when a language is not translated or updated correctly.&lt;br&gt;&lt;br&gt;Issue id: StringFormatCount&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedTranslation" defaultSeverity="WARNING" displayName="Unused Translation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unused Translation&lt;br&gt;&lt;br&gt;If an application defines a translation for a language which is not included in the app's &lt;code&gt;localeConfig&lt;/code&gt; file (when declared in the manifest), that language will be "unused"; it will not be presented to the user. Usually this means you have forgotten to include it in the locale config file.&lt;br&gt;&lt;br&gt;Issue id: UnusedTranslation&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/about/versions/13/features/app-languages"&gt;https://developer.android.com/about/versions/13/features/app-languages&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringFormatInvalid" defaultSeverity="ERROR" displayName="Invalid format string" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid format string&lt;br&gt;&lt;br&gt;If a string contains a '%' character, then the string may be a formatting string which will be passed to &lt;code&gt;String.format&lt;/code&gt; from Java code to replace each '%' occurrence with specific values.&lt;br/&gt;
&lt;br/&gt;
This lint warning checks for two related problems:&lt;br/&gt;
(1) Formatting strings that are invalid, meaning that &lt;code&gt;String.format&lt;/code&gt; will throw exceptions at runtime when attempting to use the format string.&lt;br/&gt;
(2) Strings containing '%' that are not formatting strings getting passed to a &lt;code&gt;String.format&lt;/code&gt; call. In this case the '%' will need to be escaped as '%%'.&lt;br/&gt;
&lt;br/&gt;
NOTE: Not all Strings which look like formatting strings are intended for use by &lt;code&gt;String.format&lt;/code&gt;; for example, they may contain date formats intended for &lt;code&gt;android.text.format.Time#format()&lt;/code&gt;. Lint cannot always figure out that a String is a date format, so you may get false warnings in those scenarios. See the suppress help topic for information on how to suppress errors in that case.&lt;br&gt;&lt;br&gt;Issue id: StringFormatInvalid&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExtraTranslation" defaultSeverity="ERROR" displayName="Extra translation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Extra translation&lt;br&gt;&lt;br&gt;If a string appears in a specific language translation file, but there is no corresponding string in the default locale, then this string is probably unused. (It's technically possible that your application is only intended to run in a specific locale, but it's still a good idea to provide a fallback.)&lt;br/&gt;
&lt;br/&gt;
Note that these strings can lead to crashes if the string is looked up on any locale not providing a translation, so it's important to clean them up.&lt;br&gt;&lt;br&gt;Issue id: ExtraTranslation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintImpliedQuantity" defaultSeverity="ERROR" displayName="Implied Quantities" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implied Quantities&lt;br&gt;&lt;br&gt;Plural strings should generally include a &lt;code&gt;%s&lt;/code&gt; or &lt;code&gt;%d&lt;/code&gt; formatting argument. In locales like English, the &lt;code&gt;one&lt;/code&gt; quantity only applies to a single value, 1, but that's not true everywhere. For example, in Slovene, the &lt;code&gt;one&lt;/code&gt; quantity will apply to 1, 101, 201, 301, and so on. Similarly, there are locales where multiple values match the &lt;code&gt;zero&lt;/code&gt; and &lt;code&gt;two&lt;/code&gt; quantities.&lt;br/&gt;
&lt;br/&gt;
In these locales, it is usually an error to have a message which does not include a formatting argument (such as '%d'), since it will not be clear from the grammar what quantity the quantity string is describing.&lt;br&gt;&lt;br&gt;Issue id: ImpliedQuantity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html#Plurals"&gt;https://developer.android.com/guide/topics/resources/string-resource.html#Plurals&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTypos" defaultSeverity="WARNING" displayName="Spelling error" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Spelling error&lt;br&gt;&lt;br&gt;This check looks through the string definitions, and if it finds any words that look like likely misspellings, they are flagged.&lt;br&gt;&lt;br&gt;Issue id: Typos&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedQuantity" defaultSeverity="WARNING" displayName="Unused quantity translations" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unused quantity translations&lt;br&gt;&lt;br&gt;Android defines a number of different quantity strings, such as &lt;code&gt;zero&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;few&lt;/code&gt; and &lt;code&gt;many&lt;/code&gt;. However, many languages do not distinguish grammatically between all these different quantities.&lt;br/&gt;
&lt;br/&gt;
This lint check looks at the quantity strings defined for each translation and flags any quantity strings that are unused (because the language does not make that quantity distinction, and Android will therefore not look it up).&lt;br/&gt;
&lt;br/&gt;
For example, in Chinese, only the &lt;code&gt;other&lt;/code&gt; quantity is used, so even if you provide translations for &lt;code&gt;zero&lt;/code&gt; and &lt;code&gt;one&lt;/code&gt;, these strings will &lt;b&gt;not&lt;/b&gt; be returned when &lt;code&gt;getQuantityString()&lt;/code&gt; is called, even with &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: UnusedQuantity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html#Plurals"&gt;https://developer.android.com/guide/topics/resources/string-resource.html#Plurals&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Finalization" path="Java"><inspection shortName="FinalizeNotProtected" defaultSeverity="WARNING" displayName="'finalize()' should be protected, not public" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any implementations of the &lt;code&gt;Object.finalize()&lt;/code&gt; method that are
declared &lt;code&gt;public&lt;/code&gt;.
&lt;p&gt;
  According to the contract of the &lt;code&gt;Object.finalize()&lt;/code&gt;, only the garbage
  collector calls this method. Making this method public may be confusing, because it
  means that the method can be used by users.
&lt;/p&gt;
&lt;p&gt;
  The quick-fix makes the method protected to prevent it from being explicitly invoked
  by other classes.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;class&lt;/b&gt; X {
    &lt;b&gt;public void&lt;/b&gt; finalize() {
      /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;class&lt;/b&gt; X {
    &lt;b&gt;protected void&lt;/b&gt; finalize() {
      /* ... */
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Finalize" defaultSeverity="WARNING" displayName="'finalize()' should not be overridden" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports overriding the &lt;code&gt;Object.finalize()&lt;/code&gt; method.
&lt;p&gt;According to the &lt;code&gt;Object.finalize()&lt;/code&gt; documentation:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;
    The finalization mechanism is inherently problematic. Finalization can lead
    to performance issues, deadlocks, and hangs. Errors in finalizers can lead
    to resource leaks; there is no way to cancel finalization if it is no longer
    necessary; and no ordering is specified among calls to &lt;code&gt;finalize&lt;/code&gt;
    methods of different objects. Furthermore, there are no guarantees regarding
    the timing of finalization. The &lt;code&gt;finalize&lt;/code&gt; method might be called
    on a finalizable object only after an indefinite delay, if at all.
  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Ignore for trivial 'finalize()' implementations&lt;/b&gt; option to ignore
    &lt;code&gt;finalize()&lt;/code&gt; implementations with an empty method body or a body
    containing only &lt;code&gt;if&lt;/code&gt; statements that have a condition which evaluates
    to &lt;code&gt;false&lt;/code&gt; and is a compile-time constant. For performance reasons it
    can be beneficial to override a non-trivial &lt;code&gt;finalize()&lt;/code&gt; with an empty
    implementation in a subclass. An empty final &lt;code&gt;finalize()&lt;/code&gt; implementation
    can also be used to prevent subclasses from overriding.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NoExplicitFinalizeCalls" defaultSeverity="WARNING" displayName="'finalize()' called explicitly" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Object.finalize()&lt;/code&gt;.
&lt;p&gt;Calling &lt;code&gt;Object.finalize()&lt;/code&gt; explicitly may result in objects being placed in an
inconsistent state.
  The garbage collector automatically calls this method on an object when it determines that there are no references to this object.&lt;/p&gt;
&lt;p&gt;The inspection doesn't report calls to &lt;code&gt;super.finalize()&lt;/code&gt; from within implementations of &lt;code&gt;finalize()&lt;/code&gt; as
  they're benign.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  MyObject m = new MyObject();
  m.finalize();
  System.gc()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 8" path="Java/Java language level migration aids"><inspection shortName="Java8MapForEach" defaultSeverity="WARNING" displayName="Map.forEach() can be used" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Suggests replacing &lt;code&gt;for(Entry&amp;lt;?,?&amp;gt; entry : map.entrySet()) {...}&lt;/code&gt; or
&lt;code&gt;map.entrySet().forEach(entry -&amp;gt; ...)&lt;/code&gt; with &lt;code&gt;map.forEach((key, value) -&gt; ...)&lt;/code&gt;.
&lt;p&gt;Example&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Map&amp;lt;String, Integer&amp;gt; map) {
    map.entrySet().forEach(entry -&gt; {
      String str = entry.getKey();
      System.out.println(str + ":" + entry.getValue());
    });
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Map&amp;lt;String, Integer&amp;gt; map) {
    map.forEach((str, value) -&gt; System.out.println(str + ":" + value));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  When the &lt;b&gt;Do not report loops&lt;/b&gt; option is enabled, only &lt;code&gt;entrySet().forEach()&lt;/code&gt; cases will be reported.
  However, the quick-fix action will be available for &lt;code&gt;for&lt;/code&gt;-loops as well.
&lt;/p&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2017.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Convert2streamapi" defaultSeverity="INFORMATION" displayName="Loop can be collapsed with Stream API" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports loops which can be replaced with stream API calls using lambda expressions.
&lt;p&gt;Such a replacement changes the style from imperative to more functional and makes the code more compact.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; check(List&amp;lt;String&gt; data) {
    &lt;b&gt;for&lt;/b&gt; (String e : data) {
      String trimmed = e.trim();
      &lt;b&gt;if&lt;/b&gt; (!trimmed.startsWith("xyz")) {
        &lt;b&gt;return&lt;/b&gt; false;
      }
    }
    return true;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; check(List&amp;lt;String&gt; data) {
    &lt;b&gt;return&lt;/b&gt; data.stream().map(String::trim).allMatch(trimmed -&gt; trimmed.startsWith("xyz"));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparatorCombinators" defaultSeverity="WARNING" displayName="'Comparator' combinator can be used" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Comparator&lt;/code&gt; instances defined as lambda expressions that could be expressed using
 &lt;code&gt;Comparator.comparing()&lt;/code&gt; calls.
Chained comparisons which can be replaced by &lt;code&gt;Comparator.thenComparing()&lt;/code&gt; expression are also reported.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  myList.sort((person1, person2) -&gt; person1.getName().compareTo(person2.getName()));

  myList2.sort((person1, person2) -&gt; {
      int res = person1.first().compareTo(person2.first());
      if(res == 0) res = person1.second().compareTo(person2.second());
      if(res == 0) res = person1.third() - person2.third();
      return res;
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fixes are applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  myList.sort(Comparator.comparing(Person::getName));

  myList2.sort(Comparator.comparing(Person::first)
                         .thenComparing(Person::second)
                         .thenComparingInt(Person::third));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Convert2MethodRef" defaultSeverity="WARNING" displayName="Lambda can be replaced with method reference" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports lambdas that can be replaced with method references. While often it could be a matter of taste, method references are more clear
and readable compared to lambdas.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Runnable r = () -&gt; System.out.println();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Runnable r = System.out::println;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  The inspection may suggest method references even if a lambda doesn't call any method, like replacing &lt;code&gt;obj -&gt; obj != null&lt;/code&gt;
  with &lt;code&gt;Objects::nonNull&lt;/code&gt;. 
  Use the &lt;a href="settings://preferences.sourceCode.Java?Lambda%20Body"&gt;Settings | Editor | Code Style | Java | Code Generation&lt;/a&gt;
  settings to configure special method references.
&lt;/p&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LambdaCanBeMethodCall" defaultSeverity="INFORMATION" displayName="Lambda can be replaced with method call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports lambda expressions which can be replaced with a JDK method call.
&lt;p&gt;For example, the expression &lt;code&gt;x -&amp;gt; x&lt;/code&gt; of the &lt;code&gt;Function&amp;lt;T, T&amp;gt;&lt;/code&gt; type
  can be replaced with the &lt;code&gt;Function.identity()&lt;/code&gt; call.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticPseudoFunctionalStyleMethod" defaultSeverity="WARNING" displayName="Pseudo-functional expression using static class" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of pseudo-functional code if &lt;code&gt;Java Stream API&lt;/code&gt; is available.
&lt;p&gt;Though &lt;code&gt;guava Iterable API&lt;/code&gt; provides functionality similar to &lt;code&gt;Java Streams API&lt;/code&gt;, it's slightly different and
  may miss some features.
  Especially, primitive-specialized stream variants like &lt;code&gt;IntStream&lt;/code&gt; are more performant than generic variants.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
List&amp;lt;String&amp;gt; transformedIterable = Iterables.transform(someList, someTransformFunction);//warning: Pseudo functional style code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; transformedIterable = someList.stream().map(someTransformFunction).collect(Collectors.toList());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;b&gt;Note:&lt;/b&gt; Code semantics can be changed; for example, guava's &lt;code&gt;Iterable.transform&lt;/code&gt; produces a lazy-evaluated iterable,
  but the replacement is eager-evaluated.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Static method calls translated to the 'Stream' API&lt;/b&gt; option
  to configure static method calls that should be translated to the &lt;code&gt;stream&lt;/code&gt; API.
&lt;/p&gt;

&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FoldExpressionIntoStream" defaultSeverity="INFORMATION" displayName="Expression can be folded into Stream chain" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports expressions with a repeating pattern which could be replaced with &lt;i&gt;Stream API&lt;/i&gt; or &lt;code&gt;String.join()&lt;/code&gt;.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean allStartWith(String a, String b, String c, String d, String prefix) {
    return a.startsWith(prefix) &amp;&amp; b.startsWith(prefix) &amp;&amp; c.startsWith(prefix) &amp;&amp; d.startsWith(prefix);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean foo(String a, String b, String c, String d, String prefix) {
    return Stream.of(a, b, c, d).allMatch(s -&gt; s.startsWith(prefix));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String joinAll(String a, String b, String c, String d) {
    return a + "," + b + "," + c + "," + d;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String joinAll(String a, String b, String c, String d) {
    return String.join(",", a, b, c, d);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2018.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyForEach" defaultSeverity="INFORMATION" displayName="Simplifiable forEach() call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;forEach()&lt;/code&gt; calls that can be replaced with a more concise method or from which intermediate steps can be extracted.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; findNStrings(List&amp;lt;String&amp;gt; list, int n) {
    List&amp;lt;String&amp;gt; other = new ArrayList&amp;lt;&gt;();
    list.forEach(s -&gt; {
      if(s.length() &gt; n) other.add(s);
    });
    return other;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; findNStrings(List&amp;lt;String&amp;gt; list, int n) {
    List&amp;lt;String&amp;gt; other = list.stream()
      .filter(s -&gt; s.length() &gt; n)
      .collect(Collectors.toList());
    return other;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2017.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousHasLambdaAlternative" defaultSeverity="WARNING" displayName="Anonymous type has shorter lambda alternative" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports anonymous classes which could be transformed to a constructor or a factory method call with a lambda expression argument.
&lt;p&gt;The following classes are reported by this inspection:
&lt;ul&gt;
  &lt;li&gt;Anonymous classes extending &lt;code&gt;ThreadLocal&lt;/code&gt; which have an &lt;code&gt;initialValue()&lt;/code&gt; method (can be replaced with &lt;code&gt;ThreadLocal.withInitial&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Anonymous classes extending &lt;code&gt;Thread&lt;/code&gt; which have a &lt;code&gt;run()&lt;/code&gt; method (can be replaced with &lt;code&gt;new Thread(Runnable)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;new&lt;/b&gt; Thread() {
    @Override
    &lt;b&gt;public void&lt;/b&gt; run() {
      System.out.println("Hello from thread!");
    }
  }.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;new&lt;/b&gt; Thread(() -&gt; {
    System.out.println("Hello from thread!");
  }).start();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java8CollectionRemoveIf" defaultSeverity="WARNING" displayName="Loop can be replaced with 'Collection.removeIf()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports loops which can be collapsed into a single &lt;code&gt;Collection.removeIf&lt;/code&gt; call.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Iterator&amp;lt;String&amp;gt; it = collection.iterator(); it.hasNext(); ) {
    String aValue = it.next();
    if(shouldBeRemoved(aValue)) {
      it.remove();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  collection.removeIf(aValue -&gt; shouldBeRemoved(aValue));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  This inspection only reports if the language level of the project or module is 8 or higher.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java8ListReplaceAll" defaultSeverity="WARNING" displayName="Loop can be replaced with 'List.replaceAll()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports loops which can be collapsed into a single &lt;code&gt;List.replaceAll()&lt;/code&gt; call.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i = 0; i &amp;lt; strings.size(); i++) {
    String str = strings.get(i).toLowerCase();
    strings.set(i, str);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  strings.replaceAll(String::toLowerCase);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  This inspection only reports if the language level of the project or module is 8 or higher.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2022.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Guava" defaultSeverity="WARNING" displayName="Guava's functional primitives can be replaced with Java" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of Guava's functional primitives that can be migrated to standard Java API calls.
&lt;p&gt;For example, the inspection reports usages of classes and interfaces like &lt;code&gt;FluentIterable&lt;/code&gt;, &lt;code&gt;Optional&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;,
  &lt;code&gt;Predicate&lt;/code&gt;, or &lt;code&gt;Supplier&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ImmutableList&amp;lt;String&amp;gt; results = FluentIterable.from(List.of(1, 2, 3)).transform(Object::toString).toList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; results = List.of(1, 2, 3).stream().map(Object::toString).collect(Collectors.toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
The quick-fix may change the semantics. Some lazy-evaluated Guava's iterables can be transformed to eager-evaluated.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Anonymous2MethodRef" defaultSeverity="WARNING" displayName="Anonymous type can be replaced with method reference" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports anonymous classes which can be replaced with method references.
&lt;p&gt;
  Note that if an anonymous class is converted into an unbound method reference, the same method reference object 
  can be reused by the Java runtime during subsequent invocations. On the other hand, when an anonymous class is used,
  separate objects are created every time. Thus, applying the quick-fix can cause the semantics change in rare cases, 
  e.g. when anonymous class instances are used as &lt;code&gt;HashMap&lt;/code&gt; keys.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    Runnable r = new Runnable() {
      @Override
      public void run() {
        System.out.println();
      }
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix changes this code to the compact form: &lt;code&gt;Runnable r = System.out::println;&lt;/code&gt;.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Report when interface is not annotated with @FunctionalInterface&lt;/b&gt; option to enable this inspection for
  interfaces which are not annotated with @FunctionalInterface.&lt;/p&gt;

&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Convert2Lambda" defaultSeverity="WARNING" displayName="Anonymous type can be replaced with lambda" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports anonymous classes which can be replaced with lambda expressions.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Thread(new Runnable() {
    @Override
    public void run() {
      // run thread
    }
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Thread(() -&gt; {
    // run thread
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
Note that if an anonymous class is converted into a stateless lambda, the same lambda object
can be reused by Java runtime during subsequent invocations. On the other hand, when an anonymous class is used,
separate objects are created every time. Thus, applying the quick-fix can cause the semantics change in rare cases,
e.g. when anonymous class instances are used as &lt;code&gt;HashMap&lt;/code&gt; keys.
&lt;/p&gt;
&lt;p&gt;Lambda syntax is not supported in Java 1.7 and earlier JVMs.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Report when interface is not annotated with @FunctionalInterface &lt;/b&gt; option to ignore the cases in which an anonymous
class implements an interface without &lt;code&gt;@FunctionalInterface&lt;/code&gt; annotation.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="Java8MapApi" defaultSeverity="WARNING" displayName="Simplifiable 'Map' operations" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports common usage patterns of &lt;code&gt;java.util.Map&lt;/code&gt; and suggests replacing them with:
&lt;code&gt;getOrDefault()&lt;/code&gt;, &lt;code&gt;computeIfAbsent()&lt;/code&gt;, &lt;code&gt;putIfAbsent()&lt;/code&gt;, &lt;code&gt;merge()&lt;/code&gt;, or &lt;code&gt;replaceAll()&lt;/code&gt;.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.containsKey(key) ? map.get(key) : "default";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.getOrDefault(key, "default");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = map.get(key);
  if (list == null) {
    list = new ArrayList&amp;lt;&amp;gt;();
    map.put(key, list);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.computeIfAbsent(key, localKey -&gt; new ArrayList&amp;lt;&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer val = map.get(key);
  if (val == null) map.put(key, 1);
  else map.put(key, val + 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.merge(key, 1, (localKey, localValue) -&gt; localValue + 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Map.Entry&amp;lt;String, String&amp;gt; entry : map.entrySet()) {
    map.put(entry.getKey(), transform(entry.getValue()));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.replaceAll((localKey, localValue) -&gt; transform(localValue));
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;Note that the replacement with &lt;code&gt;computeIfAbsent()&lt;/code&gt; or &lt;code&gt;merge()&lt;/code&gt; might work incorrectly for some &lt;code&gt;Map&lt;/code&gt;
  implementations if the code extracted to the lambda expression modifies the same &lt;code&gt;Map&lt;/code&gt;. By default,
  the warning doesn't appear if this code might have side effects. If necessary, enable the
  &lt;b&gt;Suggest replacement even if lambda may have side effects&lt;/b&gt; option to always show the warning.&lt;/p&gt;
&lt;p&gt;Also, due to different handling of the &lt;code&gt;null&lt;/code&gt; value in old methods like &lt;code&gt;put()&lt;/code&gt; and newer methods like
  &lt;code&gt;computeIfAbsent()&lt;/code&gt; or &lt;code&gt;merge()&lt;/code&gt;, semantics might change if storing the &lt;code&gt;null&lt;/code&gt; value into given
  &lt;code&gt;Map&lt;/code&gt; is important. The inspection won't suggest the replacement when the value is statically known to be nullable,
  but for values with unknown nullability the replacement is still suggested. In these cases, we recommended suppressing the warning
  and adding an explanatory comment.
&lt;/p&gt;
&lt;p&gt;This inspection works only if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CodeBlock2Expr" defaultSeverity="WARNING" displayName="Statement lambda can be replaced with expression lambda" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports lambda expressions with code block bodies when expression-style bodies can be used instead.
The result of the conversion is shorter and more clear.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Comparable&amp;lt;String&amp;gt; c = o -&gt; {return 0;};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Comparable&amp;lt;String&amp;gt; c = o -&gt; 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java8ListSort" defaultSeverity="WARNING" displayName="'Collections.sort()' can be replaced with 'List.sort()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls of &lt;code&gt;Collections.sort(list, comparator)&lt;/code&gt; which can be replaced with &lt;code&gt;list.sort(comparator)&lt;/code&gt;.
&lt;p&gt;&lt;code&gt;Collections.sort&lt;/code&gt; is just a wrapper, so it is better to use an instance method directly.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Assignment issues" path="Groovy"><inspection shortName="GroovyAssignabilityCheck" defaultSeverity="WARNING" displayName="Incompatible type assignments" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignments with incompatible types.
&lt;p&gt;Such assignments might result in various runtime exceptions.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {}
  class B {}

  // incompatible assignment
  A a = new B()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyResultOfAssignmentUsed" defaultSeverity="WARNING" displayName="Result of assignment used" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignment expressions nested inside other expressions to use the assigned value immediately.
&lt;p&gt;
  Such expressions may be confusing and violating the general design principle that a
  given construct should do precisely one thing.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUncheckedAssignmentOfMemberOfRawType" defaultSeverity="WARNING" displayName="Unchecked assignment from members of raw type" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports unchecked assignments from members of raw type.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List list = new ArrayList()
  List&amp;ltString&amp;gt a = &lt;b&gt;list.get(0)&lt;/b&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAssignmentToMethodParameter" defaultSeverity="WARNING" displayName="Assignment to method parameter" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignment to method parameters.
&lt;p&gt;While occasionally intended, this construct can be extremely confusing, and is often the result of a typo.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def m(a, b, c) {
      a = [] // warning
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNestedAssignment" defaultSeverity="WARNING" displayName="Nested assignment" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignment expressions nested inside other expressions.
While admirably terse, such expressions may be confusing, and violate the general design principle that a given construct
should do precisely one thing.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
a = b = 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAssignmentToForLoopParameter" defaultSeverity="WARNING" displayName="Assignment to 'for' loop parameter" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignments to &lt;b&gt;for&lt;/b&gt; loop parameters inside the &lt;b&gt;for&lt;/b&gt; loop body.
&lt;p&gt;While occasionally intended, this construct can be extremely confusing, and is often the result of a typo.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (value in [1, 2, 3]) {
      value = 4 // warning
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAssignmentCanBeOperatorAssignment" defaultSeverity="INFORMATION" displayName="Assignment can be replaced with operator assignment" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignments which can be replaced by an operator assignment.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a = a + b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a += b
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore conditional operators&lt;/b&gt; option to ignore &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore obscure operators&lt;/b&gt; option to ignore &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; operators.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovySillyAssignment" defaultSeverity="WARNING" displayName="Silly assignment" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignments of a variable to itself.
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Kotlin Android" path=""><inspection shortName="IllegalIdentifier" defaultSeverity="ERROR" displayName="Illegal Android Identifier" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Android projects identifiers that are not accepted by the Android runtime.
For example, method names with whitespaces.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
      var `a b c` = 3
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix the problem change the identifier's name to match the Android runtime requirements.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TypeParameterFindViewById" defaultSeverity="WEAK WARNING" displayName="Cast can be converted to findViewById with type parameter" enabled="true" language="kotlin" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;findViewById&lt;/code&gt; calls with type casts that can be converted to &lt;code&gt;findViewById&lt;/code&gt; with a type parameter from Android 8.0 (API level 26).
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="toString() issues" path="Java"><inspection shortName="ClassHasNoToStringMethod" defaultSeverity="WARNING" displayName="Class does not override 'toString()' method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes without a &lt;code&gt;toString()&lt;/code&gt; method.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldNotUsedInToString" defaultSeverity="WARNING" displayName="Field not used in 'toString()' method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any fields that are not used in the &lt;code&gt;toString()&lt;/code&gt; method of a class.
&lt;p&gt;This inspection can help discover the
fields that were added after the &lt;code&gt;toString()&lt;/code&gt; method was created and for which the &lt;code&gt;toString()&lt;/code&gt; method was not
  updated. The quick-fix regenerates the &lt;code&gt;toString()&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;
In the &lt;b&gt;Generate | toString()&lt;/b&gt; dialog, it is possible to exclude fields from this check.
This inspection will also check for problems with getter methods if the &lt;em&gt;Enable getters in code generation&lt;/em&gt; option is enabled there.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Relevant {
    &lt;b&gt;private&lt;/b&gt; String name; // not used in toString()
    &lt;b&gt;private int&lt;/b&gt; index;
    &lt;b&gt;private int&lt;/b&gt; length;

    @Override
    &lt;b&gt;public&lt;/b&gt; String toString() {
        &lt;b&gt;return&lt;/b&gt; "Relevant{" + "index=" + index +
          ", length=" + length + '}';
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Relevant {
    &lt;b&gt;private&lt;/b&gt; String name;
    &lt;b&gt;private int&lt;/b&gt; index;
    &lt;b&gt;private int&lt;/b&gt; length;

    @Override
    &lt;b&gt;public&lt;/b&gt; String toString() {
        &lt;b&gt;return&lt;/b&gt; "Relevant{" + "name='" + name + '\'' +
          ", index=" + index + ", length=" + length + '}';
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 10" path="Java/Java language level migration aids"><inspection shortName="RedundantExplicitVariableType" defaultSeverity="INFORMATION" displayName="Local variable type can be omitted" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant local variable types.
&lt;p&gt;These types can be inferred from the context and thus replaced with &lt;code&gt;var&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(InputStream s) {
    try (InputStream in = s) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(InputStream s) {
    try (var in = s) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VariableTypeCanBeExplicit" defaultSeverity="INFORMATION" displayName="Variable type can be explicit" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local variables of the &lt;code&gt;var&lt;/code&gt; type that can be replaced withvan explicit type.
&lt;p&gt;The inspection can help find and eliminate usages of implicit types in case of downgrading.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var str = "Hello";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String str = "Hello";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 10 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Logging" path="Kotlin"><inspection shortName="KotlinLoggerInitializedWithForeignClass" defaultSeverity="WARNING" displayName="Logger initialized with foreign class" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Logger&lt;/code&gt; instances initialized with a class literal other than the class the &lt;code&gt;Logger&lt;/code&gt;
resides in.
&lt;p&gt;
    This can happen when copy-pasting from another class.
    It may result in logging events under an unexpected category and incorrect filtering.
&lt;/p&gt;
&lt;p&gt;
    Use the inspection options to specify the logger factory classes and methods recognized by this inspection.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class AnotherService
class MyService {
    private val logger = LoggerFactory.getLogger(AnotherService::class.java)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class MyService {
    private val logger = LoggerFactory.getLogger(MyService::class.java)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinPlaceholderCountMatchesArgumentCount" defaultSeverity="WARNING" displayName="Number of placeholders does not match number of arguments in logging call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports SLF4J or Log4j 2 logging calls, such as &lt;code&gt;logger.info("{}: {}", key)&lt;/code&gt; where the number of &lt;code&gt;{}&lt;/code&gt; placeholders
in the logger message doesn't match the number of other arguments to the logging call.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Style" path="Groovy"><inspection shortName="GrUnnecessarySealedModifier" defaultSeverity="WARNING" displayName="Unnecessary 'sealed' modifier" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports unnecessary &lt;code&gt;sealed&lt;/code&gt; modifiers which used on methods, fields, or variables.&lt;/p&gt;
&lt;p&gt;This modifier has effect only on classes, interfaces and traits.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;sealed&lt;/b&gt; boolean foo() {} // modifier is unnecessary
  &lt;b&gt;sealed&lt;/b&gt; Object bar // modifier is unnecessary

  // modifier is required and therefore not highlighted
  &lt;b&gt;sealed&lt;/b&gt; class A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaStylePropertiesInvocation" defaultSeverity="INFORMATION" displayName="Java-style property access" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports properties accessed via method calls.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      int foo
  }

  def bar = new Foo()
  print(&lt;b&gt;bar.getFoo()&lt;/b&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      int foo
  }

  def bar = new Foo()
  print(&lt;b&gt;bar.foo&lt;/b&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ChangeToMethod" defaultSeverity="INFORMATION" displayName="Operator invocation can be replaced with method call" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports operator invocations that can be replaced with method calls.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a + b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a.plus(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessaryPublicModifier" defaultSeverity="WARNING" displayName="Unnecessary 'public'" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports unnecessary &lt;code&gt;public&lt;/code&gt; modifiers as Groovy classes and methods are &lt;code&gt;public&lt;/code&gt; by default.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo{
      public void bar(){
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo{
      void bar(){
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrStringStyleViolation" defaultSeverity="WEAK WARNING" displayName="String style violation" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports strings with quotation that doesn't match code style.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def hw = "Hello, world!"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def hw = 'Hello, world!'
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the fields provided below to specify code style for different kinds of strings.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyConditional" defaultSeverity="WARNING" displayName="Ternary expression" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports ternary expressions.
&lt;p&gt;Some coding standards prohibit the use of the condition operator in favor of &lt;code&gt;if&lt;/code&gt; statements.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessaryNonSealedModifier" defaultSeverity="WARNING" displayName="Unnecessary 'non-sealed' modifier" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports unnecessary &lt;code&gt;non-sealed&lt;/code&gt; modifiers which used on methods, fields, or variables.&lt;/p&gt;
&lt;p&gt;This modifier has effect only on classes, interfaces and traits.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;non-sealed&lt;/b&gt; boolean foo() {} // modifier is unnecessary
  &lt;b&gt;non-sealed&lt;/b&gt; Object bar // modifier is unnecessary

  // modifier is required and therefore not highlighted
  &lt;b&gt;non-sealed&lt;/b&gt; class A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessaryAlias" defaultSeverity="WEAK WARNING" displayName="Unnecessary import alias" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports unnecessary import aliases.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import com.foo.Bar as Bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import com.foo.Bar
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessarySemicolon" defaultSeverity="WARNING" displayName="Unnecessary semicolon" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports unnecessary semicolons.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  print 2; print 3 // semicolon is required
  print 2; // semicolon is unnecessary
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessaryFinalModifier" defaultSeverity="WARNING" displayName="Unnecessary 'final'" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports unnecessary &lt;code&gt;final&lt;/code&gt; modifiers when used with the record definition.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;final&lt;/b&gt; record R(int a) {} // modifier is unnecessary
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnnecessaryDefModifier" defaultSeverity="WARNING" displayName="Unnecessary 'def'" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports unnecessary &lt;code&gt;def&lt;/code&gt; modifiers when used with explicit type declaration.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;def&lt;/b&gt; boolean foo() {} // modifier is unnecessary
  &lt;b&gt;def&lt;/b&gt; Object bar // modifier is unnecessary

  // modifier is required and therefore not highlighted
  &lt;b&gt;def&lt;/b&gt; (int a, String b) = []
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ChangeToOperator" defaultSeverity="WEAK WARNING" displayName="Method call can be replaced with operator invocation" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method calls that can be replaced with operator invocations.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a.plus(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a + b
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="General" path="Objective-C"><inspection shortName="BridgeCastIssues" defaultSeverity="WARNING" displayName="Bridge cast issues" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the incorrect usages of the bridge casts.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnavailableInDeploymentTarget" defaultSeverity="WARNING" displayName="Using unavailable API" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the API usage not available for the deployment target.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OCNotReleasedIvar" defaultSeverity="WARNING" displayName="Not released ivar" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the owned objects stored in the instance variables that are not released.&lt;br&gt;
You take ownership of an object if you:&lt;br&gt;
- create it using a method which name begins with &lt;code&gt;alloc&lt;/code&gt; or &lt;code&gt;new&lt;/code&gt; or contains &lt;code&gt;copy&lt;/code&gt;&lt;br&gt;
- send it a &lt;code&gt;retain&lt;/code&gt; message&lt;br&gt;
- set the value of the property that has the &lt;code&gt;retain&lt;/code&gt; or &lt;code&gt;copy&lt;/code&gt; attribute and is synthesized with the instance variable&lt;br&gt;
To relinquish ownership of an object, you:&lt;br&gt;
- send it a &lt;code&gt;release&lt;/code&gt; or &lt;code&gt;autorelease&lt;/code&gt; message&lt;br&gt;
- assign &lt;code&gt;nil&lt;/code&gt; to the property that is synthesized with the instance variable&lt;br&gt;
If ARC (Automatic Reference Counting) is on, this inspection is disabled. If the checkbox below is switched off, you may release the instance
variables in any method of the class. If it's switched on, you may release them in the &lt;code&gt;dealloc&lt;/code&gt;, &lt;code&gt;tearDown&lt;/code&gt;, &lt;code&gt;applicationWillTerminate:&lt;/code&gt;,
&lt;code&gt;didTurnIntoFault&lt;/code&gt; methods and in any method that can be called from them.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringLocalization" defaultSeverity="WARNING" displayName="String localization" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the strings used in &lt;code&gt;NSLocalizedString&lt;/code&gt; that weren't defined in the corresponding &lt;b&gt;.strings&lt;/b&gt; file.&lt;br&gt;
If the string was defined for some localizations and not defined for other ones, this inspection will also be triggered.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallDealloc" defaultSeverity="WARNING" displayName="'dealloc' sent directly" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the &lt;code&gt;dealloc&lt;/code&gt; messages sent directly. Such messages should never be sent directly.
  Instead, an object's &lt;code&gt;dealloc&lt;/code&gt; method is invoked indirectly through the &lt;code&gt;release
  NSObject&lt;/code&gt; protocol method (if the &lt;code&gt;release&lt;/code&gt; message results in the receiver's retain count becoming 0).
  See &lt;a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/MemoryMgmt/Articles/MemoryMgmt.html"&gt;Memory Management Programming Guide&lt;/a&gt;
  for more details on the use of these methods.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UsingZeroAsNil" defaultSeverity="WARNING" displayName="Using zero as nil" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the cases when &lt;code&gt;0&lt;/code&gt; is used instead of &lt;code&gt;nil&lt;/code&gt;. 
In some cases, it might be a problem, for example, when &lt;code&gt;0&lt;/code&gt; is stored
in an array. You might have wanted to store &lt;code&gt;NSNumber&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt; instead of &lt;code&gt;nil&lt;/code&gt;.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OCNotLocalizedString" defaultSeverity="WARNING" displayName="Non-localized string" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the non-localized strings in the project.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OtherObjC" defaultSeverity="WARNING" displayName="Other obj c" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports other problems related to Objective-C.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OCLegacyObjCLiteral" defaultSeverity="WARNING" displayName="Modern syntax can be used" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports old-style code: collection literals, collection accessor usages,
and the &lt;code&gt;NSNumber&lt;/code&gt; literals.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  NSString *myString = [myArray objectAtIndex:1];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  NSString *myString = myArray[1];
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NotImplementsProtocol" defaultSeverity="WARNING" displayName="Not implemented protocol" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the cases when an expression of type A is used in the context of type B (assigned, cast, passed as parameter, returned from a
  method, function, or block, and so on) under the condition that A and B are class types, and B does not conform to a protocol to which A conforms.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitDeclarationOfIvar" defaultSeverity="WARNING" displayName="Implicit declaration of ivar" enabled="false" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the &lt;a href="http://en.wikipedia.org/wiki/Objective-C#Non-fragile_instance_variables"&gt;&amp;quot;non-fragile&amp;quot; instance variables&lt;/a&gt;,
  which are the instance variables that provide backing for the properties to be synthesized at runtime without declaring them in the class's interface.
  Although this is a correct way to declare instance variables, you may forget to declare them explicitly. Because the "non-fragile"
  instance variables are implemented with an extra layer of indirection, they may lead to undesirable runtime overhead.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ARCIssues" defaultSeverity="WARNING" displayName="ARC Issues" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the code invalid in ARC mode.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KeyValueCoding" defaultSeverity="WARNING" displayName="Key value coding" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the attempts to access the object key paths that are possibly not defined,
which typically causes exceptions at runtime.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NotReleasedValue" defaultSeverity="WARNING" displayName="Not released value" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the owned objects stored in the local variables or parameters that are not released later or are overwritten by another value before they are released.&lt;br&gt;
&amp;nbsp;- You take ownership of an object if you create it using a method which name begins with &lt;code&gt;alloc&lt;/code&gt; or
&lt;code&gt;new&lt;/code&gt; or contains &lt;code&gt;copy&lt;/code&gt;, or if you send it a &lt;code&gt;retain&lt;/code&gt; message.&lt;br&gt;
&amp;nbsp;- You use &lt;code&gt;release&lt;/code&gt; or &lt;code&gt;autorelease&lt;/code&gt; to relinquish ownership of an object.&lt;br&gt;
Objective-C memory management rules require each owned object to be released or autoreleased, see
&lt;a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html"&gt;Memory Management Programming Guide&lt;/a&gt;.&lt;br&gt;
If ARC (Automatic Reference Counting) is on, this inspection is disabled.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualityInConditionalOperatorWithSelf" defaultSeverity="WARNING" displayName="'=' in conditional expression with 'self'" enabled="false" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Detects the conditional expressions with the &lt;code&gt;=&lt;/code&gt; operator on the top level and &lt;code&gt;self&lt;/code&gt; on the left side.
The inspection for common patterns like &lt;code&gt;if(self = [super init])&lt;/code&gt; can be turned off leaving other &lt;code&gt;=&lt;/code&gt; usages in
conditional operators highlighted.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Probable bugs" path="Gradle"><inspection shortName="BintrayPublishingPlugin" defaultSeverity="WARNING" displayName="Bintray publishing plugin may stop working on May 1st, 2021" enabled="true" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;                                            
&lt;p&gt;Detects usages of Gradle plugin &lt;code&gt;com.jfrog.bintray&lt;/code&gt;.
  The plugin is used for publishing build results to Bintray.
  Publishing to
  &lt;a href="https://www.jfrog.com/confluence/display/BT/Welcome+to+JFrog+Bintray"&gt;Bintray&lt;/a&gt; service is disabled.
  &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JCenterRepository" defaultSeverity="WARNING" displayName="Builds will no longer be able to resolve artifacts from JCenter after February 1st, 2022" enabled="true" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Detects usages of the JCenter repository to resolve dependencies.
Builds will no longer be able to resolve artifacts from JCenter after February 1st, 2022.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleRepositoryUrls" defaultSeverity="WARNING" displayName="Multiple repository urls" enabled="true" language="Groovy" pluginId="org.jetbrains.plugins.gradle" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the usage of multiple URLs per repository (maven or ivy) block.
The problem is that only one URL can be picked up for the repository, the other URLs will be ignored.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Manifest" path=""><inspection shortName="MisspelledHeader" defaultSeverity="WEAK WARNING" displayName="Unknown or misspelled header name" enabled="true" language="Manifest" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports any unknown and probably misspelled header names and provides possible variants.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingFinalNewline" defaultSeverity="ERROR" displayName="Missing final new line" enabled="true" language="Manifest" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports if manifest files do not end with a final newline as required by the JAR file specification.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java interop issues" path="Kotlin"><inspection shortName="JavaCollectionsStaticMethodOnImmutableList" defaultSeverity="WARNING" displayName="Call of Java mutator method on immutable Kotlin collection" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Java mutator methods calls (like &lt;code&gt;fill&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt;, &lt;code&gt;shuffle&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;) on an immutable Kotlin collection.
&lt;p&gt;This can lead to &lt;code&gt;UnsupportedOperationException&lt;/code&gt; at runtime.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.Collections

  fun test() {
      val immutableList = listOf(1, 2)
      Collections.reverse(immutableList)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix the problem make the list mutable.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinInternalInJava" defaultSeverity="ERROR" displayName="Usage of Kotlin internal declarations from Java" enabled="true" language="JAVA" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of Kotlin &lt;code&gt;internal&lt;/code&gt; declarations in Java code that is located in a different module.
&lt;p&gt;
    The &lt;code&gt;internal&lt;/code&gt; keyword is designed to restrict access to a class, function, or property from other modules.
    Due to JVM limitations, &lt;code&gt;internal&lt;/code&gt; classes, functions, and properties can still be
    accessed from outside Kotlin, which may later lead to compatibility problems.
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinSealedInheritorsInJava" defaultSeverity="ERROR" displayName="Inheritance of Kotlin sealed interface/class from Java" enabled="true" language="JAVA" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports attempts to inherit from Kotlin sealed interfaces or classes in Java code.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
// Kotlin file: MathExpression.kt

sealed class MathExpression

data class Const(val number: Double) : MathExpression()
data class Sum(val e1: MathExpression, val e2: MathExpression) : MathExpression()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
// Java file: NotANumber.java

public class NotANumber extends MathExpression {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantNotNullExtensionReceiverOfInline" defaultSeverity="INFORMATION" displayName="'inline fun' extension receiver can be explicitly nullable until Kotlin 1.2" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports inline functions with non-nullable extension receivers which don't use the fact that extension receiver is not nullable.&lt;/p&gt;
&lt;p&gt;
    Before Kotlin 1.2, calls of &lt;code&gt;inline fun&lt;/code&gt; with flexible nullable extension receiver (a platform type with an unknown
    nullability) did not include nullability checks in bytecode. Since Kotlin 1.2, nullability checks are included into the bytecode
    (see &lt;a href="https://youtrack.jetbrains.com/issue/KT-12899"&gt;KT-12899&lt;/a&gt;).
&lt;/p&gt;
&lt;p&gt;
    Thus functions which do not use the fact that extension receiver is not nullable are dangerous in Kotlin until 1.2 and it's
    recommended to make such functions to have nullable receiver.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  inline fun String.greet() {
      println("Hello, $this!")
  }

  fun main() {
      // `System.getProperty` returns not denotable `String!` type
      val user = System.getProperty("user.name")
      user.greet()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  inline fun String.greet() {
      println("Hello, $this!")
  }

  fun main() {
      // `System.getProperty` returns not denotable `String!` type
      val user = System.getProperty("user.name")
      user.greet()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the Kotlin language level of the project or module is lower than 1.2.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PackageDirectoryMismatch" defaultSeverity="INFO" displayName="Package name does not match containing directory" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;package&lt;/code&gt; directives that do not match the location of the file.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FakeJvmFieldConstant" defaultSeverity="WARNING" displayName="Kotlin non-const property used as Java constant" enabled="true" language="JAVA" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Kotlin properties that are not &lt;code&gt;const&lt;/code&gt; and used as Java annotation arguments.
&lt;p&gt;
For example, a property with the &lt;code&gt;@JvmField&lt;/code&gt; annotation has an initializer that can be evaluated at compile-time,
and it has a primitive or &lt;code&gt;String&lt;/code&gt; type.
&lt;/p&gt;

&lt;p&gt;
Such properties have a &lt;code&gt;ConstantValue&lt;/code&gt; attribute in bytecode in Kotlin 1.1-1.2.
This attribute allows javac to fold usages of the corresponding field and use that field in annotations.
This can lead to incorrect behavior in the case of separate or incremental compilation in mixed Java/Kotlin code.
This behavior is subject to change in Kotlin 1.3 (no &lt;code&gt;ConstantValue&lt;/code&gt; attribute any more).
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;Kotlin code in foo.kt file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  annotation class Ann(val s: String)
  @JvmField val importantString = "important"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Java code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class JavaUser {
      // This is dangerous
      @Ann(s = FooKt.importantString)
      public void foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix the problem replace the &lt;code&gt;@JvmField&lt;/code&gt; annotation with the &lt;code&gt;const&lt;/code&gt; modifier on a relevant Kotlin property or inline it.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PlatformExtensionReceiverOfInline" defaultSeverity="WARNING" displayName="'inline fun' with nullable receiver until Kotlin 1.2" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports potentially unsafe calls of inline functions with flexible nullable (platform type with unknown nullability) extension receivers.&lt;/p&gt;
&lt;p&gt;
    Before Kotlin 1.2, calls of &lt;code&gt;inline fun&lt;/code&gt; with flexible nullable extension receiver (a platform type with an unknown
    nullability) did not include nullability checks in bytecode. Since Kotlin 1.2, nullability checks are included into the bytecode
    (see &lt;a href="https://youtrack.jetbrains.com/issue/KT-12899"&gt;KT-12899&lt;/a&gt;).
&lt;/p&gt;
&lt;p&gt;
    It's recommended to add an explicit &lt;code&gt;!!&lt;/code&gt; you want an exception to be thrown,
    or consider changing the function's receiver type to nullable if it should work without exceptions.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  inline fun String.removePrefix(prefix: String): String {
      return this.substring(prefix.length)
  }

  fun main() {
      // `System.getProperty` returns not denotable `String!` type
      val property = System.getProperty("user.dir")
      println(property.removePrefix("/home"))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  inline fun String.removePrefix(prefix: String): String {
      return this.substring(prefix.length)
  }

  fun main() {
      // `System.getProperty` returns not denotable `String!` type
      val property = System.getProperty("user.dir")
      println(property!!.removePrefix("/home"))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the Kotlin language level of the project or module is lower than 1.2.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HasPlatformType" defaultSeverity="WEAK WARNING" displayName="Function or property has platform type" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports functions and properties that have a platform type.
&lt;p&gt;To prevent unexpected errors, the type should be declared explicitly.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() = java.lang.String.valueOf(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix allows you to specify the return type:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): String = java.lang.String.valueOf(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="JUnit" path="Java"><inspection shortName="UseOfObsoleteAssert" defaultSeverity="WARNING" displayName="Usage of obsolete 'junit.framework.Assert' method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any calls to methods from the &lt;code&gt;junit.framework.Assert&lt;/code&gt; class. This class is
obsolete and the calls can be replaced by calls to methods from the &lt;code&gt;org.junit.Assert&lt;/code&gt; class.
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;import&lt;/b&gt; org.junit.*;
  &lt;b&gt;public class&lt;/b&gt; NecessaryTest {
    @Test
    &lt;b&gt;public void&lt;/b&gt; testIt() {
      junit.framework.Assert.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick fix is applied, the result looks like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;import&lt;/b&gt; org.junit;
  &lt;b&gt;public class&lt;/b&gt; NecessaryTest {

    &lt;b&gt;public void&lt;/b&gt; testIt() {
      Assert.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnit5MalformedRepeated" defaultSeverity="WARNING" displayName="JUnit 5 malformed repeated test" enabled="true" language="JAVA" pluginId="JUnit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports the following problems with JUnit 5 &lt;code&gt;@RepeatedTest&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;@Test&lt;/code&gt; and &lt;code&gt;@RepeatedTest&lt;/code&gt; are used on the same method. Even though it is allowed to use them, they have no additional
    effect together.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;RepetitionInfo&lt;/code&gt; parameter is used in the &lt;code&gt;@BeforeAll&lt;/code&gt; and &lt;code&gt;@AfterAll&lt;/code&gt; methods. The parameter is
    not injected in these methods.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;RepetitionInfo&lt;/code&gt; parameter is used in the &lt;code&gt;@BeforeEach&lt;/code&gt; and &lt;code&gt;@AfterEach&lt;/code&gt; methods in classes
    with &lt;code&gt;@Test&lt;/code&gt;  methods. In this case, the parameter won't be injected in &lt;code&gt;@Test&lt;/code&gt; methods.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MalformedSetUpTearDown" defaultSeverity="WARNING" displayName="Malformed 'setUp()' or 'tearDown()' method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit 3 &lt;code&gt;setUp()&lt;/code&gt; or &lt;code&gt;tearDown()&lt;/code&gt; methods that either are not declared
&lt;code&gt;public&lt;/code&gt;, do not return &lt;code&gt;void&lt;/code&gt;, or take arguments.
Such &lt;code&gt;setUp()&lt;/code&gt; or &lt;code&gt;tearDown()&lt;/code&gt; methods are most likely created unintentionally,
and will not be executed by JUnit test runners.
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; WeightyTest &lt;b&gt;extends&lt;/b&gt; TestCase {
    &lt;b&gt;private&lt;/b&gt; File file;
    &lt;b&gt;private int&lt;/b&gt; setUp(String prefix) &lt;b&gt;throws&lt;/b&gt; IOException {
      file = File.createTempFile(prefix, ".tmp");
      &lt;b&gt;return&lt;/b&gt; 0;
    }

    // ... tests go here
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExpectedExceptionNeverThrown" defaultSeverity="WARNING" displayName="Expected exception never thrown in test method body" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports checked exceptions expected by a JUnit 4 test-method that are never thrown inside the method body.
Such test methods will never succeed.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test(expected = CloneNotSupportedException.class)
  &lt;b&gt;public void&lt;/b&gt; testIt() {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnit5MalformedExtensions" defaultSeverity="WARNING" displayName="JUnit 5 malformed extension registration" enabled="true" language="JVM" pluginId="JUnit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields annotated with &lt;code&gt;@RegisterExtension&lt;/code&gt; which have a wrong type or are not declared as static when it's required.
Such extensions won't be registered correctly and could lead to test startup failures.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class MyTest {
    @RegisterExtension
    private JUnit4Rule rule;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnitDatapoint" defaultSeverity="WARNING" displayName="Malformed '@DataPoint' field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields or methods annotated with &lt;code&gt;@DataPoint&lt;/code&gt; that are not &lt;code&gt;public&lt;/code&gt; and/or not &lt;code&gt;static&lt;/code&gt;.
A &lt;a href="https://github.com/junit-team/junit4/wiki/Theories"&gt;theories&lt;/a&gt; test class with a malformed &lt;code&gt;@DataPoint&lt;/code&gt; member
cannot be run.
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @RunWith(Theories.class)
  &lt;b&gt;public class&lt;/b&gt; SeriousTest {
    @DataPoint
    &lt;b&gt;private&lt;/b&gt; String dataPoint = "value";

    @DataPoint("generated")
    &lt;b&gt;private&lt;/b&gt; String generatedDataPoint() {
      &lt;b&gt;return&lt;/b&gt; "generated value";
    }

    @Theory
    &lt;b&gt;public void&lt;/b&gt; theoryMethod(String param) {
      // ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick fix is provided to fix the modifiers:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @RunWith(Theories.class)
  &lt;b&gt;public class&lt;/b&gt; SeriousTest {
    @DataPoint
    &lt;b&gt;public static&lt;/b&gt; String dataPoint = "value";

    @DataPoint("generated")
    &lt;b&gt;public static&lt;/b&gt; String generatedDataPoint() {
      &lt;b&gt;return&lt;/b&gt; "generated value";
    }

    @Theory
    &lt;b&gt;public void&lt;/b&gt; theoryMethod(String param) {
      // ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AssertEqualsMayBeAssertSame" defaultSeverity="WARNING" displayName="'assertEquals()' may be 'assertSame()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit &lt;code&gt;assertEquals()&lt;/code&gt; calls that
can be replaced with an equivalent &lt;code&gt;assertSame()&lt;/code&gt; call.
This is possible when the arguments are instances of a &lt;code&gt;final&lt;/code&gt; class that does not override
the &lt;code&gt;Object.equals()&lt;/code&gt; method and makes it explicit that the object identity is compared.
&lt;p&gt;Suggests replacing &lt;code&gt;assertEquals()&lt;/code&gt; with &lt;code&gt;assertSame()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  &lt;b&gt;public void&lt;/b&gt; testObjectType() {
    Object o = getObject();
    Assert.assertEquals(String.&lt;b&gt;class&lt;/b&gt;, o.getClass());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  &lt;b&gt;public void&lt;/b&gt; testSort() {
    Object o = getObject();
    Assert.assertSame(String.&lt;b&gt;class&lt;/b&gt;, o.getClass());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MetaAnnotationWithoutRuntimeRetention" defaultSeverity="WARNING" displayName="Test annotation without '@Retention(RUNTIME)' annotation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports annotations with a &lt;code&gt;SOURCE&lt;/code&gt; or &lt;code&gt;CLASS&lt;/code&gt; retention policy that are supposed to be used by JUnit 5.
Such annotations are not available at runtime and most probably their retention policy should be fixed to be accessible through reflection.
&lt;p&gt;Note that if the retention policy is not specified, then the default retention policy &lt;code&gt;CLASS&lt;/code&gt; is used.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Testable
  public @interface UnitTest {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Retention(RetentionPolicy.RUNTIME)
  @Testable
  public @interface UnitTest {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;!--&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;&lt;/p&gt;--&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestCaseInProductCode" defaultSeverity="WARNING" displayName="JUnit 'TestCase' in product source" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit 3 test classes in product source trees.
This most likely indicates a programmer's error and can result in test code being shipped
into production.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnit4AnnotatedMethodInJUnit3TestCase" defaultSeverity="WARNING" displayName="JUnit 4 test method in class extending JUnit 3 TestCase" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit 4 &lt;code&gt;@Test&lt;/code&gt; annotated methods inside the inheritor
of &lt;code&gt;junit.framework.TestCase&lt;/code&gt;. Mixing API of JUnit can lead to problems running the tests.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class MyTest extends TestCase {
      @Test //name doesn't start from "test", thus would be ignored
      public void wouldBeIgnored() {}
  
      @Test   //name starts from "test"
      @Ignore //thus would be executed despite @Ignore annotation
      public void testWouldBeExecuted() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;Provided fixes:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Remove the &lt;code&gt;@Ignore&lt;/code&gt; annotation and rename the test method, so the name doesn't start with "test".&lt;/li&gt;
  &lt;li&gt;Convert a JUnit 3 test class to JUnit 4.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleExceptionsDeclaredOnTestMethod" defaultSeverity="WARNING" displayName="Multiple exceptions declared on test method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit test method &lt;code&gt;throws&lt;/code&gt; clauses with more than one exception.
Such clauses are unnecessarily verbose.
Test methods will not be called from other project code, so there is no need to handle these exceptions separately.
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  &lt;b&gt;public void&lt;/b&gt; testReflection() &lt;b&gt;throws&lt;/b&gt; NoSuchMethodException,
      InvocationTargetException, IllegalAccessException {
    String result = (String) String.class.getMethod("trim")
        .invoke(" hello ");
    assertEquals("hello", result);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick fix is provided to replace the exception declarations with a single exception:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  &lt;b&gt;public void&lt;/b&gt; testReflection() &lt;b&gt;throws&lt;/b&gt; Exception {
    String result = (String) String.class.getMethod("trim")
        .invoke(" hello ");
    assertEquals("hello", result);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnit3StyleTestMethodInJUnit4Class" defaultSeverity="WARNING" displayName="Old style JUnit test method in JUnit 4 class" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit 3 style test methods that are located inside a class
that does not extend the JUnit 3 &lt;code&gt;TestCase&lt;/code&gt; class and contains JUnit 4 or JUnit 5 &lt;code&gt;@Test&lt;/code&gt; annotated methods.
Such test methods cannot be run.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Junit4Converter" defaultSeverity="INFORMATION" displayName="JUnit 3 test can be JUnit 4" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit 3 test classes that can be converted to JUnit 4 test classes.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class MainTestCase extends junit.framework.TestCase {
    public void test() {
      Assert.assertTrue(true);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class MainTestCase {
    @org.junit.Test
    public void test() {
      Assert.assertTrue(true);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 5 or higher, and JUnit 4 is available on the classpath.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestMethodWithoutAssertion" defaultSeverity="WARNING" displayName="JUnit test method without any assertions" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports test methods that do not contain any assertions. Such methods may indicate either incomplete or weak test cases.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; ExtensiveTest {

    @Test
    &lt;b&gt;public void&lt;/b&gt; testAlive() {
      System.out.println("nothing");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
      Use the table to specify the combinations of fully qualified class name and method name regular expression
      that should qualify as assertions. Class names also match subclasses.
  &lt;/li&gt;
  &lt;li&gt;
      Use the &lt;b&gt;'assert' keyword is considered an assertion&lt;/b&gt; option to specify if the Java &lt;code&gt;assert&lt;/code&gt; statements using the &lt;code&gt;assert&lt;/code&gt; keyword should be considered an assertion.
  &lt;/li&gt;
  &lt;li&gt;
      Use the &lt;b&gt;Ignore test methods which declare exceptions&lt;/b&gt; option to ignore the test methods that declare exceptions.
      This can be useful when you have tests that will throw an exception on failure and thus don't need any assertions.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MigrateAssertToMatcherAssert" defaultSeverity="WARNING" displayName="JUnit assertion can be 'assertThat()' call" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Assert.assertEquals()&lt;/code&gt;, &lt;code&gt;Assert.assertTrue()&lt;/code&gt;, etc. methods
which can be migrated to Hamcrest declarative style &lt;code&gt;Assert.assertThat()&lt;/code&gt; calls.
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; SubstantialTest {
    @Test
    &lt;b&gt;public void&lt;/b&gt; testContents(Collection&amp;lt;String&gt; c, String s) {
      Assert.assertTrue(c.contains(s));
      Assert.assertEquals(c, s);
      Assert.assertNotNull(c);
      Assert.assertNull(c);
      Assert.assertFalse(c.contains(s));
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix is provided to perform the migration:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; SubstantialTest {
    @Test
    &lt;b&gt;public void&lt;/b&gt; testContents(Collection&amp;lt;String&gt; c, String s) {
      assertThat(c, hasItem(o));
      assertThat(o, is(c));
      assertThat(c, notNullValue());
      assertThat(c, nullValue());
      assertThat(c, not(hasItem(o)));
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection requires that the Hamcrest library is available on the classpath.
&lt;p&gt;Use the &lt;b&gt;Statically import matcher's methods&lt;/b&gt; option to specify if you want the quick-fix to statically import the Hamcrest matcher methods.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestCaseWithConstructor" defaultSeverity="WARNING" displayName="JUnit TestCase with non-trivial constructors" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit test cases with initialization logic in their constructors.
If a constructor fails, the &lt;code&gt;@After&lt;/code&gt; annotated or &lt;code&gt;tearDown()&lt;/code&gt; method won't be called.
This can leave the test environment partially initialized, which can adversely affect other tests.
Instead, initialization of JUnit test cases should be done in a &lt;code&gt;setUp()&lt;/code&gt; or &lt;code&gt;@Before&lt;/code&gt; annotated method.
&lt;p&gt;Bad example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; ImportantTest {
    &lt;b&gt;private&lt;/b&gt; File file;
    &lt;b&gt;public&lt;/b&gt; ImportantTest() &lt;b&gt;throws&lt;/b&gt; IOException {
      file = File.createTempFile("xyz", ".tmp");
    }

    // ... tests go here
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestMethodInProductCode" defaultSeverity="WARNING" displayName="JUnit test method in product source" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods annotated with the JUnit 4 or JUnit 5 &lt;code&gt;@Test&lt;/code&gt; annotation that are located in production source trees.
This most likely a mistake and can result in test code being shipped into production.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuperTearDownInFinally" defaultSeverity="WARNING" displayName="'super.tearDown()' not called from 'finally' block" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls of the JUnit 3's &lt;code&gt;super.tearDown()&lt;/code&gt; method that are not performed inside a &lt;code&gt;finally&lt;/code&gt; block.
If there are other method calls in the &lt;code&gt;tearDown()&lt;/code&gt; method that may throw
an exception before the &lt;code&gt;super.tearDown()&lt;/code&gt; call, this may lead to inconsistencies and leaks.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; AnotherTest &lt;b&gt;extends&lt;/b&gt; CompanyTestCase {
    &lt;b&gt;private&lt;/b&gt; Path path;

    @Override
    &lt;b&gt;protected void&lt;/b&gt; setUp() &lt;b&gt;throws&lt;/b&gt; Exception {
      &lt;b&gt;super&lt;/b&gt;.setUp();
      path = Files.createTempFile("abcde", ".tmp");
    }

    @Override
    &lt;b&gt;protected void&lt;/b&gt; tearDown() &lt;b&gt;throws&lt;/b&gt; Exception {
      Files.delete(path);
      &lt;b&gt;super&lt;/b&gt;.tearDown();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Improved code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; AnotherTest &lt;b&gt;extends&lt;/b&gt; CompanyTestCase {
    &lt;b&gt;private&lt;/b&gt; Path path;

    @Override
    &lt;b&gt;protected void&lt;/b&gt; setUp() &lt;b&gt;throws&lt;/b&gt; Exception {
      &lt;b&gt;super&lt;/b&gt;.setUp();
      path = Files.createTempFile("abcde", ".tmp");
    }

    @Override
    &lt;b&gt;protected void&lt;/b&gt; tearDown() &lt;b&gt;throws&lt;/b&gt; Exception {
      &lt;b&gt;try&lt;/b&gt; {
        Files.delete(path);
      } &lt;b&gt;finally&lt;/b&gt; {
        &lt;b&gt;super&lt;/b&gt;.tearDown();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnconstructableTestCase" defaultSeverity="WARNING" displayName="Unconstructable JUnit 'TestCase'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit test cases that are not &lt;code&gt;abstract&lt;/code&gt; and do not
expose a public &lt;code&gt;no-arg&lt;/code&gt; constructor or a public constructor that takes a single string
as an argument.
Such test cases cannot be run by most JUnit test runners.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class MyTest {

  private MyTest() {} // no-arg constructor is private

  @Test
  public void testSomething() {
    assertEquals(1, 1);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestCaseWithNoTestMethods" defaultSeverity="WARNING" displayName="Test class with no tests" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-&lt;code&gt;abstract&lt;/code&gt; test cases without any test methods.
&lt;p&gt;Such test cases usually indicate unfinished code
  or could be a refactoring leftover that should be removed.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; CrucialTest {
    @Before
    &lt;b&gt;public void&lt;/b&gt; setUp() {
      System.out.println("setting up");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore test cases which have superclasses with test methods&lt;/b&gt; option to ignore test cases which have super classes
  with test methods.&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BeforeClassOrAfterClassIsPublicStaticVoidNoArg" defaultSeverity="WARNING" displayName="Malformed '@BeforeClass'/'@BeforeAll' or '@AfterClass'/'@AfterAll' method" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit 4.0 &lt;code&gt;@BeforeClass&lt;/code&gt; or &lt;code&gt;@AfterClass&lt;/code&gt; methods
that are not declared &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt;,
do not return &lt;code&gt;void&lt;/code&gt;, or take arguments.
Such methods are easy to create inadvertently, but they will not be executed by JUnit tests runners.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class MainTest {
    @BeforeClass
    String beforeClass(int i) {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied, the method changes to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MainTest {
    @BeforeClass
    public static void beforeClass() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BeforeOrAfterIsPublicVoidNoArg" defaultSeverity="WARNING" displayName="Malformed '@Before' or '@After' method" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit 4 &lt;code&gt;@Before&lt;/code&gt; or &lt;code&gt;@After&lt;/code&gt; methods that are not declared &lt;code&gt;public&lt;/code&gt;, do not return
&lt;code&gt;void&lt;/code&gt;, or take arguments. Such methods are easy to create inadvertently, but they will not be executed by JUnit tests runners.
&lt;p&gt;The inspection provides fixes for method signatures.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Before private int foo(int arg) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Before public void foo() { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticSuite" defaultSeverity="WARNING" displayName="'suite()' method not declared 'static'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit test case classes with &lt;code&gt;suite()&lt;/code&gt; methods which aren't declared as &lt;code&gt;static&lt;/code&gt;.&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestMethodIsPublicVoidNoArg" defaultSeverity="WARNING" displayName="Malformed test method" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any JUnit test methods that are declared &lt;code&gt;static&lt;/code&gt;, not declared
&lt;code&gt;public&lt;/code&gt;, do not return &lt;code&gt;void&lt;/code&gt;, or have parameters.
Such test methods are easy to create inadvertently, but they will not be executed by
JUnit test runners.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  void test() {
    assertEquals(1, 1);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  public void test() {
    assertEquals(1, 1);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;p&gt;Use the inspection options to specify annotations.
  Any parameter annotated with one of these annotations will not be reported.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterizedParametersStaticCollection" defaultSeverity="WARNING" displayName="Parameterized test class without data provider method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit 4 &lt;a href="https://github.com/junit-team/junit4/wiki/parameterized-tests"&gt;parameterized test&lt;/a&gt; classes that are annotated
with &lt;code&gt;@RunWith(Parameterized.class)&lt;/code&gt; but either do not include a data provider method annotated with &lt;code&gt;@Parameterized.Parameters&lt;/code&gt; or
this method has an incorrect signature. Such test classes cannot be run.
The data provider method should be &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; and have a return type of &lt;code&gt;Iterable&lt;/code&gt; or
&lt;code&gt;Object[]&lt;/code&gt;.
&lt;p&gt;Suggests creating an empty parameter provider method or changing the signature of the incorrect data provider method.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;p&gt;
&lt;pre&gt;&lt;code&gt;
  @RunWith(Parameterized.class)
  &lt;b&gt;public class&lt;/b&gt; ImportantTest {
    &lt;b&gt;private int&lt;/b&gt; input;
    &lt;b&gt;private int&lt;/b&gt; expected;

    ImportantTest(&lt;b&gt;int&lt;/b&gt; input, &lt;b&gt;int&lt;/b&gt; expected) {
      &lt;b&gt;this&lt;/b&gt;.input = input;
      &lt;b&gt;this&lt;/b&gt;.expected = expected;
    }

    // ... test cases
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @RunWith(Parameterized.class)
  &lt;b&gt;public class&lt;/b&gt; ImportantTest {
    &lt;b&gt;private int&lt;/b&gt; input;
    &lt;b&gt;private int&lt;/b&gt; expected;

    ImportantTest(&lt;b&gt;int&lt;/b&gt; input, &lt;b&gt;int&lt;/b&gt; expected) {
      &lt;b&gt;this&lt;/b&gt;.input = input;
      &lt;b&gt;this&lt;/b&gt;.expected = expected;
    }

    @Parameters
    &lt;b&gt;public static&lt;/b&gt; Iterable&amp;lt;Object[]&gt; parameters() {
      &lt;b&gt;return null&lt;/b&gt;;
    }

    // ... test cases
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IgnoredJUnitTest" defaultSeverity="WARNING" displayName="JUnit test annotated with '@Ignore'/'@Disabled'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of JUnit 4's &lt;code&gt;@Ignore&lt;/code&gt; or JUnit 5's &lt;code&gt;@Disabled&lt;/code&gt; annotations.
It is considered a code smell to have tests annotated with these annotations for a long time, especially when no reason is specified.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Ignore
  &lt;b&gt;public class&lt;/b&gt; UrgentTest {

    @Test
    &lt;b&gt;public void&lt;/b&gt; testIt() {
      Assert.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Only report annotations without reason&lt;/b&gt; option to only report the cases when no reason is specified as the annotation's
    &lt;code&gt;value&lt;/code&gt; attribute.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnit5MalformedNestedClass" defaultSeverity="WARNING" displayName="JUnit 5 malformed '@Nested' class" enabled="true" language="JVM" pluginId="JUnit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;static&lt;/code&gt; inner classes annotated with &lt;code&gt;@Nested&lt;/code&gt;.
&lt;p&gt;The &lt;code&gt;@Nested&lt;/code&gt; annotation cannot be used on &lt;code&gt;static&lt;/code&gt; classes.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertEqualsCalledOnArray" defaultSeverity="WARNING" displayName="'assertEquals()' called on array" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit &lt;code&gt;assertEquals()&lt;/code&gt; calls with arguments of an array type.
Such methods compare the arrays' identities instead of the arrays' contents.
Array contents should be checked with the &lt;code&gt;assertArrayEquals()&lt;/code&gt; method.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  &lt;b&gt;public void&lt;/b&gt; testSort() {
    &lt;b&gt;int&lt;/b&gt;[] actual = {248, 496, 0, 56};
    Arrays.sort(actual);
    Assert.assertEquals(&lt;b&gt;new int&lt;/b&gt;[] {0, 56, 248, 496}, actual);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  &lt;b&gt;public void&lt;/b&gt; testSort() {
    &lt;b&gt;int&lt;/b&gt;[] actual = {248, 496, 0, 56};
    Arrays.sort(actual);
    Assert.assertArrayEquals(&lt;b&gt;new int&lt;/b&gt;[] {0, 56, 248, 496}, actual);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Concurrency annotation issues" path="Java"><inspection shortName="NonFinalFieldInImmutable" defaultSeverity="WARNING" displayName="Non-final field in '@Immutable' class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any non-final field in a class with the &lt;code&gt;@Immutable&lt;/code&gt; annotation.
This violates the contract of the &lt;code&gt;@Immutable&lt;/code&gt; annotation.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import javax.annotation.concurrent.Immutable;
  @Immutable
  class Foo {
    String bar = "foo";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Supported &lt;code&gt;@GuardedBy&lt;/code&gt; annotations are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldAccessNotGuarded" defaultSeverity="WARNING" displayName="Unguarded field access or method call" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports accesses of fields declared as &lt;code&gt;@GuardedBy&lt;/code&gt; that are not guarded by an appropriate synchronization structure.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    @GuardedBy("this")
    void x() {
        notify();
    }
    void y() {
        x(); // unguarded method call
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Supported &lt;code&gt;@GuardedBy&lt;/code&gt; annotations are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticGuardedByInstance" defaultSeverity="WARNING" displayName="Static member guarded by instance field or this" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;@GuardedBy&lt;/code&gt; annotations on &lt;code&gt;static&lt;/code&gt; fields or methods in which the guard is either a non-static field or
&lt;code&gt;this&lt;/code&gt;.
&lt;p&gt;Guarding a static element with a non-static element may result in
  excessive concurrency, multiple threads may be able to access the guarded field simultaneously by locking in different object contexts.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private ReadWriteLock lock = new ReentrantReadWriteLock();

    @GuardedBy("lock")
    public static void bar() {
        // ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Supported &lt;code&gt;@GuardedBy&lt;/code&gt; annotations are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnknownGuard" defaultSeverity="WARNING" displayName="Unknown '@GuardedBy' field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;@GuardedBy&lt;/code&gt; annotations in which the specified guarding field is unknown.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private Object state;

    @GuardedBy("lock") //unknown guard reference
    public void bar() {
        state = new Object();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Supported &lt;code&gt;@GuardedBy&lt;/code&gt; annotations are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalGuard" defaultSeverity="WARNING" displayName="Non-final '@GuardedBy' field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;@GuardedBy&lt;/code&gt; annotations in which the guarding field
is not &lt;code&gt;final&lt;/code&gt;.
&lt;p&gt;Guarding on a non-final field may result in unexpected race conditions, as locks will
  be held on the value of the field (which may change), rather than the field itself.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private ReadWriteLock lock = new ReentrantReadWriteLock(); //not final guarding field
    private Object state;

    @GuardedBy("lock")
    public void bar() {
        state = new Object();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Supported &lt;code&gt;@GuardedBy&lt;/code&gt; annotations are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceGuardedByStatic" defaultSeverity="WARNING" displayName="Instance member guarded by static field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;@GuardedBy&lt;/code&gt; annotations on instance fields or methods
in which the guard is a &lt;code&gt;static&lt;/code&gt; field. Guarding a non-static by a static may result in excessive lock contention,
as access to each locked field in any object instance will prevent simultaneous access to that field in every object instance.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private static ReadWriteLock lock = new ReentrantReadWriteLock(); //static guarding field
    private Object state;

    @GuardedBy("lock")
    public void bar() {
        state = new Object();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Supported &lt;code&gt;@GuardedBy&lt;/code&gt; annotations are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;net.jcip.annotations.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;javax.annotation.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;org.apache.http.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.android.annotations.concurrency.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;androidx.annotation.GuardedBy&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.errorprone.annotations.concurrent.GuardedBy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Packaging issues" path="Java"><inspection shortName="ClassOnlyUsedInOnePackage" defaultSeverity="WARNING" displayName="Class only used from one other package" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports classes that don't depend on any other class in their package, depend on classes from another package, and are themselves a dependency
only for classes from this other package.
Consider moving such classes to the package on which they depend.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageWithTooFewClasses" defaultSeverity="WARNING" displayName="Package with too few classes" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports packages that contain fewer classes than the specified minimum.
&lt;p&gt;Packages which contain subpackages are not reported. Overly small packages may indicate a fragmented design.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Minimum number of classes&lt;/b&gt; field to specify the minimum allowed number of classes in a package.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DisjointPackage" defaultSeverity="WARNING" displayName="Package with disjoint dependency graph" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports packages whose classes can be separated into mutually independent subsets.
&lt;p&gt;Such disjoint packages indicate ad-hoc packaging or a lack of conceptual cohesion.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageInMultipleModules" defaultSeverity="WARNING" displayName="Package with classes in multiple modules" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports non-empty packages that are present in several modules.
When packages are contained in several modules, it is very easy to create a class with the same name in two modules.
A module which depends on these modules will see a conflict if it tries to use such a class.
The Java Platform Module System disallows packages contained in more than one module (also called &lt;em&gt;split packages&lt;/em&gt;)
&lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExceptionPackage" defaultSeverity="WARNING" displayName="Exception package" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports packages that only contain classes that extend &lt;code&gt;java.lang.Throwable&lt;/code&gt;, either directly or indirectly.
  &lt;p&gt;Although exceptions usually don't depend on other classes for their implementation, they are normally not used separately.
    It is often a better design to locate exceptions in the same package as the classes that use them.&lt;/p&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassUnconnectedToPackage" defaultSeverity="WARNING" displayName="Class independent of its package" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports classes that don't depend on any other class in their package and are not a dependency for any other class in their package.
Such classes indicate ad-hoc or incoherent packaging strategies and often may be profitably moved.
  &lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageWithTooManyClasses" defaultSeverity="WARNING" displayName="Package with too many classes" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports packages that contain too many classes.
&lt;p&gt;Overly large packages may indicate a lack of design clarity.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Maximum number of classes&lt;/b&gt; field to specify the maximum allowed number of classes in a package.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Imports" path="Java"><inspection shortName="JavaLangImport" defaultSeverity="WARNING" displayName="Unnecessary import from the 'java.lang' package" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;import&lt;/code&gt; statements that refer to the &lt;code&gt;java.lang&lt;/code&gt; package.
&lt;p&gt;
  &lt;code&gt;java.lang&lt;/code&gt; classes are always implicitly imported, so such import statements are
  redundant and confusing.
&lt;/p&gt;
&lt;p&gt;
  Since IntelliJ IDEA can automatically detect and fix such statements with its &lt;b&gt;Optimize Imports&lt;/b&gt; command, this inspection is mostly useful for offline reporting on code bases that you don't intend to change.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SamePackageImport" defaultSeverity="WARNING" displayName="Unnecessary import from the same package" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;import&lt;/code&gt; statements that refer to the same package as the
containing file.
&lt;p&gt;
  Same-package files are always implicitly imported, so such &lt;code&gt;import&lt;/code&gt;
  statements are redundant and confusing.
&lt;/p&gt;
&lt;p&gt;
  Since IntelliJ IDEA can automatically detect and fix such statements with its &lt;b&gt;Optimize Imports&lt;/b&gt;
  command, this inspection is mostly useful for offline reporting on code bases that you
  don't intend to change.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticImport" defaultSeverity="WARNING" displayName="Static import" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;import static&lt;/code&gt; statements.
&lt;p&gt;Such &lt;code&gt;import&lt;/code&gt; statements are not supported under Java 1.4 or earlier JVMs.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the table below to specify the classes that will be ignored by the inspection when used in an &lt;code&gt;import static&lt;/code&gt;
    statement.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore single field static imports&lt;/b&gt; checkbox to ignore single-field &lt;code&gt;import static&lt;/code&gt; statements.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore single method static imports&lt;/b&gt; checkbox to ignore single-method &lt;code&gt;import static&lt;/code&gt; statements.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UNUSED_IMPORT" defaultSeverity="WARNING" displayName="Unused import" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports redundant &lt;code&gt;import&lt;/code&gt; statements.
&lt;p&gt;Regular &lt;code&gt;import&lt;/code&gt; statements are unnecessary when not using imported classes and packages in the source file.
The same applies to imported &lt;code&gt;static&lt;/code&gt; fields and methods that aren't used in the source file.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.ArrayList;
  public class Example {
    public static void main(String[] args) {
      System.out.println("Hello World!");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick fix is applied:
&lt;pre&gt;&lt;code&gt;
  public class Example {
    public static void main(String[] args) {
      System.out.println("Hello World!");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SingleClassImport" defaultSeverity="WARNING" displayName="Single class import" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;import&lt;/code&gt; statements that import single classes (as opposed to entire packages).
&lt;p&gt;Some coding standards prohibit such &lt;code&gt;import&lt;/code&gt; statements.&lt;/p&gt;
&lt;p&gt;
  You can configure IntelliJ IDEA to detect and fix such statements with its &lt;b&gt;Optimize Imports&lt;/b&gt; command. Go to
  &lt;a href="settings://preferences.sourceCode.Java?Use%20single%20class%20import"&gt;Settings | Editor | Code Style | Java | Imports&lt;/a&gt;
  and clear the &lt;b&gt;Use single class import&lt;/b&gt; checkbox. Thus this inspection is mostly useful for
  offline reporting on code bases that you don't intend to change.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OnDemandImport" defaultSeverity="WARNING" displayName="'*' import" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any &lt;code&gt;import&lt;/code&gt; statements that cover entire packages ('* imports').
&lt;p&gt;Some coding standards prohibit such &lt;code&gt;import&lt;/code&gt; statements.&lt;/p&gt;
&lt;p&gt;
  You can configure IntelliJ IDEA to detect and fix such statements with its &lt;b&gt;Optimize Imports&lt;/b&gt;
  command. Go to &lt;a href="settings://preferences.sourceCode.Java?Use%20single%20class%20import"&gt;Settings | Editor | Code Style | Java | Imports&lt;/a&gt;,
  make sure that the &lt;b&gt;Use single class import&lt;/b&gt; option is enabled, and specify values in the
  &lt;b&gt;Class count to use import with '*'&lt;/b&gt; and &lt;b&gt;Names count to use static import with '*'&lt;/b&gt; fields.
  Thus this inspection is mostly useful for offline reporting on code bases that you don't
  intend to change.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Data flow analysis" path="C/C++"><inspection shortName="LocalValueEscapesScope" defaultSeverity="WARNING" displayName="Local value escapes scope" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the variables with the references to the local variables that escape their scope.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int *escapeLocalScope() {
    int lv = 100;
    return &amp;#38lv;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingReturn" defaultSeverity="WARNING" displayName="Missing return" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the non-void methods, functions, and blocks that may exit without executing the &lt;code&gt;return&lt;/code&gt; statement.
All the paths in the control flow graph must end with a &lt;code&gt;return&lt;/code&gt; statement.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedValue" defaultSeverity="WARNING" displayName="Unused value" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the variable values that are never used after being assigned. This can happen in the following cases:
&lt;ul&gt;
  &lt;li&gt;the variable is never read after the assignment&lt;/li&gt;
  &lt;li&gt;the value is overwritten by another assignment before it is accessed for reading&lt;/li&gt;
  &lt;li&gt;the variable initializer is redundant (for one of the above two reasons)&lt;/li&gt;
  &lt;li&gt;the variable itself is never used.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    int field;

    void foo() {
      field = unused_value;
    }

    void bar() {
      use(field);
      foo();
    }
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the checkbox below to have this inspection ignore variable initializers.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopDoesntUseConditionVariable" defaultSeverity="WARNING" displayName="Loop condition isn't updated inside the loop" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the loop conditions that are not updated inside the loop.
This can indicate code defects and cause infinite loops at runtime.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    int i = 0, j = 0;
    while (i &amp;lt; 10) {
        ++j;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NullDereference" defaultSeverity="WARNING" displayName="Null dereference" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports dereferences of the pointers that may contain &lt;code&gt;nullptr&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  using namespace std;
  void process(string *a, string b) {
    if (a != nullptr || a-&gt;length()) {
      a = &amp;#38b;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedParameter" defaultSeverity="WARNING" displayName="Unused parameter" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the parameters that are declared but never accessed for reading and can be removed safely.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OCDFA" defaultSeverity="WARNING" displayName="Context-sensitive analysis" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the issues found by the context-sensitive data flow analyser.
Such as: "Constant condition", "Dangling pointer", "Null dereference", "Unreachable code", and so on.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantConditionsOC" defaultSeverity="WARNING" displayName="Constant condition" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports conditions that are always &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; and expressions whose value is statically proven to be constant.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process(State current) {
    current = State::Started;

    if (current == State::Stopped) {
        //code
    }
    //code
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnreachableCallsOfFunction" defaultSeverity="WARNING" displayName="Unreachable calls of function" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the functions which calls are never used. Such functions are also never executed.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnreachableCode" defaultSeverity="WARNING" displayName="Unreachable code" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the code pieces that are never executed in any control flow and can be removed safely.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NotInitializedVariable" defaultSeverity="WARNING" displayName="Not initialized variable" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the local variables that may have not been initialized before their usage.
Formally, there is a path in the call graph that starts at a variable declaration and ends at its usage which has no assignments or dereferences of this variable.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantParameter" defaultSeverity="WARNING" displayName="Constant parameter" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports function parameters that always have the same value.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedLocalVariable" defaultSeverity="WARNING" displayName="Unused local variable" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the local variables that are declared but never accessed for reading.
Such declarations and assignment can be removed safely.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantFunctionResult" defaultSeverity="WARNING" displayName="Constant function result" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the functions where the return value is always the same constant.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EndlessLoop" defaultSeverity="WARNING" displayName="Endless loop" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;do while&lt;/code&gt;, and &lt;code&gt;goto&lt;/code&gt; statements that exit only by throwing an exception.
Even though such statements may be correct, they often indicate code errors.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DanglingPointer" defaultSeverity="WARNING" displayName="Dangling pointer" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the usages of the pointers that refer to the memory already deleted by the &lt;code&gt;delete&lt;/code&gt; operator or the &lt;code&gt;free(void* ptr)&lt;/code&gt; function.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process() {
    for(node *pt = head; pt != nullptr; pt = pt-&gt;next) {
        delete pt;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Markdown" path=""><inspection shortName="MarkdownNoTableBorders" defaultSeverity="ERROR" displayName="Table doesn't have side borders" enabled="true" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Checks if table has correct side borders.
For compatibility reasons all table rows should have borders (pipe symbols) at the start and at the end.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MarkdownIncorrectTableFormatting" defaultSeverity="WEAK WARNING" displayName="Incorrect table formatting" enabled="true" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Checks if table is correctly formatted.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MarkdownUnresolvedFileReference" defaultSeverity="WARNING" displayName="Unresolved file references" enabled="true" language="Markdown" pluginId="org.intellij.plugins.markdown" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unresolved file references in Markdown files.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Initialization" path="Java"><inspection shortName="AbstractMethodCallInConstructor" defaultSeverity="WARNING" displayName="Abstract method called during object construction" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;abstract&lt;/code&gt; methods of the current class during object construction.
&lt;p&gt;A method is called during object construction if it is inside a:
&lt;ul&gt;
  &lt;li&gt;Constructor&lt;/li&gt;
  &lt;li&gt;Non-static instance initializer&lt;/li&gt;
  &lt;li&gt;Non-static field initializer&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;clone()&lt;/code&gt; method&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObject()&lt;/code&gt; method&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObjectNoData()&lt;/code&gt; method&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Such calls may result in subtle bugs, as object initialization may happen before the method call.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Parent {
    abstract void abstractMethod();
  }

  class Child extends Parent {
    Child() {
      abstractMethod();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection shares the functionality with the following inspections:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Overridable method called during object construction&lt;/li&gt;
  &lt;li&gt;Overridden method called during object construction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Only one inspection should be enabled at once to prevent warning duplication.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalStaticVariableUsedInClassInitialization" defaultSeverity="WARNING" displayName="Non-final static field is used during class initialization" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the use of non-&lt;code&gt;final&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; variables during class initialization.
&lt;p&gt;In such cases, the code semantics may become dependent on the class creation order. Additionally, such cases may lead to the use of
  variables before their initialization, and generally cause difficult and confusing bugs.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public static int bar = 0;

    static {
      System.out.println(bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticVariableInitialization" defaultSeverity="WARNING" displayName="Static field may not be initialized" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;static&lt;/code&gt; variables that may be uninitialized upon class initialization.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public static int bar;

    static { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that this inspection uses a very conservative dataflow algorithm and may incorrectly report &lt;code&gt;static&lt;/code&gt; variables as uninitialized. Variables
  reported as initialized will always be initialized.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore primitive fields&lt;/b&gt; option to ignore uninitialized primitive fields.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThisEscapedInConstructor" defaultSeverity="WARNING" displayName="'this' reference escaped in object construction" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports possible escapes of &lt;code&gt;this&lt;/code&gt; during the object initialization. The escapes occur when &lt;code&gt;this&lt;/code&gt; is used as a method argument
or an object of assignment in a constructor or initializer. Such escapes may result in subtle bugs, as the object is now available in the
context where it is not guaranteed to be initialized.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    {
      System.out.println(this);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InstanceVariableInitialization" defaultSeverity="WARNING" displayName="Instance field may not be initialized" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instance variables that may be uninitialized upon object initialization.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public int bar;

    static { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that this inspection uses a very conservative dataflow algorithm and may incorrectly report instance variables as uninitialized. Variables
  reported as initialized will always be initialized.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore primitive fields&lt;/b&gt; option to ignore uninitialized primitive fields.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DoubleBraceInitialization" defaultSeverity="INFORMATION" displayName="Double brace initialization" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;a href="https://www.c2.com/cgi/wiki?DoubleBraceInitialization"&gt;Double Brace Initialization&lt;/a&gt;.
&lt;p&gt;Double brace initialization may cause memory leaks when used in a non-static context because it creates an anonymous class
  that will reference the surrounding object.&lt;/p&gt;
&lt;p&gt;Compared to regular initialization, double brace initialization provides worse performance since it requires loading an
  additional class.&lt;/p&gt;
&lt;p&gt;It may also cause failure of &lt;code&gt;equals()&lt;/code&gt; comparisons if the &lt;code&gt;equals()&lt;/code&gt; method doesn't accept subclasses as
  parameters.&lt;/p&gt;
&lt;p&gt;In addition, before Java 9, double brace initialization couldn't be combined with the diamond operator since it was incompatible
  with anonymous classes.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;() {{
    add(1);
    add(2);
  }};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
  list.add(1);
  list.add(2);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceVariableUninitializedUse" defaultSeverity="WARNING" displayName="Instance field used before initialization" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instance variables that are read before initialization.
&lt;p&gt;The inspection ignores equality checks with &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int bar;

    Foo() {
      System.out.println(bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that this inspection uses a very conservative dataflow algorithm and may incorrectly report instance variables as uninitialized. Variables
  reported as initialized will always be initialized.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore if annotated by&lt;/b&gt; option to specify special annotations. The inspection will ignore fields
  annotated with one of these annotations.&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore primitive fields&lt;/b&gt; option to ignore uninitialized primitive fields.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OverriddenMethodCallDuringObjectConstruction" defaultSeverity="WARNING" displayName="Overridden method called during object construction" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any calls to overridden methods of the current class during object construction.
This happens if an object construction is inside:
&lt;ul&gt;
  &lt;li&gt;A constructor&lt;/li&gt;
  &lt;li&gt;A non-static instance initializer&lt;/li&gt;
  &lt;li&gt;A non-static field initializer&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;clone()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObject()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObjectNoData()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Such calls may result in subtle bugs, as the object is not guaranteed to be initialized before the method call occurs.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Parent {
    void someMethod() { }
  }

  class Child extends Parent {
    Child() {
      someMethod();
    }

    @Override
    void someMethod() { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection shares its functionality with:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The &lt;b&gt;Abstract method called during object construction&lt;/b&gt; inspection&lt;/li&gt;
  &lt;li&gt;The &lt;b&gt;Overridable method called during object construction&lt;/b&gt; inspection&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Only one inspection should be enabled at the same time to prevent duplicate warnings.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverridableMethodCallDuringObjectConstruction" defaultSeverity="WARNING" displayName="Overridable method called during object construction" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to overridable methods of the current class during object construction.
&lt;p&gt;A method is called during object construction if it is inside a:
&lt;ul&gt;
  &lt;li&gt;Constructor&lt;/li&gt;
  &lt;li&gt;Non-static instance initializer&lt;/li&gt;
  &lt;li&gt;Non-static field initializer&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;clone()&lt;/code&gt; method&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObject()&lt;/code&gt; method&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;readObjectNoData()&lt;/code&gt; method&lt;/li&gt;
&lt;p&gt;Methods are overridable if they are not declared as &lt;code&gt;final&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, or &lt;code&gt;private&lt;/code&gt;.
  Package-local methods are considered safe, even though they are overridable. Such calls may result in subtle bugs,
  as object initialization may happen before the method call.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    void someMethod() { }
  }

  class Child extends Parent {
    Child() {
      someMethod();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
  &lt;p&gt;This inspection shares the functionality with the following inspections:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Abstract method called during object construction&lt;/li&gt;
  &lt;li&gt;Overridden method called during object construction&lt;/li&gt;
&lt;/ul&gt;
  &lt;p&gt;Only one inspection should be enabled at once to prevent warning duplication.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticVariableUninitializedUse" defaultSeverity="WARNING" displayName="Static field used before initialization" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;static&lt;/code&gt; variables that are read before initialization.
&lt;p&gt;The inspection ignores equality checks with &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public static int bar;

    public static void main(String[] args) {
      System.out.println(bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that this inspection uses a very conservative dataflow algorithm and may incorrectly report &lt;code&gt;static&lt;/code&gt; variables as uninitialized. Variables
  reported as initialized will always be initialized.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore primitive fields&lt;/b&gt; option to ignore uninitialized primitive fields.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NonThreadSafeLazyInitialization" defaultSeverity="WARNING" displayName="Unsafe lazy initialization of 'static' field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;static&lt;/code&gt; variables that are lazily initialized in a non-thread-safe manner.
&lt;p&gt;Lazy initialization of &lt;code&gt;static&lt;/code&gt; variables should be done with an appropriate synchronization construct
  to prevent different threads from performing conflicting initialization.&lt;/p&gt;
&lt;p&gt;When applicable, a quick-fix, which introduces the
&lt;a href="https://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom"&gt;lazy initialization holder class idiom&lt;/a&gt;, is suggested.
  This idiom makes use of the fact that the JVM guarantees that a class will not be initialized until it is used.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
    private static List&amp;lt;String&amp;gt; list;

    public List&amp;lt;String&amp;gt; getList() {
      if (list == null) {
        list = List.of("one", "two", "tree");
      }
      return list;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
    private static final class ListHolder {
      static final List&amp;lt;String&amp;gt; list = List.of("one", "two", "tree");
    }

    public List&amp;lt;String&amp;gt; getList() {
      return ListHolder.list;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Gradle" path="Kotlin/Migration"><inspection shortName="GradleKotlinxCoroutinesDeprecation" defaultSeverity="ERROR" displayName="Incompatible kotlinx.coroutines dependency is used with Kotlin 1.3+ in Gradle" enabled="true" language="Groovy" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library dependencies in Gradle that should be updated to be compatible with Kotlin 1.3+.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
      implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.0.1'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix changes the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library version to a compatible with Kotlin 1.3:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
      implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.27.0-eap13'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java language level issues" path="Java"><inspection shortName="AssertStatement" defaultSeverity="WARNING" displayName="'assert' statement" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;assert&lt;/code&gt; statements. By default, &lt;code&gt;assert&lt;/code&gt; statements are disabled during execution in the production
environment. Consider using logger or exceptions instead.
&lt;p&gt;The &lt;code&gt;assert&lt;/code&gt; statements are not supported in Java 1.3 and earlier JVM.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnumClass" defaultSeverity="WARNING" displayName="Enumerated class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;b&gt;enum&lt;/b&gt; classes.
Such statements are not supported in Java 1.4 and earlier JVM.
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForwardCompatibility" defaultSeverity="WARNING" displayName="Forward compatibility" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Java code constructs that may fail to compile in future Java versions.
&lt;p&gt;The following problems are reported:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use of &lt;code&gt;assert&lt;/code&gt;&gt;, &lt;code&gt;enum&lt;/code&gt; or &lt;/code&gt;_&lt;/code&gt; as an identifier&lt;/li&gt;
  &lt;li&gt;Use of the &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;yield&lt;/code&gt;, or &lt;code&gt;record&lt;/code&gt; restricted identifier as a type name&lt;/li&gt;
  &lt;li&gt;Unqualified calls to the &lt;code&gt;yield&lt;/code&gt; method&lt;/li&gt;
  &lt;li&gt;Modifiers on the &lt;code&gt;requires java.base&lt;/code&gt; statement inside of &lt;code&gt;module-info.java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Since Java 14, this class will stop compiling, as 'yield' becomes a restricted identifier.
  public class yield {} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fixing these issues timely may simplify migration to future Java versions.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForeachStatement" defaultSeverity="WARNING" displayName="Enhanced 'for' statement" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports enhanced &lt;code&gt;for&lt;/code&gt; statements.
Such &lt;code&gt;for&lt;/code&gt; statements are not supported by Java of version 1.4 and older.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int x: Arrays.asList(1, 2, 3)) {
    System.out.println(x);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Iterator&amp;lt;Integer&amp;gt; iterator = Arrays.asList(1, 2, 3).iterator(); iterator.hasNext(); ) {
    final int x = iterator.next();
    System.out.println(x);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VarargParameter" defaultSeverity="INFORMATION" displayName="Varargs method" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that accept an arbitrary number of parameters (also known as varargs methods).
&lt;p&gt;Such methods are not supported under Java 1.4 or earlier JVMs.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum EnumConstants {
  A(null), B, C;

  EnumConstants(String... ss) {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix is available to replace a variable argument
  parameter with an equivalent array parameter. Relevant arguments in method calls are wrapped in an array initializer expression.
  After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum EnumConstants {
  A(null), B(new String[]{}), C(new String[]{});

  EnumConstants(String[] ss) {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnnotationClass" defaultSeverity="WARNING" displayName="Annotation class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports annotation interfaces.
Such interfaces are not supported in Java 1.4 and earlier JVM.
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Annotation" defaultSeverity="WARNING" displayName="Annotation" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports annotations.
Annotations are not supported in Java 1.4 and earlier JVM.
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Properties files" path=""><inspection shortName="UnusedMessageFormatParameter" defaultSeverity="WARNING" displayName="Missing message format parameter" enabled="true" language="Properties" pluginId="com.intellij.java-i18n" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports properties values
that look like &lt;code&gt;java.text.MessageFormat&lt;/code&gt; format strings
but do not use some the parameters of the &lt;code&gt;{xx}&lt;/code&gt; kind.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
# parameter {0} is not used
&lt;b&gt;error.message&lt;/b&gt;=Something happened in line &lt;b&gt;{1}&lt;/b&gt;
  &lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AlphaUnsortedPropertiesFile" defaultSeverity="WEAK WARNING" displayName="Properties file or resource bundle is alphabetically unsorted" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports alphabetically unsorted resource bundles or .properties files.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InconsistentResourceBundle" defaultSeverity="ERROR" displayName="Inconsistent resource bundle" enabled="true" language="Properties" pluginId="com.intellij.java-i18n" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports problems in the properties files contained in the resource bundle.
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;Report missing translation&lt;/b&gt;
  &lt;/li&gt;
&lt;/ul&gt;
option controls search for an untranslated properties. &lt;br&gt;
It reports properties contained in parent properties file that are missing in inherited (unless it's a language dialect). &lt;br&gt;
E.g. having this resource bundle: &lt;br&gt;

&lt;b&gt;messages.properties&lt;/b&gt; : &lt;font color="#000080"&gt;&lt;b&gt;abc=xxx&lt;/b&gt;&lt;/font&gt; &lt;br&gt;
&lt;b&gt;messages_fr.properties&lt;/b&gt; : empty &lt;br&gt;

Property &lt;font color="#000080"&gt;&lt;b&gt;abc&lt;/b&gt;&lt;/font&gt; will be reported as untranslated.
&lt;ul&gt;
  &lt;li&gt;

    &lt;b&gt;Report inconsistent properties&lt;/b&gt;
  &lt;/li&gt;
&lt;/ul&gt;
option controls invalid resource bundle structure inspection. &lt;br&gt;
It reports properties contained in inherited properties file that are missing in parent (or in sibling if there is no parent). &lt;br&gt;
E.g. having this resource bundle: &lt;br&gt;
&lt;b&gt;messages.properties&lt;/b&gt; : empty &lt;br&gt;
&lt;b&gt;messages_fr.properties&lt;/b&gt; : &lt;font color="#000080"&gt;&lt;b&gt;abc=xxx&lt;/b&gt;&lt;/font&gt; &lt;br&gt;

Property &lt;font color="#000080"&gt;&lt;b&gt;abc&lt;/b&gt;&lt;/font&gt; translation here is not available for any language except French,
and, thus, will be reported as missing in the (default) properties file &lt;b&gt;messages.properties&lt;/b&gt; .

&lt;ul&gt;
  &lt;li&gt;

    &lt;b&gt;Report properties overridden with the same value&lt;/b&gt;
  &lt;/li&gt;
&lt;/ul&gt;
option checks for properties which are copy-pasted into several properties files verbatim. &lt;br&gt;
E.g. in this resource bundle: &lt;br&gt;
&lt;b&gt;messages.properties&lt;/b&gt; : &lt;font color="#000080"&gt;&lt;b&gt;abc=xxx&lt;/b&gt;&lt;/font&gt; &lt;br&gt;
&lt;b&gt;messages_fr.properties&lt;/b&gt; : &lt;font color="#000080"&gt;&lt;b&gt;abc=xxx&lt;/b&gt;&lt;/font&gt; &lt;br&gt;

Property &lt;font color="#000080"&gt;&lt;b&gt;abc&lt;/b&gt;&lt;/font&gt; will be reported as unnecessarily inherited in the file &lt;b&gt;messages_fr.properties&lt;/b&gt; .
&lt;br&gt;

&lt;ul&gt;
  &lt;li&gt;

    &lt;b&gt;Report properties overridden with different placeholders&lt;/b&gt;
  &lt;/li&gt;
&lt;/ul&gt;
option checks for properties which are overridden for placeholder consistency. &lt;br&gt;
E.g. in this resource bundle: &lt;br&gt;
&lt;b&gt;messages.properties&lt;/b&gt; : &lt;br&gt;
&lt;font color="#000080"&gt;&lt;b&gt;qwe={0}xxx{1}&lt;/b&gt;&lt;/font&gt; &lt;br&gt;
&lt;font color="#000080"&gt;&lt;b&gt;abc={0}yyy{1}&lt;/b&gt;&lt;/font&gt; &lt;br&gt;
&lt;b&gt;messages_fr.properties&lt;/b&gt; : &lt;br&gt;
&lt;font color="#000080"&gt;&lt;b&gt;qwe={0}xxx{0}xxx{1}&lt;/b&gt;&lt;/font&gt; &lt;br&gt;
&lt;font color="#000080"&gt;&lt;b&gt;abc={0}yyy&lt;/b&gt;&lt;/font&gt; &lt;br&gt;


Property &lt;font color="#000080"&gt;&lt;b&gt;abc&lt;/b&gt;&lt;/font&gt; will be reported as property contains message format placeholders
with value not corresponding to &lt;b&gt;messages.properties&lt;/b&gt; .
&lt;br&gt;

&lt;ul&gt;
  &lt;li&gt;

    &lt;b&gt;Report properties overridden with different values endings&lt;/b&gt;
  &lt;/li&gt;
&lt;/ul&gt;
option checks for properties which are overridden for ending consistency. &lt;br&gt;
E.g. in this resource bundle: &lt;br&gt;
&lt;b&gt;messages.properties&lt;/b&gt; : &lt;br&gt;
&lt;font color="#000080"&gt;&lt;b&gt;abc=xxxzzz&lt;/b&gt;&lt;/font&gt; &lt;br&gt;
&lt;b&gt;messages_fr.properties&lt;/b&gt; : &lt;br&gt;
&lt;font color="#000080"&gt;&lt;b&gt;abc=xxx;&lt;/b&gt;&lt;/font&gt; &lt;br&gt;


Property &lt;font color="#000080"&gt;&lt;b&gt;abc&lt;/b&gt;&lt;/font&gt; will be reported as property contains special signs
( &lt;b&gt;'!'&lt;/b&gt; , &lt;b&gt;'?'&lt;/b&gt; , &lt;b&gt;'.'&lt;/b&gt; , &lt;b&gt;':'&lt;/b&gt; or &lt;b&gt;';'&lt;/b&gt; ) at the end of value but
value in &lt;b&gt;messages.properties&lt;/b&gt; doesn't.
&lt;br&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TrailingSpacesInProperty" defaultSeverity="WARNING" displayName="Trailing spaces in property" enabled="true" language="Properties" pluginId="com.intellij.properties" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports all properties whose keys or values end with a whitespace. &lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DuplicatePropertyInspection" defaultSeverity="WARNING" displayName="Duplicate property" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports duplicate property keys with different values, duplicate keys, or duplicate property values.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
property1=&lt;b&gt;&lt;font color="#000080"&gt;value&lt;/font&gt;&lt;/b&gt;;
property2=&lt;b&gt;&lt;font color="#000080"&gt;value&lt;/font&gt;&lt;/b&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;b&gt;Options&lt;/b&gt; list allows selecting the area in which the inspection should search for duplicates.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousLocalesLanguages" defaultSeverity="WARNING" displayName="Suspicious resource bundle locale languages" enabled="false" language="Properties" pluginId="com.intellij.java-i18n" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports locales with language codes that are not supported by Java.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedProperty" defaultSeverity="WARNING" displayName="Unused property" enabled="true" language="Properties" pluginId="com.intellij.properties" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports all properties that are not referenced from the outside of the .properties file.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="WrongPropertyKeyValueDelimiter" defaultSeverity="WEAK WARNING" displayName="Property key/value delimiter doesn't match code style settings" enabled="true" language="Properties" pluginId="com.intellij.properties" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports properties in which key or value delimiters do not match code style settings.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseEllipsisInPropertyInspection" defaultSeverity="WARNING" displayName="Three dot characters instead of the ellipsis" enabled="false" language="Properties" pluginId="com.intellij.properties" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports three "dot" characters which are used instead of the ellipsis character for UTF-8 properties files.
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Android Lint: Security" path="Android/Lint"><inspection shortName="AndroidLintProxyPassword" defaultSeverity="WARNING" displayName="Proxy Password in Cleartext" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Proxy Password in Cleartext&lt;br&gt;&lt;br&gt;Storing proxy server passwords in clear text is dangerous if this file is shared via version control. If this is deliberate or this is a truly private project, suppress this warning.&lt;br&gt;&lt;br&gt;Issue id: ProxyPassword&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExportedPreferenceActivity" defaultSeverity="WARNING" displayName="PreferenceActivity should not be exported" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;PreferenceActivity should not be exported&lt;br&gt;&lt;br&gt;Fragment injection gives anyone who can send your &lt;code&gt;PreferenceActivity&lt;/code&gt; an intent the ability to load any fragment, with any arguments, in your process.&lt;br&gt;&lt;br&gt;Issue id: ExportedPreferenceActivity&lt;br&gt;&lt;br&gt;&lt;a href="http://securityintelligence.com/new-vulnerability-android-framework-fragment-injection"&gt;http://securityintelligence.com/new-vulnerability-android-framework-fragment-injection&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIntentFilterExportedReceiver" defaultSeverity="WARNING" displayName="Unspecified android:exported in manifest" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unspecified &lt;code&gt;android:exported&lt;/code&gt; in manifest&lt;br&gt;&lt;br&gt;Apps targeting Android 12 and higher are required to specify an explicit value for &lt;code&gt;android:exported&lt;/code&gt; when the corresponding component has an intent filter defined. Otherwise, installation will fail. Set it to &lt;code&gt;true&lt;/code&gt; to make this activity accessible to other apps, and &lt;code&gt;false&lt;/code&gt; to limit it to be used only by this app or the OS. For launch activities, this should be set to true; otherwise, the app will fail to launch.&lt;br/&gt;
&lt;br/&gt;
Previously, &lt;code&gt;android:exported&lt;/code&gt; for components without any intent filters present used to default to &lt;code&gt;false&lt;/code&gt;, and when intent filters were present, the default was &lt;code&gt;true&lt;/code&gt;. Defaults which change value based on other values are confusing and lead to apps accidentally exporting components as a side-effect of adding intent filters. This is a security risk, and we have made this change to avoid introducing accidental vulnerabilities.&lt;br/&gt;
&lt;br/&gt;
While the default without intent filters remains unchanged, it is now required to explicitly specify a value when intent filters are present. Any app failing to meet this requirement will fail to install on any Android version after Android 11.&lt;br/&gt;
&lt;br/&gt;
We recommend setting &lt;code&gt;android:exported&lt;/code&gt; to false (even on previous versions of Android prior to this requirement) unless you have a good reason to export a particular component.&lt;br&gt;&lt;br&gt;Issue id: IntentFilterExportedReceiver&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidPermission" defaultSeverity="ERROR" displayName="Invalid Permission Attribute" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Permission Attribute&lt;br&gt;&lt;br&gt;Not all elements support the permission attribute. If a permission is set on an invalid element, it is a no-op and ignored. Ensure that this permission attribute was set on the correct element to protect the correct component.&lt;br&gt;&lt;br&gt;Issue id: InvalidPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCustomX509TrustManager" defaultSeverity="WARNING" displayName="Implements custom TLS trust manager" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implements custom TLS trust manager&lt;br&gt;&lt;br&gt;This check looks for custom &lt;code&gt;X509TrustManager&lt;/code&gt; implementations.&lt;br&gt;&lt;br&gt;Issue id: CustomX509TrustManager&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeletedProvider" defaultSeverity="ERROR" displayName="Using Deleted Provider" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Deleted Provider&lt;br&gt;&lt;br&gt;The &lt;code&gt;Crypto&lt;/code&gt; provider has been completely removed in Android P (and was deprecated in an earlier release). This means that the code will throw a &lt;code&gt;NoSuchProviderException&lt;/code&gt; and the app will crash. Even if the code catches that exception at a higher level, this is not secure and should not be used.&lt;br&gt;&lt;br&gt;Issue id: DeletedProvider&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html"&gt;https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeDynamicallyLoadedCode" defaultSeverity="WARNING" displayName="load used to dynamically load code" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;load&lt;/code&gt; used to dynamically load code&lt;br&gt;&lt;br&gt;Dynamically loading code from locations other than the application's library directory or the Android platform's built-in library directories is dangerous, as there is an increased risk that the code could have been tampered with. Applications should use &lt;code&gt;loadLibrary&lt;/code&gt; when possible, which provides increased assurance that libraries are loaded from one of these safer locations. Application developers should use the features of their development environment to place application native libraries into the lib directory of their compiled APKs.&lt;br&gt;&lt;br&gt;Issue id: UnsafeDynamicallyLoadedCode&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDataExtractionRules" defaultSeverity="WARNING" displayName="Missing data extraction rules" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing data extraction rules&lt;br&gt;&lt;br&gt;Before Android 12, the attributes &lt;code&gt;android:allowBackup&lt;/code&gt; and &lt;code&gt;android:fullBackupContent&lt;/code&gt; were used to configure all forms of backup, including cloud backups, device-to-device transfers and adb backup.&lt;br/&gt;
&lt;br/&gt;
In Android 12 and higher, these attributes have been deprecated and will only apply to cloud backups. You should instead use the attribute &lt;code&gt;android:dataExtractionRules&lt;/code&gt;, specifying an &lt;code&gt;@xml&lt;/code&gt; resource that configures which files to back up, for cloud backups and for device-to-device transfers, separately. If your &lt;code&gt;minSdkVersion&lt;/code&gt; supports older versions, you'll still want to specify an &lt;code&gt;android:fullBackupContent&lt;/code&gt; resource if the default behavior is not right for your app.&lt;br&gt;&lt;br&gt;Issue id: DataExtractionRules&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/about/versions/12/backup-restore#xml-changes"&gt;https://developer.android.com/about/versions/12/backup-restore#xml-changes&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUsingHttp" defaultSeverity="WARNING" displayName="Using HTTP instead of HTTPS" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using HTTP instead of HTTPS&lt;br&gt;&lt;br&gt;The Gradle Wrapper is available both via HTTP and HTTPS. HTTPS is more secure since it protects against man-in-the-middle attacks etc. Older projects created in Android Studio used HTTP but we now default to HTTPS and recommend upgrading existing projects.&lt;br&gt;&lt;br&gt;Issue id: UsingHttp&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGrantAllUris" defaultSeverity="WARNING" displayName="Content provider shares everything" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Content provider shares everything&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;grant-uri-permission&gt;&lt;/code&gt; element allows specific paths to be shared. This detector checks for a path URL of just '/' (everything), which is probably not what you want; you should limit access to a subset.&lt;br&gt;&lt;br&gt;Issue id: GrantAllUris&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEasterEgg" defaultSeverity="WARNING" displayName="Code contains easter egg" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Code contains easter egg&lt;br&gt;&lt;br&gt;An "easter egg" is code deliberately hidden in the code, both from potential users and even from other developers. This lint check looks for code which looks like it may be hidden from sight.&lt;br&gt;&lt;br&gt;Issue id: EasterEgg&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAddJavascriptInterface" defaultSeverity="WARNING" displayName="addJavascriptInterface Called" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;addJavascriptInterface&lt;/code&gt; Called&lt;br&gt;&lt;br&gt;For applications built for API levels below 17, &lt;code&gt;WebView#addJavascriptInterface&lt;/code&gt; presents a security hazard as JavaScript on the target web page has the ability to use reflection to access the injected object's public fields and thus manipulate the host application in unintended ways.&lt;br&gt;&lt;br&gt;Issue id: AddJavascriptInterface&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface(java.lang.Object,%20java.lang.String)"&gt;https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface(java.lang.Object,%20java.lang.String)&lt;/a&gt;&lt;br&gt;&lt;a href="https://support.google.com/faqs/answer/9095419?hl=en"&gt;https://support.google.com/faqs/answer/9095419?hl=en&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRiskyLibrary" defaultSeverity="WARNING" displayName="Libraries with Privacy or Security Risks" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Libraries with Privacy or Security Risks&lt;br&gt;&lt;br&gt;Your app is using a version of a library that has been identified by the library developer as a potential source of privacy and/or security risks. This may be a violation of Google Play policies (see &lt;a href="https://play.google.com/about/monetization-ads/ads/"&gt;https://play.google.com/about/monetization-ads/ads/&lt;/a&gt;) and/or affect your app&amp;#8217;s visibility on the Play Store.&lt;br/&gt;
&lt;br/&gt;
When available, the individual error messages from lint will include details about the reasons for this advisory.&lt;br/&gt;
&lt;br/&gt;
Please try updating your app with an updated version of this library, or remove it from your app.&lt;br&gt;&lt;br&gt;Issue id: RiskyLibrary&lt;br&gt;&lt;br&gt;&lt;a href="https://play.google.com/sdks"&gt;https://play.google.com/sdks&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintKnownPermissionError" defaultSeverity="ERROR" displayName="Value specified for permission is a known error" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Value specified for permission is a known error&lt;br&gt;&lt;br&gt;This check looks for values specified in component permissions that are known errors, such as &lt;code&gt;android:permission="true"&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
 Please double check the permission value you have supplied. The value is expected to be a  permission string from the system, another app, or your own, NOT a boolean.&lt;br&gt;&lt;br&gt;Issue id: KnownPermissionError&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUsingC2DM" defaultSeverity="ERROR" displayName="Using C2DM" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using C2DM&lt;br&gt;&lt;br&gt;The C2DM library does not work on Android P or newer devices; you should migrate to Firebase Cloud Messaging to ensure reliable message delivery.&lt;br&gt;&lt;br&gt;Issue id: UsingC2DM&lt;br&gt;&lt;br&gt;&lt;a href="https://developers.google.com/cloud-messaging/c2dm"&gt;https://developers.google.com/cloud-messaging/c2dm&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSetJavaScriptEnabled" defaultSeverity="WARNING" displayName="Using setJavaScriptEnabled" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;setJavaScriptEnabled&lt;/code&gt;&lt;br&gt;&lt;br&gt;Your code should not invoke &lt;code&gt;setJavaScriptEnabled&lt;/code&gt; if you are not sure that your app really requires JavaScript support.&lt;br&gt;&lt;br&gt;Issue id: SetJavaScriptEnabled&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/articles/security-tips"&gt;https://developer.android.com/training/articles/security-tips&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTrustAllX509TrustManager" defaultSeverity="WARNING" displayName="Insecure TLS/SSL trust manager" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure TLS/SSL trust manager&lt;br&gt;&lt;br&gt;This check looks for X509TrustManager implementations whose &lt;code&gt;checkServerTrusted&lt;/code&gt; or &lt;code&gt;checkClientTrusted&lt;/code&gt; methods do nothing (thus trusting any certificate chain) which could result in insecure network traffic caused by trusting arbitrary TLS/SSL certificates presented by peers.&lt;br&gt;&lt;br&gt;Issue id: TrustAllX509TrustManager&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeNativeCodeLocation" defaultSeverity="WARNING" displayName="Native code outside library directory" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Native code outside library directory&lt;br&gt;&lt;br&gt;In general, application native code should only be placed in the application's library directory, not in other locations such as the res or assets directories. Placing the code in the library directory provides increased assurance that the code will not be tampered with after application installation. Application developers should use the features of their development environment to place application native libraries into the lib directory of their compiled APKs. Embedding non-shared library native executables into applications should be avoided when possible.&lt;br&gt;&lt;br&gt;Issue id: UnsafeNativeCodeLocation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintReservedSystemPermission" defaultSeverity="ERROR" displayName="Permission name is a reserved Android permission" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission name is a reserved Android permission&lt;br&gt;&lt;br&gt;This check looks for custom permission declarations whose names are reserved values for system or Android SDK permissions, or begin with the reserved string &lt;code&gt;android.&lt;/code&gt;&lt;br/&gt;
&lt;br/&gt;
Please double check the permission name you have supplied. Attempting to redeclare a system or Android SDK permission will be ignored.  Using the prefix &lt;code&gt;android.&lt;/code&gt; is a violation of the Android Compatibility Definition Document.&lt;br&gt;&lt;br&gt;Issue id: ReservedSystemPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHardcodedDebugMode" defaultSeverity="ERROR" displayName="Hardcoded value of android:debuggable in the manifest" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardcoded value of &lt;code&gt;android:debuggable&lt;/code&gt; in the manifest&lt;br&gt;&lt;br&gt;It's best to leave out the &lt;code&gt;android:debuggable&lt;/code&gt; attribute from the manifest. If you do, then the tools will automatically insert &lt;code&gt;android:debuggable=true&lt;/code&gt; when building an APK to debug on an emulator or device. And when you perform a release build, such as Exporting APK, it will automatically set it to &lt;code&gt;false&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If on the other hand you specify a specific value in the manifest file, then the tools will always use it. This can lead to accidentally publishing your app with debug information.&lt;br&gt;&lt;br&gt;Issue id: HardcodedDebugMode&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExportedService" defaultSeverity="WARNING" displayName="Exported service does not require permission" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Exported service does not require permission&lt;br&gt;&lt;br&gt;Exported services (services which either set &lt;code&gt;exported=true&lt;/code&gt; or contain an intent-filter and do not specify &lt;code&gt;exported=false&lt;/code&gt;) should define a permission that an entity must have in order to launch the service or bind to it. Without this, any application can use this service.&lt;br&gt;&lt;br&gt;Issue id: ExportedService&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExportedContentProvider" defaultSeverity="WARNING" displayName="Content provider does not require permission" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Content provider does not require permission&lt;br&gt;&lt;br&gt;Content providers are exported by default and any application on the system can potentially use them to read and write data. If the content provider provides access to sensitive data, it should be protected by specifying &lt;code&gt;export=false&lt;/code&gt; in the manifest or by protecting it with a permission that can be granted to other applications.&lt;br&gt;&lt;br&gt;Issue id: ExportedContentProvider&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeprecatedProvider" defaultSeverity="WARNING" displayName="Using BC Provider" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using BC Provider&lt;br&gt;&lt;br&gt;The &lt;code&gt;BC&lt;/code&gt; provider has been deprecated and will not be provided when &lt;code&gt;targetSdkVersion&lt;/code&gt; is P or higher.&lt;br&gt;&lt;br&gt;Issue id: DeprecatedProvider&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html"&gt;https://android-developers.googleblog.com/2018/03/cryptography-changes-in-android-p.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExportedReceiver" defaultSeverity="WARNING" displayName="Receiver does not require permission" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Receiver does not require permission&lt;br&gt;&lt;br&gt;Exported receivers (receivers which either set &lt;code&gt;exported=true&lt;/code&gt; or contain an intent-filter and do not specify &lt;code&gt;exported=false&lt;/code&gt;) should define a permission that an entity must have in order to launch the receiver or bind to it. Without this, any application can use this receiver.&lt;br&gt;&lt;br&gt;Issue id: ExportedReceiver&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSSLCertificateSocketFactoryCreateSocket" defaultSeverity="WARNING" displayName="Insecure call to SSLCertificateSocketFactory.createSocket()" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure call to &lt;code&gt;SSLCertificateSocketFactory.createSocket()&lt;/code&gt;&lt;br&gt;&lt;br&gt;When &lt;code&gt;SSLCertificateSocketFactory.createSocket()&lt;/code&gt; is called with an &lt;code&gt;InetAddress&lt;/code&gt; as the first parameter, TLS/SSL hostname verification is not performed, which could result in insecure network traffic caused by trusting arbitrary hostnames in TLS/SSL certificates presented by peers. In this case, developers must ensure that the &lt;code&gt;InetAddress&lt;/code&gt; is explicitly verified against the certificate through other means, such as by calling `SSLCertificateSocketFactory.getDefaultHostnameVerifier() to get a &lt;code&gt;HostnameVerifier&lt;/code&gt; and calling &lt;code&gt;HostnameVerifier.verify()&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: SSLCertificateSocketFactoryCreateSocket&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPermissionNamingConvention" defaultSeverity="WARNING" displayName="Permission name does not follow recommended convention" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission name does not follow recommended convention&lt;br&gt;&lt;br&gt;Permissions should be prefixed with an app's package name, using reverse-domain-style naming. This prefix should be followed by &lt;code&gt;.permission.&lt;/code&gt;, and then a description of the capability that the permission represents, in upper SNAKE_CASE. For example, &lt;code&gt;com.example.myapp.permission.ENGAGE_HYPERSPACE&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Following this recommendation avoids naming collisions, and helps clearly identify the owner and intention of a custom permission.&lt;br&gt;&lt;br&gt;Issue id: PermissionNamingConvention&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSetWorldReadable" defaultSeverity="WARNING" displayName="File.setReadable() used to make file world-readable" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;File.setReadable()&lt;/code&gt; used to make file world-readable&lt;br&gt;&lt;br&gt;Setting files world-readable is very dangerous, and likely to cause security holes in applications. It is strongly discouraged; instead, applications should use more formal mechanisms for interactions such as &lt;code&gt;ContentProvider&lt;/code&gt;, &lt;code&gt;BroadcastReceiver&lt;/code&gt;, and &lt;code&gt;Service&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: SetWorldReadable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSetWorldWritable" defaultSeverity="WARNING" displayName="File.setWritable() used to make file world-writable" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;File.setWritable()&lt;/code&gt; used to make file world-writable&lt;br&gt;&lt;br&gt;Setting files world-writable is very dangerous, and likely to cause security holes in applications. It is strongly discouraged; instead, applications should use more formal mechanisms for interactions such as &lt;code&gt;ContentProvider&lt;/code&gt;, &lt;code&gt;BroadcastReceiver&lt;/code&gt;, and &lt;code&gt;Service&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: SetWorldWritable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintJavascriptInterface" defaultSeverity="ERROR" displayName="Missing @JavascriptInterface on methods" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing @JavascriptInterface on methods&lt;br&gt;&lt;br&gt;As of API 17, you must annotate methods in objects registered with the &lt;code&gt;addJavascriptInterface&lt;/code&gt; method with a &lt;code&gt;@JavascriptInterface&lt;/code&gt; annotation.&lt;br&gt;&lt;br&gt;Issue id: JavascriptInterface&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface(java.lang.Object, java.lang.String)"&gt;https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface(java.lang.Object, java.lang.String)&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSignatureOrSystemPermissions" defaultSeverity="WARNING" displayName="Declaring signatureOrSystem permissions" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Declaring signatureOrSystem permissions&lt;br&gt;&lt;br&gt;The &lt;code&gt;signature&lt;/code&gt; protection level should probably be sufficient for most needs and works regardless of where applications are installed. The &lt;code&gt;signatureOrSystem&lt;/code&gt; level is used for certain situations where multiple vendors have applications built into a system image and need to share specific features explicitly because they are being built together.&lt;br&gt;&lt;br&gt;Issue id: SignatureOrSystemPermissions&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWorldWriteableFiles" defaultSeverity="WARNING" displayName="openFileOutput() with MODE_WORLD_WRITEABLE" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;openFileOutput()&lt;/code&gt; with &lt;code&gt;MODE_WORLD_WRITEABLE&lt;/code&gt;&lt;br&gt;&lt;br&gt;There are cases where it is appropriate for an application to write world writeable files, but these should be reviewed carefully to ensure that they contain no private data, and that if the file is modified by a malicious application it does not trick or compromise your application.&lt;br&gt;&lt;br&gt;Issue id: WorldWriteableFiles&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBidiSpoofing" defaultSeverity="ERROR" displayName="Bidirectional text spoofing" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Bidirectional text spoofing&lt;br&gt;&lt;br&gt;Unicode bidirectional text characters can alter the order in which the compiler processes tokens. However, this can also be used to hide malicious code, and can be difficult to spot. This lint check audits the source code and looks for cases where it looks like bidirectional text has the potential to be misleading.&lt;br&gt;&lt;br&gt;Issue id: BidiSpoofing&lt;br&gt;&lt;br&gt;&lt;a href="https://krebsonsecurity.com/2021/11/trojan-source-bug-threatens-the-security-of-all-code/"&gt;https://krebsonsecurity.com/2021/11/trojan-source-bug-threatens-the-security-of-all-code/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsafeProtectedBroadcastReceiver" defaultSeverity="WARNING" displayName="Unsafe Protected BroadcastReceiver" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsafe Protected &lt;code&gt;BroadcastReceiver&lt;/code&gt;&lt;br&gt;&lt;br&gt;`BroadcastReceiver`s that declare an intent-filter for a protected-broadcast action string must check that the received intent's action string matches the expected value, otherwise it is possible for malicious actors to spoof intents.&lt;br&gt;&lt;br&gt;Issue id: UnsafeProtectedBroadcastReceiver&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCustomPermissionTypo" defaultSeverity="WARNING" displayName="Permission appears to be a custom permission with a typo" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission appears to be a custom permission with a typo&lt;br&gt;&lt;br&gt;This check looks for required permissions that &lt;i&gt;look&lt;/i&gt; like custom permissions defined in the same manifest, but aren't, and may be typos.&lt;br/&gt;
&lt;br/&gt;
Please double check the permission value you have supplied.&lt;br&gt;&lt;br&gt;Issue id: CustomPermissionTypo&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBadHostnameVerifier" defaultSeverity="WARNING" displayName="Insecure HostnameVerifier" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure HostnameVerifier&lt;br&gt;&lt;br&gt;This check looks for implementations of &lt;code&gt;HostnameVerifier&lt;/code&gt; whose &lt;code&gt;verify&lt;/code&gt; method always returns true (thus trusting any hostname) which could result in insecure network traffic caused by trusting arbitrary hostnames in TLS/SSL certificates presented by peers.&lt;br&gt;&lt;br&gt;Issue id: BadHostnameVerifier&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHardwareIds" defaultSeverity="WARNING" displayName="Hardware Id Usage" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardware Id Usage&lt;br&gt;&lt;br&gt;Using these device identifiers is not recommended other than for high value fraud prevention and advanced telephony use-cases. For advertising use-cases, use &lt;code&gt;AdvertisingIdClient$Info#getId&lt;/code&gt; and for analytics, use &lt;code&gt;InstanceId#getId&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: HardwareIds&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/articles/user-data-ids.html"&gt;https://developer.android.com/training/articles/user-data-ids.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSecureRandom" defaultSeverity="WARNING" displayName="Using a fixed seed with SecureRandom" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using a fixed seed with &lt;code&gt;SecureRandom&lt;/code&gt;&lt;br&gt;&lt;br&gt;Specifying a fixed seed will cause the instance to return a predictable sequence of numbers. This may be useful for testing but it is not appropriate for secure use.&lt;br&gt;&lt;br&gt;Issue id: SecureRandom&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/security/SecureRandom.html"&gt;https://developer.android.com/reference/java/security/SecureRandom.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseCheckPermission" defaultSeverity="WARNING" displayName="Using the result of check permission calls" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using the result of check permission calls&lt;br&gt;&lt;br&gt;You normally want to use the result of checking a permission; these methods return whether the permission is held; they do not throw an error if the permission is not granted. Code which does not do anything with the return value probably meant to be calling the enforce methods instead, e.g. rather than &lt;code&gt;Context#checkCallingPermission&lt;/code&gt; it should call &lt;code&gt;Context#enforceCallingPermission&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: UseCheckPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAllowAllHostnameVerifier" defaultSeverity="WARNING" displayName="Insecure HostnameVerifier" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure &lt;code&gt;HostnameVerifier&lt;/code&gt;&lt;br&gt;&lt;br&gt;This check looks for use of HostnameVerifier implementations whose &lt;code&gt;verify&lt;/code&gt; method always returns true (thus trusting any hostname) which could result in insecure network traffic caused by trusting arbitrary hostnames in TLS/SSL certificates presented by peers.&lt;br&gt;&lt;br&gt;Issue id: AllowAllHostnameVerifier&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAcceptsUserCertificates" defaultSeverity="WARNING" displayName="Allowing User Certificates" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Allowing User Certificates&lt;br&gt;&lt;br&gt;Allowing user certificates could allow eavesdroppers to intercept data sent by your app, 'which could impact the privacy of your users. Consider nesting your app's &lt;code&gt;trust-anchors&lt;/code&gt; inside a &lt;code&gt;&amp;lt;debug-overrides&gt;&lt;/code&gt; element to make sure they are only available when &lt;code&gt;android:debuggable&lt;/code&gt; is set to &lt;code&gt;"true"&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AcceptsUserCertificates&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/articles/security-config#TrustingDebugCa"&gt;https://developer.android.com/training/articles/security-config#TrustingDebugCa&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPackageManagerGetSignatures" defaultSeverity="WARNING" displayName="Potential Multiple Certificate Exploit" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Potential Multiple Certificate Exploit&lt;br&gt;&lt;br&gt;Improper validation of app signatures could lead to issues where a malicious app submits itself to the Play Store with both its real certificate and a fake certificate and gains access to functionality or information it shouldn't have due to another application only checking for the fake certificate and ignoring the rest. Please make sure to validate all signatures returned by this method.&lt;br&gt;&lt;br&gt;Issue id: PackageManagerGetSignatures&lt;br&gt;&lt;br&gt;&lt;a href="https://bluebox.com/technical/android-fake-id-vulnerability/"&gt;https://bluebox.com/technical/android-fake-id-vulnerability/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWebViewClientOnReceivedSslError" defaultSeverity="WARNING" displayName="Proceeds with the HTTPS connection despite SSL errors" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Proceeds with the HTTPS connection despite SSL errors&lt;br&gt;&lt;br&gt;This check looks for &lt;code&gt;onReceivedSslError&lt;/code&gt; implementations that invoke &lt;code&gt;SslErrorHandler#proceed&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: WebViewClientOnReceivedSslError&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInsecureBaseConfiguration" defaultSeverity="WARNING" displayName="Insecure Base Configuration" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Insecure Base Configuration&lt;br&gt;&lt;br&gt;Permitting cleartext traffic could allow eavesdroppers to intercept data sent by your app, which impacts the privacy of your users. Consider only allowing encrypted traffic by setting the &lt;code&gt;cleartextTrafficPermitted&lt;/code&gt; tag to &lt;code&gt;"false"&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InsecureBaseConfiguration&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/features/security-config.html"&gt;https://developer.android.com/preview/features/security-config.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGetInstance" defaultSeverity="WARNING" displayName="Cipher.getInstance with ECB" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Cipher.getInstance with ECB&lt;br&gt;&lt;br&gt;&lt;code&gt;Cipher#getInstance&lt;/code&gt; should not be called with ECB as the cipher mode or without setting the cipher mode because the default mode on android is ECB, which is insecure.&lt;br&gt;&lt;br&gt;Issue id: GetInstance&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWorldReadableFiles" defaultSeverity="WARNING" displayName="openFileOutput() with MODE_WORLD_READABLE" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;openFileOutput()&lt;/code&gt; with &lt;code&gt;MODE_WORLD_READABLE&lt;/code&gt;&lt;br&gt;&lt;br&gt;There are cases where it is appropriate for an application to write world readable files, but these should be reviewed carefully to ensure that they contain no private data that is leaked to other applications.&lt;br&gt;&lt;br&gt;Issue id: WorldReadableFiles&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAuthLeak" defaultSeverity="WARNING" displayName="Code might contain an auth leak" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Code might contain an auth leak&lt;br&gt;&lt;br&gt;Strings in java apps can be discovered by decompiling apps, this lint check looks for code which looks like it may contain an url with a username and password&lt;br&gt;&lt;br&gt;Issue id: AuthLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSystemPermissionTypo" defaultSeverity="WARNING" displayName="Permission appears to be a standard permission with a typo" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission appears to be a standard permission with a typo&lt;br&gt;&lt;br&gt;This check looks for required permissions that &lt;i&gt;look&lt;/i&gt; like well-known system permissions or permissions from the Android SDK, but aren't, and may be typos.&lt;br/&gt;
&lt;br/&gt;
Please double check the permission value you have supplied.&lt;br&gt;&lt;br&gt;Issue id: SystemPermissionTypo&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnprotectedSMSBroadcastReceiver" defaultSeverity="WARNING" displayName="Unprotected SMS BroadcastReceiver" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unprotected SMS &lt;code&gt;BroadcastReceiver&lt;/code&gt;&lt;br&gt;&lt;br&gt;BroadcastReceivers that declare an intent-filter for &lt;code&gt;SMS_DELIVER&lt;/code&gt; or &lt;code&gt;SMS_RECEIVED&lt;/code&gt; must ensure that the caller has the &lt;code&gt;BROADCAST_SMS&lt;/code&gt; permission, otherwise it is possible for malicious actors to spoof intents.&lt;br&gt;&lt;br&gt;Issue id: UnprotectedSMSBroadcastReceiver&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTileProviderPermissions" defaultSeverity="WARNING" displayName="TileProvider should declare BIND_TILE_PROVIDER permission" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TileProvider does not set permission&lt;br&gt;&lt;br&gt;TileProviders should require the &lt;code&gt;com.google.android.wearable.permission.BIND_TILE_PROVIDER&lt;/code&gt; permission to prevent arbitrary apps from binding to it.&lt;br&gt;&lt;br&gt;Issue id: TileProviderPermissions&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnspecifiedImmutableFlag" defaultSeverity="WARNING" displayName="Missing PendingIntent mutability flag" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;PendingIntent&lt;/code&gt; mutability flag&lt;br&gt;&lt;br&gt;Apps targeting Android 12 and higher must specify either &lt;code&gt;FLAG_IMMUTABLE&lt;/code&gt; or &lt;code&gt;FLAG_MUTABLE&lt;/code&gt; when constructing a &lt;code&gt;PendingIntent&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: UnspecifiedImmutableFlag&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/about/versions/12/behavior-changes-12#pending-intent-mutability"&gt;https://developer.android.com/about/versions/12/behavior-changes-12#pending-intent-mutability&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPackagedPrivateKey" defaultSeverity="ERROR" displayName="Packaged private key" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Packaged private key&lt;br&gt;&lt;br&gt;In general, you should not package private key files inside your app.&lt;br&gt;&lt;br&gt;Issue id: PackagedPrivateKey&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSSLCertificateSocketFactoryGetInsecure" defaultSeverity="WARNING" displayName="Call to SSLCertificateSocketFactory.getInsecure()" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Call to &lt;code&gt;SSLCertificateSocketFactory.getInsecure()&lt;/code&gt;&lt;br&gt;&lt;br&gt;The &lt;code&gt;SSLCertificateSocketFactory.getInsecure()&lt;/code&gt; method returns an SSLSocketFactory with all TLS/SSL security checks disabled, which could result in insecure network traffic caused by trusting arbitrary TLS/SSL certificates presented by peers. This method should be avoided unless needed for a special circumstance such as debugging. Instead, &lt;code&gt;SSLCertificateSocketFactory.getDefault()&lt;/code&gt; should be used.&lt;br&gt;&lt;br&gt;Issue id: SSLCertificateSocketFactoryGetInsecure&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Class" path="Java/Naming conventions"><inspection shortName="ClassNameSameAsAncestorName" defaultSeverity="WARNING" displayName="Class name same as ancestor name" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that have the same name as one of their superclasses, while their fully qualified names remain different.
Such class names may be very confusing.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;
  package util;
  abstract class Iterable&amp;lt;T&amp;gt; implements java.lang.Iterable&amp;lt;T&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix that renames such classes is available only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassNamePrefixedWithPackageName" defaultSeverity="WARNING" displayName="Class name prefixed with package name" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes whose names are prefixed with their package names, ignoring differences in
capitalization.
&lt;p&gt;While occasionally having such names is reasonable, they are often used due to a poor naming scheme, may be redundant and
  annoying.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
  &lt;pre&gt;&lt;code&gt;
  package byteCode;
  class ByteCodeAnalyzer {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix that renames such classes is available only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExceptionNameDoesntEndWithException" defaultSeverity="WARNING" displayName="Exception class name does not end with 'Exception'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports exception classes whose names don't end with &lt;code&gt;Exception&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;class NotStartedEx extends Exception {}&lt;/code&gt;
&lt;p&gt;A quick-fix that renames such classes is available only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NewClassNamingConvention" defaultSeverity="WARNING" displayName="Class naming convention" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes whose names are too short, too long, or do not follow
the specified regular expression pattern.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt; if the inspection is enabled for tests, and the specified length for the minimum class name is 8 (the default), the following test class
   produces a warning because the length of its name is 6, which is less than 8: &lt;code&gt;public class MyTest{}&lt;/code&gt;.
&lt;p&gt;A quick-fix that renames such classes is available only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;
  Use the list in the &lt;b&gt;Options&lt;/b&gt; section to specify which classes should be checked. Deselect the checkboxes for the classes for which
  you want to skip the check.&lt;/p&gt;
&lt;p&gt;For each class type, specify the minimum length, maximum length, and the regular expression expected for class names using the
  provided input fields. Specify &lt;b&gt;0&lt;/b&gt; in the length fields to skip corresponding checks.&lt;/p&gt;
&lt;p&gt;Regular expressions should be specified in the standard &lt;code&gt;java.util.regex&lt;/code&gt; format.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonExceptionNameEndsWithException" defaultSeverity="WARNING" displayName="Non-exception class name ends with 'Exception'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-&lt;code&gt;exception&lt;/code&gt; classes whose names end with &lt;code&gt;Exception&lt;/code&gt;.
&lt;p&gt;Such classes may cause confusion by breaking a common naming convention and
  often indicate that the &lt;code&gt;extends Exception&lt;/code&gt; clause is missing.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
  &lt;pre&gt;&lt;code&gt;public class NotStartedException {}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix that renames such classes is available only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 7" path="Java/Java language level migration aids"><inspection shortName="TryWithIdenticalCatches" defaultSeverity="WARNING" displayName="Identical 'catch' branches in 'try' statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports identical &lt;code&gt;catch&lt;/code&gt; sections in a single &lt;code&gt;try&lt;/code&gt; statement.
&lt;p&gt;Collapsing such sections into one &lt;i&gt;multi-catch&lt;/i&gt; block reduces code duplication and prevents
  the situations when one &lt;code&gt;catch&lt;/code&gt; section is updated, and another one is not.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    try {
        doSmth();
    }
    catch (IOException e) {
        LOG.error(e);
    }
    catch (URISyntaxException e) {
        LOG.error(e);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix is available to make the code more compact:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    try {
        doSmth();
    }
    catch (IOException | URISyntaxException e) {
        LOG.error(e);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 7 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TryFinallyCanBeTryWithResources" defaultSeverity="WARNING" displayName="'try finally' can be replaced with 'try' with resources" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;finally&lt;/code&gt; statements that can use Java 7 Automatic Resource Management,
which is less error-prone.
&lt;p&gt;A quick-fix is available to convert a &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;finally&lt;/code&gt;
  statement into a &lt;code&gt;try&lt;/code&gt;-with-resources statement.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  PrintStream printStream = new PrintStream(fileName);
  try {
    printStream.print(true);
  } finally {
    printStream.close();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix is provided to pass the cause to a constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try (PrintStream printStream = new PrintStream(fileName)) {
    printStream.print(true);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 7 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Convert2Diamond" defaultSeverity="WARNING" displayName="Explicit type can be replaced with '&lt;&gt;'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports all &lt;code&gt;new&lt;/code&gt; expressions with type arguments that can be replaced a with diamond type &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); // reports array list type argument
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 7 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EqualsReplaceableByObjectsCall" defaultSeverity="WEAK WARNING" displayName="'equals()' expression replaceable by 'Objects.equals()' expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports expressions that can be replaced with a call to &lt;code&gt;java.util.Objects#equals&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(Object a, Object b) {
    boolean result = a != null &amp;&amp; a.equals(b);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(Object a, Object b) {
    boolean result = Objects.equals(a, b);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Replacing expressions like &lt;code&gt;a != null &amp;&amp; a.equals(b)&lt;/code&gt; with &lt;code&gt;Objects.equals(a, b)&lt;/code&gt;
  slightly changes the semantics. Use the &lt;b&gt;Highlight expressions like 'a != null &amp;&amp; a.equals(b)'&lt;/b&gt; option to enable or disable this behavior.
&lt;/p&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 7 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SafeVarargsDetector" defaultSeverity="WARNING" displayName="Possible heap pollution from parameterized vararg type" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports all methods with variable arity, which can be annotated as &lt;code&gt;@SafeVarargs&lt;/code&gt;.
The &lt;code&gt;@SafeVarargs&lt;/code&gt; annotation suppresses unchecked warnings about parameterized array creation at call sites.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo&amp;lt;T&amp;gt; {
    private List&amp;lt;T&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    public final void safeVarargs(T... elements) {
      Collections.addAll(list, elements);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo&amp;lt;T&amp;gt; {
    private List&amp;lt;T&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    @SafeVarargs
    public final void safeVarargs(T... elements) {
      Collections.addAll(list, elements);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  This annotation is not supported under Java 1.6 or earlier JVMs.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Error handling" path="Groovy"><inspection shortName="GroovyContinueOrBreakFromFinallyBlock" defaultSeverity="WARNING" displayName="'continue' or 'break' from 'finally' block" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; statements inside of &lt;code&gt;finally&lt;/code&gt; blocks.
&lt;p&gt;While occasionally intended, such statements are very confusing, may mask thrown exceptions, and tremendously complicate debugging.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUnusedCatchParameter" defaultSeverity="WARNING" displayName="Unused 'catch' parameter" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports &lt;b&gt;catch&lt;/b&gt; parameters that are unused in their
corresponding blocks. This inspection will not report any &lt;b&gt;catch&lt;/b&gt; parameters
named "ignore" or "ignored".&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      def arr = new int[3]
      arr[5] = 5
  } catch(Exception &lt;b&gt;ex&lt;/b&gt;) {
      println('Catching the exception')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the parameter &lt;b&gt;ex&lt;/b&gt; is never used in &lt;b&gt;catch&lt;/b&gt; block.
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      def arr = new int[3]
      arr[5] = 5
  } catch(Exception &lt;b&gt;ignored&lt;/b&gt;) {
      println('Catching the exception')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyEmptyFinallyBlock" defaultSeverity="WARNING" displayName="Empty 'finally' block" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports empty &lt;code&gt;finally&lt;/code&gt; blocks.
Empty &lt;code&gt;finally&lt;/code&gt; blocks usually indicate coding errors.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
try {
  throw new Exception()
}
finally {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyReturnFromFinallyBlock" defaultSeverity="WARNING" displayName="'return' inside 'finally' block" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;return&lt;/code&gt; statements inside of &lt;code&gt;finally&lt;/code&gt; blocks.
&lt;p&gt;
  While occasionally intended, such &lt;code&gt;return&lt;/code&gt; statements may mask exceptions thrown, and
  complicate debugging.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyEmptyTryBlock" defaultSeverity="WARNING" displayName="Empty 'try' block" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports empty &lt;code&gt;try&lt;/code&gt; blocks.
Empty &lt;code&gt;try&lt;/code&gt; blocks usually indicate coding errors.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
try {
}
finally {
  close()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyThrowFromFinallyBlock" defaultSeverity="WARNING" displayName="'throw' inside 'finally' block" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;throw&lt;/code&gt; statements inside of &lt;code&gt;finally&lt;/code&gt; blocks.
&lt;p&gt;
  While occasionally intended, such &lt;code&gt;throw&lt;/code&gt; statements may mask exceptions thrown and
  tremendously complicate debugging.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyEmptyCatchBlock" defaultSeverity="WARNING" displayName="Empty 'catch' block" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports empty &lt;code&gt;catch&lt;/code&gt; blocks. While occasionally intended,
empty &lt;code&gt;catch&lt;/code&gt; blocks can make debugging extremely difficult.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
try {
  throw new Exception()
}
catch (Exception e) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
try {
  throw new Exception()
}
catch (Exception ignored) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Plugin descriptor" path="Plugin DevKit"><inspection shortName="PluginXmlCapitalization" defaultSeverity="WARNING" displayName="Plugin.xml text capitalization" enabled="true" language="XML" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports text capitalization problems in &lt;code&gt;plugin.xml&lt;/code&gt;.
&lt;p&gt;
  The following elements are checked:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;name&gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;action&gt;, &amp;lt;group&gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;separator, &amp;lt;synonym&gt;, &amp;lt;override-text&gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;extension point properties annotated with &lt;code&gt;org.jetbrains.annotations.Nls&lt;/code&gt; specifying required &lt;code&gt;capitalization&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  Please see &lt;a href="https://jetbrains.design/intellij/text/capitalization/"&gt;Capitalization&lt;/a&gt; in IntelliJ Platform UI Guidelines for more
  information.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PluginXmlDynamicPlugin" defaultSeverity="WARNING" displayName="Plugin.xml dynamic plugin verification" enabled="false" language="XML" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports dynamic plugin problems.
&lt;p&gt;
  Dynamic plugins can be installed, updated and uninstalled without restarting the IDE (supported in 2020.1 and later).
&lt;/p&gt;
&lt;p&gt;
  Please see &lt;a href="https://plugins.jetbrains.com/docs/intellij/dynamic-plugins.html?from=PluginXmlDynamicPlugin"&gt;Dynamic Plugins&lt;/a&gt; for further reference.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2020.1&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PluginXmlI18n" defaultSeverity="WARNING" displayName="Plugin.xml i18n verification" enabled="false" language="XML" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports hardcoded texts in &lt;code&gt;plugin.xml&lt;/code&gt;.
&lt;p&gt;
  Using texts defined in resource bundles allows supporting multiple languages in the IDE.
&lt;/p&gt;
&lt;p&gt;
  The following elements are checked:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;action&gt;, &amp;lt;group&gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;lt;separator, &amp;lt;override-text&gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;known extension points having &lt;code&gt;bundle/key&lt;/code&gt; alternative&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PluginXmlValidity" defaultSeverity="ERROR" displayName="Plugin.xml validity" enabled="true" language="XML" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports problems in &lt;code&gt;plugin.xml&lt;/code&gt;.
&lt;p&gt;
  Invalid configuration can lead to problems at runtime.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InspectionMappingConsistency" defaultSeverity="WARNING" displayName="&lt;inspection&gt; tag consistency" enabled="true" language="XML" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports problems for inspection extension point registration in &lt;code&gt;plugin.xml&lt;/code&gt;.
&lt;p&gt;
  Inspection (group) name must be defined using respective attributes for proper presentation in IDE.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 11" path="Java/Java language level migration aids"><inspection shortName="ReadWriteStringCanBeUsed" defaultSeverity="WARNING" displayName="'Files.readString()' or 'Files.writeString()' can be used" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code fragments that read or write a &lt;code&gt;String&lt;/code&gt; as bytes using &lt;code&gt;java.nio.file.Files&lt;/code&gt;.
&lt;p&gt;These fragments can be replaced with calls to the &lt;code&gt;Files.readString()&lt;/code&gt; and &lt;code&gt;Files.writeString()&lt;/code&gt; methods introduced in Java 11.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "example";
  Files.write(Paths.get("out.txt"), s.getBytes(StandardCharsets.UTF_8), StandardOpenOption.WRITE);
  s = new String(Files.readAllBytes(Paths.get("in.txt")), StandardCharsets.ISO_8859_1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "example";
  Files.writeString(Paths.get("out.txt"), s, StandardOpenOption.WRITE);
  s = Files.readString(Paths.get("in.txt"), StandardCharsets.ISO_8859_1);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringRepeatCanBeUsed" defaultSeverity="WARNING" displayName="String.repeat() can be used" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports loops that can be replaced with a single &lt;code&gt;String.repeat()&lt;/code&gt; method (available since Java 11).
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void append(StringBuilder sb, int count, Object obj) {
    for (int i = 0; i &amp;lt; count; i++) {
      sb.append(obj);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void append(StringBuilder sb, int count, Object obj) {
    sb.append(String.valueOf(obj).repeat(Math.max(0, count)));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  By default, the inspection may wrap &lt;code&gt;count&lt;/code&gt; with &lt;code&gt;Math.max(0, count)&lt;/code&gt; if it cannot prove statically that &lt;code&gt;count&lt;/code&gt; is
  not negative. This is done to prevent possible semantics change, as &lt;code&gt;String.repeat()&lt;/code&gt; rejects negative numbers.
  Use the &lt;b&gt;Add Math.max(0,count) to avoid possible semantics change&lt;/b&gt; option to disable this behavior if required.&lt;/p&gt;
  &lt;p&gt;Similarly, a string you want to repeat can be wrapped in
  &lt;code&gt;String.valueOf&lt;/code&gt; to prevent possible &lt;code&gt;NullPointerException&lt;/code&gt; if it's unknown whether it can be &lt;code&gt;null&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 11 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2019.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Methods" path="Objective-C"><inspection shortName="MethodIsLaterInTheScope" defaultSeverity="WARNING" displayName="Method declaration is later in the scope" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the methods that are used before they are declared.&lt;br&gt;
  The purpose is to ensure compatibility with the compilers that require methods to be declared before their usage.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssociatedTypeMismatch" defaultSeverity="WARNING" displayName="Associated type mismatch" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the methods with different return or parameter types in their interface and implementation.
  It also reports the setters and getters that take/return the type different from the type of the corresponding property.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodParameterCountMismatch" defaultSeverity="WARNING" displayName="Method parameter count mismatch" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the calls to the methods that have the wrong number of arguments.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverriddenTypeMismatch" defaultSeverity="WARNING" displayName="Overridden type mismatch" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the overridden methods (the methods with the same selector in the overridden classes) that have parameter or
return types different from the base method's types. The return type is &lt;code&gt;covariant&lt;/code&gt;, which means that the overridden method can return any subtype of the base method's return type.
Parameter types are &lt;code&gt;contravariant&lt;/code&gt;, which means that the overridden method can have parameters of any superclass of the base method's parameter types. Covariance and
 contravariance are applicable only to object types.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LastArgumentMustBeNull" defaultSeverity="WARNING" displayName="Last argument must be null" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the send message expressions where the message has the &lt;code&gt;NS_REQUIRES_NIL_TERMINATION&lt;/code&gt; attribute, and the last argument is not &lt;code&gt;nil&lt;/code&gt;.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Unused code" path="C/C++"><inspection shortName="OCUnusedTemplateParameter" defaultSeverity="WARNING" displayName="Unused template parameter" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the template parameters that are never used and can be removed safely.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OCUnusedStruct" defaultSeverity="WARNING" displayName="Unused struct" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the classes and structures that are never used and can be removed safely.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OCUnusedConcept" defaultSeverity="WARNING" displayName="Unused concept" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the concepts that are never used and can be removed safely.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OCUnusedGlobalDeclaration" defaultSeverity="WARNING" displayName="Unused global declaration" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the global function and variable declarations that are never used and can be removed safely.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OCUnusedTypeAlias" defaultSeverity="WARNING" displayName="Unused type alias" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the statements that are never used and can be removed safely.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OCUnusedIncludeDirective" defaultSeverity="WARNING" displayName="Unused include directive" enabled="false" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the include directives that are not used or not required and can be removed safely.
&lt;dl&gt;
  &lt;dt&gt;&lt;b&gt;Detect completely unused&lt;/b&gt;&lt;/dt&gt;
  &lt;dd&gt;An include directive is considered unused if declarations from it are never used within the translation unit.&lt;/dd&gt;
  &lt;dt&gt;&lt;b&gt;Detect not directly used&lt;/b&gt;&lt;/dt&gt;
  &lt;dd&gt;An include directive is considered unused if declarations from it are not used in the file directly. This works best with the "Include What You Use" policy.&lt;/dd&gt;
  &lt;dt&gt;&lt;b&gt;Detect not required&lt;/b&gt;&lt;/dt&gt;
  &lt;dd&gt;Detects the minimal set of include directives for the file to be compilable. All other #include directives are considered unused.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Use the checkbox below to run inspection in header files.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OCUnusedMacro" defaultSeverity="WARNING" displayName="Unused macro" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the macro definitions that are never used and can be removed safely.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedExpressionResult" defaultSeverity="WARNING" displayName="Unused expression result" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the expressions with unused results.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="RELAX NG" path=""><inspection shortName="UnusedDefine" defaultSeverity="WARNING" displayName="Unused define" enabled="false" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unused named pattern (&lt;code&gt;define&lt;/code&gt;) in a RELAX-NG file (XML or Compact Syntax).
&lt;code&gt;define&lt;/code&gt; elements that are used through an include in another file are ignored.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnresolvedReference" defaultSeverity="ERROR" displayName="Unresolved reference" enabled="true" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unresolved reference to a named pattern (&lt;code&gt;define&lt;/code&gt;) in RELAX-NG files that use XML syntax.
Suggests creating the referenced &lt;code&gt;define&lt;/code&gt; element.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Reflective access" path="Java"><inspection shortName="Java9ReflectionClassVisibility" defaultSeverity="WARNING" displayName="Reflective access across modules issues" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Class.forName()&lt;/code&gt; and &lt;code&gt;ClassLoader.loadClass()&lt;/code&gt; calls
which try to access classes that aren't visible in the current scope due to Java 9 module accessibility rules.
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 9 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaLangInvokeHandleSignature" defaultSeverity="WARNING" displayName="MethodHandle/VarHandle type mismatch" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;MethodHandle&lt;/code&gt; and &lt;code&gt;VarHandle&lt;/code&gt; factory method calls that don't match any method or field.
&lt;p&gt;Also reports arguments to &lt;code&gt;MethodHandle.invoke()&lt;/code&gt; and similar methods, that don't match the &lt;code&gt;MethodHandle&lt;/code&gt; signature
  and arguments to &lt;code&gt;VarHandle.set()&lt;/code&gt; that don't match the &lt;code&gt;VarHandle&lt;/code&gt; type.
  &lt;!-- tooltip end --&gt;

&lt;p&gt;Examples:&lt;/p&gt;
&lt;pre&gt;
  MethodHandle mh = MethodHandles.lookup().findVirtual(
      MyClass.class, "foo", MethodType.methodType(void.class, int.class));
  &lt;i&gt;// the argument should be an &lt;b&gt;int&lt;/b&gt; value&lt;/i&gt;
  mh.invoke(myObj, "&lt;b&gt;abc&lt;/b&gt;");
&lt;/pre&gt;
&lt;br&gt;
&lt;pre&gt;
  &lt;i&gt;// the argument should be &lt;b&gt;String&lt;/b&gt;.class&lt;/i&gt;
  VarHandle vh = MethodHandles.lookup().findVarHandle(
      MyClass.class, "text", &lt;b&gt;int&lt;/b&gt;.class);
&lt;/pre&gt;
&lt;br&gt;
&lt;pre&gt;
  VarHandle vh = MethodHandles.lookup().findVarHandle(
      MyClass.class, "text", String.class);
  &lt;i&gt;// the argument should be a &lt;b&gt;String&lt;/b&gt; value&lt;/i&gt;
  vh.set(myObj, &lt;b&gt;42&lt;/b&gt;);
&lt;/pre&gt;
&lt;p&gt;
  &lt;small&gt;New in 2017.2&lt;/small&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaReflectionMemberAccess" defaultSeverity="WARNING" displayName="Reflective access to nonexistent/not visible class member" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports reflective access to fields and methods that don't exist or aren't visible.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Field stringHashField() throws NoSuchFieldException {
    return String.class.getField("hash");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Field stringHashField() throws NoSuchFieldException {
    return String.class.getDeclaredField("hash");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  With a &lt;code&gt;final&lt;/code&gt; class, it's clear if there is a field or method with the specified name in the class.
&lt;/p&gt;
&lt;p&gt;
  With non-&lt;code&gt;final&lt;/code&gt; classes, it's possible that a subclass has a field or method with that name, so there could be false positives.
  Use the inspection's settings to get rid of such false positives everywhere or with specific classes.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaReflectionInvocation" defaultSeverity="WARNING" displayName="Reflective invocation arguments mismatch" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports cases in which the arguments provided to &lt;code&gt;Method.invoke()&lt;/code&gt; and &lt;code&gt;Constructor.newInstance()&lt;/code&gt;
do not match the signature specified in &lt;code&gt;Class.getMethod()&lt;/code&gt; and &lt;code&gt;Class.getConstructor()&lt;/code&gt;.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Method m = myObj.getClass().getMethod("myMethod", &lt;b&gt;int&lt;/b&gt;.class);
  &lt;i&gt;// the argument should be an &lt;b&gt;int&lt;/b&gt; value&lt;/i&gt;
  m.invoke(myObj, "&lt;b&gt;abc&lt;/b&gt;");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Error handling" path="Java"><inspection shortName="EmptyTryBlock" defaultSeverity="WARNING" displayName="Empty 'try' block" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports empty &lt;code&gt;try&lt;/code&gt; blocks, including try-with-resources statements.
&lt;p&gt;&lt;code&gt;try&lt;/code&gt; blocks with comments are considered empty.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
This inspection doesn't report empty &lt;code&gt;try&lt;/code&gt; blocks found in JSP files.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryInitCause" defaultSeverity="WARNING" displayName="Unnecessary call to 'Throwable.initCause()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Throwable.initCause()&lt;/code&gt; where an exception constructor also takes a &lt;code&gt;Throwable cause&lt;/code&gt; argument.
&lt;p&gt;In this case, the &lt;code&gt;initCause()&lt;/code&gt; call can be removed and its argument can be added to the call to the exception's constructor.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      process();
  }
  catch (RuntimeException ex) {
    RuntimeException wrapper = new RuntimeException("Error while processing");
    wrapper.initCause(ex); // Unnecessary call to 'Throwable.initCause()'
    throw wrapper;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix is available to pass the cause argument to the constructor. After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      process();
  }
  catch (RuntimeException ex) {
    RuntimeException wrapper = new RuntimeException("Error while processing", ex);
    throw wrapper;
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BadExceptionCaught" defaultSeverity="WARNING" displayName="Prohibited 'Exception' caught" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;catch&lt;/code&gt; clauses that catch an inappropriate exception.
&lt;p&gt;Some exceptions, for example
  &lt;code&gt;java.lang.NullPointerException&lt;/code&gt; or
  &lt;code&gt;java.lang.IllegalMonitorStateException&lt;/code&gt;, represent programming errors
  and therefore almost certainly should not be caught in production code.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    return component.getMousePosition(true) != null;
  } catch (NullPointerException e) { // warning: Prohibited exception 'NullPointerException' caught
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Prohibited exceptions&lt;/b&gt; list to specify which exceptions should be reported.&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueOrBreakFromFinallyBlock" defaultSeverity="WARNING" displayName="'continue' or 'break' inside 'finally' block" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; statements inside of &lt;code&gt;finally&lt;/code&gt; blocks.
&lt;p&gt;While occasionally intended, such statements are very confusing, may mask thrown exceptions, and complicate debugging.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    while (true) {
        try {
          throwingMethod();
        } finally {
            continue;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadDeathRethrown" defaultSeverity="WARNING" displayName="'ThreadDeath' not rethrown" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;try&lt;/code&gt; statements that catch
&lt;code&gt;java.lang.ThreadDeath&lt;/code&gt; and do not rethrow the exception.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    executeInParallel(request);
  } catch (ThreadDeath ex) { // warning: ThreadDeath 'ex' not rethrown
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ErrorRethrown" defaultSeverity="WARNING" displayName="'Error' not rethrown" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;try&lt;/code&gt; statements that catch
&lt;code&gt;java.lang.Error&lt;/code&gt; or any of its subclasses and do not rethrow the error.
&lt;p&gt;Statements that catch &lt;code&gt;java.lang.ThreadDeath&lt;/code&gt; are not
  reported.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    executeTests(request);
  }
  catch (OutOfMemoryError ex) { // warning: Error 'ex' not rethrown
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TooBroadCatch" defaultSeverity="WARNING" displayName="Overly broad 'catch' block" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;catch&lt;/code&gt; blocks with parameters that are more generic than the
exception thrown by the corresponding &lt;code&gt;try&lt;/code&gt; block.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try  {
    File file = new File(pathToFile);
    return file.getAbsolutePath();
  } catch (Exception ex) { // warning: 'catch' of 'Exception' is too broad, masking exceptions 'RuntimeException'
    return defaultFilePath;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try  {
    File file = new File(pathToFile);
    return file.getAbsolutePath();
  } catch (RuntimeException ex) {
    return defaultFilePath;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Only warn on RuntimeException, Exception, Error or Throwable&lt;/b&gt; option to have this inspection warn only on the most generic exceptions.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore exceptions which hide others but are themselves thrown&lt;/b&gt; option to ignore any exceptions that hide other exceptions but
    still may be thrown and thus are technically not overly broad.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TooBroadThrows" defaultSeverity="WARNING" displayName="Overly broad 'throws' clause" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;throws&lt;/code&gt; clauses with exceptions that are more generic than the
exceptions that the method actually throws.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void createFile() throws Exception { // warning: 'throws Exception' is too broad, masking exception 'IOException'
    File file = new File("pathToFile");
    file.createNewFile();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void createFile() throws IOException {
    File file = new File("pathToFile");
    file.createNewFile();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Only warn on RuntimeException, Exception, Error or Throwable&lt;/b&gt; option to have this inspection warn only on the most generic
    exceptions.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore exceptions declared on methods overriding a library method&lt;/b&gt; option to ignore overly broad &lt;code&gt;throws&lt;/code&gt; clauses
    in methods that override a library method.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore exceptions which hide others but are themselves thrown&lt;/b&gt; option to ignore any exceptions that hide other exceptions
    but still may be thrown from the method body and thus
    are technically not overly broad.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalFieldOfException" defaultSeverity="WARNING" displayName="Non-final field of 'Exception' class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields in subclasses of &lt;code&gt;java.lang.Exception&lt;/code&gt; that are not declared &lt;code&gt;final&lt;/code&gt;.
&lt;p&gt;Data on exception objects should not be modified
  because this may result in losing the error context for later debugging and logging.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class EditorException extends Exception {
    private String message; // warning: Non-final field 'message' of exception class
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NewExceptionWithoutArguments" defaultSeverity="WARNING" displayName="Exception constructor called without arguments" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports creation of a exception instance without any arguments specified.
&lt;p&gt;When an exception is constructed without any arguments, it contains no information about the problem that occurred, which makes
  debugging needlessly hard.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  throw new IOException(); // warning: exception without arguments
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinallyBlockCannotCompleteNormally" defaultSeverity="WARNING" displayName="'finally' block which can not complete normally" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, and &lt;code&gt;yield&lt;/code&gt; statements that are used inside &lt;code&gt;finally&lt;/code&gt; blocks.
These cause the &lt;code&gt;finally&lt;/code&gt; block to not complete normally but to complete abruptly.
Any exceptions thrown from the &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; blocks of the same &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt; statement will be suppressed.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void x() {
    &lt;b&gt;try&lt;/b&gt; {
      throw new RuntimeException();
    } &lt;b&gt;finally&lt;/b&gt; {
      // if bar() returns true, the RuntimeException will be suppressed
      &lt;b&gt;if&lt;/b&gt; (bar()) &lt;b&gt;return&lt;/b&gt;;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BadExceptionThrown" defaultSeverity="WARNING" displayName="Prohibited exception thrown" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;throw&lt;/code&gt; statements that throw an inappropriate exception.
For example an exception can be inappropriate because it is overly generic,
such as &lt;code&gt;java.lang.Exception&lt;/code&gt; or &lt;code&gt;java.io.IOException&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void setup(Mode mode) {
      if (mode == null)
          throw new RuntimeException("Problem during setup"); // warning: Prohibited exception 'RuntimeException' thrown
      ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Prohibited exceptions&lt;/b&gt; list to specify which exceptions should be reported.&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyFinallyBlock" defaultSeverity="WARNING" displayName="Empty 'finally' block" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports empty &lt;code&gt;finally&lt;/code&gt; blocks.
&lt;p&gt;Empty &lt;code&gt;finally&lt;/code&gt; blocks usually indicate coding errors. They may also remain after code refactoring and can safely be removed.&lt;/p&gt;
&lt;p&gt;This inspection doesn't report empty &lt;code&gt;finally&lt;/code&gt; blocks found in JSP files.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    Files.readString(Paths.get("in.txt"));
  } catch (IOException e) {
    throw new RuntimeException(e);
  } finally {

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:
&lt;pre&gt;&lt;code&gt;
  try {
    Files.readString(Paths.get("in.txt"));
  } catch (IOException e) {
    throw new RuntimeException(e);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceofCatchParameter" defaultSeverity="WARNING" displayName="'instanceof' on 'catch' parameter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports cases in which an &lt;code&gt;instanceof&lt;/code&gt; expression is used for testing the type of a parameter in a &lt;code&gt;catch&lt;/code&gt; block.
&lt;p&gt;Testing the type of &lt;code&gt;catch&lt;/code&gt; parameters is usually better done by having separate
  &lt;code&gt;catch&lt;/code&gt; blocks instead of using &lt;code&gt;instanceof&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Runnable runnable) {
    try {
        runnable.run();
    } catch (Throwable throwable) {
        if (throwable instanceof NoClassDefFoundError) { // warning: 'instanceof' on 'catch' parameter 'throwable'
            System.out.println("Class not found!");
        }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsThrowable" defaultSeverity="WARNING" displayName="Class directly extends 'Throwable'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that directly extend &lt;code&gt;java.lang.Throwable&lt;/code&gt;.
&lt;p&gt;Extending &lt;code&gt;java.lang.Throwable&lt;/code&gt; directly is generally considered bad practice.
  It is usually enough to extend &lt;code&gt;java.lang.RuntimeException&lt;/code&gt;, &lt;code&gt;java.lang.Exception&lt;/code&gt;, or - in special
  cases - &lt;code&gt;java.lang.Error&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EnigmaThrowable extends Throwable {} // warning: Class 'EnigmaThrowable' directly extends 'java.lang.Throwable'
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowCaughtLocally" defaultSeverity="WARNING" displayName="'throw' caught by containing 'try' statement" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;throw&lt;/code&gt; statements whose exceptions are always
caught by containing &lt;code&gt;try&lt;/code&gt; statements.
&lt;p&gt;Using &lt;code&gt;throw&lt;/code&gt;
  statements as a "goto" to change the local flow of control is confusing and results in poor performance.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    if (!Files.isDirectory(PROJECTS)) {
        throw new IllegalStateException("Directory not found."); // warning: 'throw' caught by containing 'try' statement
    }
    ...
  } catch (Exception e) {
      LOG.error("run failed");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore rethrown exceptions&lt;/b&gt; option to ignore exceptions that are rethrown.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NullThrown" defaultSeverity="WARNING" displayName="'null' thrown" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;null&lt;/code&gt; literals that are used as the argument of a &lt;code&gt;throw&lt;/code&gt; statement.
&lt;p&gt;Such constructs produce a &lt;code&gt;java.lang.NullPointerException&lt;/code&gt; that usually should not be thrown programmatically.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CatchMayIgnoreException" defaultSeverity="WARNING" displayName="Catch block may ignore exception" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;catch&lt;/code&gt; blocks that are empty or may ignore an exception.
&lt;p&gt;While occasionally intended, empty &lt;code&gt;catch&lt;/code&gt; blocks may complicate debugging.
Also, ignoring a &lt;code&gt;catch&lt;/code&gt; parameter might be wrong.
  Finally, the static code analyzer reports if it detects that a &lt;code&gt;catch&lt;/code&gt; block may silently ignore important VM
  exceptions like &lt;code&gt;NullPointerException&lt;/code&gt;. Ignoring such an exception
(without logging or rethrowing it) may hide a bug.&lt;/p&gt;

&lt;p&gt;
  The inspection won't report any &lt;code&gt;catch&lt;/code&gt; parameters named &lt;code&gt;ignore&lt;/code&gt; or &lt;code&gt;ignored&lt;/code&gt;.
  Conversely, the inspection will warn you about any &lt;code&gt;catch&lt;/code&gt; parameters named &lt;code&gt;ignore&lt;/code&gt; or &lt;code&gt;ignored&lt;/code&gt; that are actually in use.
  Additionally, the inspection won't report &lt;code&gt;catch&lt;/code&gt; parameters inside test sources named &lt;code&gt;expected&lt;/code&gt; or &lt;code&gt;ok&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  You can use a quick-fix to change the exception name to &lt;code&gt;ignored&lt;/code&gt;.
  For empty &lt;b&gt;catch&lt;/b&gt; blocks, an additional quick-fix to generate the &lt;b&gt;catch&lt;/b&gt; body is suggested.
  You can modify the "Catch Statement Body" template on the Code tab in
  &lt;a href="settings://fileTemplates"&gt;Settings | Editor | File and Code Templates&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    throwingMethod();
  } catch (IOException ex) {

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    System.out.println(System.in.read());
  } catch (IOException ignored) {

  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Do not warn when 'catch' block contains a comment&lt;/b&gt; option to ignore &lt;code&gt;catch&lt;/code&gt; blocks with comments.
  &lt;/li&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Do not warn when 'catch' block is not empty&lt;/b&gt; option to ignore &lt;code&gt;catch&lt;/code&gt; blocks that contain
    statements or comments inside, while the variable itself is not used.
  &lt;/li&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Do not warn when exception named 'ignore(d)' is not actually ignored&lt;/b&gt; option to ignore
    variables named &lt;code&gt;ignored&lt;/code&gt; if they are in use.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;small&gt;New in 2018.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowFromFinallyBlock" defaultSeverity="WARNING" displayName="'throw' inside 'finally' block" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;throw&lt;/code&gt; statements inside &lt;code&gt;finally&lt;/code&gt;
blocks.
&lt;p&gt;While occasionally intended, such &lt;code&gt;throw&lt;/code&gt; statements may conceal exceptions thrown from &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt; and thus
  tremendously complicate the debugging process.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnFromFinallyBlock" defaultSeverity="WARNING" displayName="'return' inside 'finally' block" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;return&lt;/code&gt; statements inside of &lt;code&gt;finally&lt;/code&gt; blocks.
&lt;p&gt;While occasionally intended, such &lt;code&gt;return&lt;/code&gt; statements may mask thrown exceptions
and complicate debugging.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    foo();
  } finally {
    if (bar()) return;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExceptionFromCatchWhichDoesntWrap" defaultSeverity="WARNING" displayName="'throw' inside 'catch' block which ignores the caught exception" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports exceptions that are thrown from inside &lt;code&gt;catch&lt;/code&gt; blocks but do not "wrap" the caught exception.
&lt;p&gt;When an exception is thrown in response to an exception, wrapping the initial exception prevents losing valuable context information,
  such as stack frames and line numbers.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ...
  catch (IOException e) {
    closeAllConnections();
    throw new ConnectException("Connection problem."); // warning: 'throw' inside 'catch' block ignores the caught exception 'e'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore if result of exception method call is used&lt;/b&gt; option to indicate whether the inspection should ignore exceptions whose
    argument is the result of a method
    call on the original exception, such as &lt;code&gt;getMessage()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore if thrown exception cannot wrap an exception&lt;/b&gt; option to ignore &lt;code&gt;throw&lt;/code&gt; statements that throw exceptions without a
    constructor that accepts a &lt;code&gt;Throwable&lt;/code&gt; cause.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowsRuntimeException" defaultSeverity="WARNING" displayName="Unchecked exception declared in 'throws' clause" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports declaration of an unchecked exception (&lt;code&gt;java.lang.RuntimeException&lt;/code&gt; or one of its subclasses) in the &lt;code&gt;throws&lt;/code&gt;
clause of a method.
&lt;p&gt;Declarations of unchecked exceptions are not required and may be deleted or moved to a Javadoc &lt;code&gt;@throws&lt;/code&gt; tag.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class InvalidDataException extends RuntimeException {}

  class TextEditor {
    void readSettings() throws InvalidDataException {} // warning: Unchecked exception 'InvalidDataException' declared in 'throws' clause
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UncheckedExceptionClass" defaultSeverity="WARNING" displayName="Unchecked 'Exception' class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports subclasses of &lt;code&gt;java.lang.RuntimeException&lt;/code&gt;.
&lt;p&gt;Some coding standards require that all user-defined exception classes are checked.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EnigmaException extends RuntimeException {} // warning: Unchecked exception class 'EnigmaException'
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CaughtExceptionImmediatelyRethrown" defaultSeverity="WARNING" displayName="Caught exception is immediately rethrown" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;catch&lt;/code&gt; blocks that immediately rethrow
the caught exception without performing any action on it.
Such &lt;code&gt;catch&lt;/code&gt; blocks are unnecessary and have no error
handling.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
        try {
            new FileInputStream("");
        } catch (FileNotFoundException e) {
            throw e;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedTryStatement" defaultSeverity="WARNING" displayName="Nested 'try' statement" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports nested &lt;code&gt;try&lt;/code&gt; statements.
&lt;p&gt;Nested &lt;code&gt;try&lt;/code&gt; statements
  may result in unclear code and should probably have their &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt; sections
  merged.
  &lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BadExceptionDeclared" defaultSeverity="WARNING" displayName="Prohibited exception declared" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that declare an inappropriate exception in their &lt;code&gt;throws&lt;/code&gt; clause.
For example an exception can be inappropriate because it is overly generic,
such as &lt;code&gt;java.lang.Exception&lt;/code&gt; or &lt;code&gt;java.lang.Throwable&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void describeModule(String module) throws Exception {} // warning: Prohibited exception 'Exception' declared
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Prohibited exceptions&lt;/b&gt; list to specify which exceptions should be reported.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore exceptions declared on methods overriding a library method&lt;/b&gt; option to ignore exceptions declared by methods
    that override a library method.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckedExceptionClass" defaultSeverity="WARNING" displayName="Checked exception class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports checked exception classes (that is, subclasses of &lt;code&gt;java.lang.Exception&lt;/code&gt; that are
not subclasses of &lt;code&gt;java.lang.RuntimeException&lt;/code&gt;).
&lt;p&gt;Some coding standards suppress checked user-defined exception classes.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class IllegalMoveException extends Exception {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Threading issues" path="Java"><inspection shortName="NotifyCalledOnCondition" defaultSeverity="WARNING" displayName="'notify()' or 'notifyAll()' called on 'java.util.concurrent.locks.Condition' object" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;notify()&lt;/code&gt; or &lt;code&gt;notifyAll()&lt;/code&gt; made on
&lt;code&gt;java.util.concurrent.locks.Condition&lt;/code&gt; object.
&lt;p&gt;
  This is probably a programming error, and some variant of the &lt;code&gt;signal()&lt;/code&gt; or
  &lt;code&gt;signalAll()&lt;/code&gt; method was intended instead, otherwise &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; may occur.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    final Lock l = new ReentrantLock();
    final Condition c = l.newCondition();

    void release() {
      l.lock();
      try {
        c.notifyAll(); // probably 'signalAll()' was intended here
      } finally {
        l.unlock();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemRunFinalizersOnExit" defaultSeverity="WARNING" displayName="Call to 'System.runFinalizersOnExit()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;System.runFinalizersOnExit()&lt;/code&gt;.
&lt;p&gt;
  This call is one of the most dangerous in the Java language. It is inherently non-thread-safe,
  may result in data corruption, a deadlock, and may affect parts of the program far removed from its call point.
  It is deprecated and was removed in JDK 11, and its use is strongly discouraged.
&lt;/p&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 10 or lower.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VolatileArrayField" defaultSeverity="WARNING" displayName="Volatile array field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports array fields that are declared &lt;code&gt;volatile&lt;/code&gt;. Such declarations
may be confusing because accessing the array itself follows the rules for &lt;code&gt;volatile&lt;/code&gt;
fields, but accessing the array's contents does not.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Data {
    private volatile int[] idx = new int[0];
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  If such volatile access is needed for array contents, consider using
  &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; classes instead:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Data {
    private final AtomicIntegerArray idx = new AtomicIntegerArray(new int[0]);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizationOnStaticField" defaultSeverity="WARNING" displayName="Synchronization on 'static' field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports synchronization on &lt;code&gt;static&lt;/code&gt; fields. While not strictly incorrect,
synchronization on &lt;code&gt;static&lt;/code&gt; fields can lead to bad performance because of contention.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MethodMayBeSynchronized" defaultSeverity="WARNING" displayName="Method with single 'synchronized' block can be replaced with 'synchronized' method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods whose body contains a single &lt;code&gt;synchronized&lt;/code&gt; statement.
A lock expression for this &lt;code&gt;synchronized&lt;/code&gt; statement must be equal to
&lt;code&gt;this&lt;/code&gt; for instance methods or &lt;code&gt;[ClassName].class&lt;/code&gt; for static methods.
&lt;p&gt;
  To improve readability of such methods,
  you can remove the &lt;code&gt;synchronized&lt;/code&gt; wrapper and mark the method as &lt;code&gt;synchronized&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int generateInt(int x) {
    synchronized (this) {
      return 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public synchronized int generateInt(int x) {
    return 1;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptySynchronizedStatement" defaultSeverity="WARNING" displayName="Empty 'synchronized' statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;synchronized&lt;/code&gt; statements with empty bodies.
&lt;p&gt;
  Empty &lt;code&gt;synchronized&lt;/code&gt; statements are sometimes used to wait for other threads to
  release a particular resource. However, there is no guarantee that the same resource
  won't be acquired again right after the empty &lt;code&gt;synchronized&lt;/code&gt; statement finishes.
  For proper synchronization, the resource should be utilized inside the &lt;code&gt;synchronized&lt;/code&gt; block.
&lt;/p&gt;
&lt;p&gt;
  Also, an empty &lt;code&gt;synchronized&lt;/code&gt; block may appear after a refactoring
  when redundant code was removed. In this case, the &lt;code&gt;synchronized&lt;/code&gt; block
  itself will be redundant and should be removed as well.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized(lock) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  A quick-fix is suggested to remove the empty synchronized statement.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  This inspection is disabled in JSP files.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizeOnNonFinalField" defaultSeverity="WARNING" displayName="Synchronization on a non-final field" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;synchronized&lt;/code&gt; statement lock expressions
that consist of a non-&lt;code&gt;final&lt;/code&gt; field reference.
Such statements are unlikely to have useful semantics, as different
threads may acquire different locks even when operating on the same object.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private Object o;
  public void foo() {
    synchronized (o) // synchronization on a non-final field
    { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonAtomicOperationOnVolatileField" defaultSeverity="WARNING" displayName="Non-atomic operation on 'volatile' field" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-atomic operations on volatile fields.
&lt;p&gt;
  An example of a non-atomic operation is updating the field using the increment operator.
  As the operation involves read and write, and other modifications may happen in between, data may become corrupted.
  The operation can be made atomic by surrounding it with a &lt;code&gt;synchronized&lt;/code&gt; block or
  using one of the classes from the &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; package.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private volatile int v = 1;

  void foo() {
    v = 2 * v;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadWithDefaultRunMethod" defaultSeverity="WARNING" displayName="Instantiating a 'Thread' with default 'run()' method" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code that instantiates &lt;code&gt;Thread&lt;/code&gt; without specifying
a &lt;code&gt;Runnable&lt;/code&gt; parameter or overriding the &lt;code&gt;run()&lt;/code&gt; method.
&lt;p&gt;
  Such threads do nothing useful.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AccessToStaticFieldLockedOnInstance" defaultSeverity="WARNING" displayName="Access to 'static' field locked on instance data" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports access to non-constant static fields that are
locked on either &lt;code&gt;this&lt;/code&gt; or an instance field of &lt;code&gt;this&lt;/code&gt;.
&lt;p&gt;
  Locking a static field on instance data does not prevent the field from being
  modified by other instances, and thus may result in unexpected race conditions.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static String test;
  public void foo() {
      synchronized (this) {
          System.out.println(test); // warning
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  There is a quick-fix that allows ignoring static fields of specific types.
  You can manage those ignored types in the inspection options.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the inspection options to specify which classes used for static fields should be ignored.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BusyWait" defaultSeverity="WARNING" displayName="Busy wait" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.lang.Thread.sleep()&lt;/code&gt; that occur inside loops.
&lt;p&gt;Such calls
  are indicative of "busy-waiting". Busy-waiting is often inefficient, and may result in unexpected deadlocks
  as busy-waiting threads do not release locked resources.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
     volatile int x;
     public void waitX() throws Exception {
      while (x &amp;gt; 0) {
        Thread.sleep(10);//warning: Call to 'Thread.sleep()' in a loop, probably busy-waiting
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SleepWhileHoldingLock" defaultSeverity="WARNING" displayName="Call to 'Thread.sleep()' while synchronized" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.lang.Thread.sleep()&lt;/code&gt; methods that occur
within a &lt;code&gt;synchronized&lt;/code&gt; block or method.
&lt;p&gt;
  &lt;code&gt;sleep()&lt;/code&gt; within a
  &lt;code&gt;synchronized&lt;/code&gt; block may result in decreased performance, poor scalability, and possibly
  even deadlocking. Consider using &lt;code&gt;wait()&lt;/code&gt; instead,
  as it will release the lock held.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (lock) {
    Thread.sleep(100);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldAccessedSynchronizedAndUnsynchronized" defaultSeverity="WARNING" displayName="Field accessed in both 'synchronized' and unsynchronized contexts" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-final fields that are accessed in both &lt;code&gt;synchronized&lt;/code&gt; and
non-&lt;code&gt;synchronized&lt;/code&gt; contexts.
&lt;code&gt;volatile&lt;/code&gt; fields as well as accesses in constructors and initializers are ignored by this inspection.
&lt;p&gt;
  Such "partially synchronized" access is often the result of a coding oversight
  and may lead to unexpectedly inconsistent data structures.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Program {
    Console console; // warning: Field 'console' is accessed in both synchronized and unsynchronized contexts

    public synchronized void execute() {
      console.print("running");
    }

    public void check() {
      console.check();
    }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to specify if simple getters and setters are counted as accesses too.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToNativeMethodWhileLocked" defaultSeverity="WARNING" displayName="Call to a 'native' method while locked" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls &lt;code&gt;native&lt;/code&gt; methods within a &lt;code&gt;synchronized&lt;/code&gt; block or method.
&lt;p&gt;
  When possible, it's better to keep calls to &lt;code&gt;native&lt;/code&gt; methods out of the synchronized context
  because such calls cause an expensive context switch and may lead to performance issues.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  native void nativeMethod();

  void example(){
    synchronized (lock){
      nativeMethod();//warning
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizationOnLocalVariableOrMethodParameter" defaultSeverity="WARNING" displayName="Synchronization on local variable or method parameter" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports synchronization on a local variable or parameter. 
&lt;p&gt;
  It is very difficult to guarantee correct operation when such synchronization is used.
  It may be possible to improve such code, for example, by controlling access using a synchronized wrapper class or by synchronizing on a
  field.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void bar() {
    final Object lock = new Object();
    synchronized (lock) { }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DoubleCheckedLocking" defaultSeverity="WARNING" displayName="Double-checked locking" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"&gt;double-checked locking&lt;/a&gt;.
&lt;p&gt;
  Double-checked locking tries to initialize a field on demand and in a thread-safe manner while avoiding the cost of synchronization.
  Unfortunately it is not thread-safe when used on a field that is not declared &lt;code&gt;volatile&lt;/code&gt;.
  When using Java 1.4 or earlier, double-checked locking doesn't work even with &lt;code&gt;volatile&lt;/code&gt; fields.
  Read the article linked above for the detailed explanation of the problem.
&lt;/p&gt;
&lt;p&gt;
  Example of an incorrect double-checked locking:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    private Helper helper = null;
    public Helper getHelper() {
      if (helper == null)
        synchronized(this) {
          if (helper == null) helper = new Helper();
        }
        return helper;
      }
    }
    // other functions and members...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitNotifyNotInSynchronizedContext" defaultSeverity="WARNING" displayName="'wait()' or 'notify()' is not in synchronized context" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;wait()&lt;/code&gt;, &lt;code&gt;notify()&lt;/code&gt;, and &lt;code&gt;notifyAll()&lt;/code&gt;
that are not made inside a corresponding synchronized statement or synchronized method.
&lt;p&gt;
  Calling these methods on an object
  without holding a lock on that object causes &lt;code&gt;IllegalMonitorStateException&lt;/code&gt;.
  Such a construct is not necessarily an error, as the necessary lock may be acquired before
  the containing method is called, but it's worth looking at.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Sync {
    private final Object lock = new Object();

    void test() throws InterruptedException {
      synchronized (this) {
        lock.wait(); // 'lock.wait()' is not synchronized on 'lock'
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NotifyWithoutCorrespondingWait" defaultSeverity="WARNING" displayName="'notify()' without corresponding 'wait()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Object.notify()&lt;/code&gt; or &lt;code&gt;Object.notifyAll()&lt;/code&gt; for which no call to a corresponding
&lt;code&gt;Object.wait()&lt;/code&gt; can be found.
&lt;p&gt;Only calls that target fields of the current class are reported by this inspection.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (synList) {
    synList.notify(); //synList.wait() is never called
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AccessToNonThreadSafeStaticFieldFromInstance" defaultSeverity="WARNING" displayName="Non-thread-safe 'static' field access" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports access to &lt;code&gt;static&lt;/code&gt; fields that are of a non-thread-safe type.
&lt;p&gt;
  When a &lt;code&gt;static&lt;/code&gt; field is accessed from an instance method or a non-synchronized block,
  multiple threads can access that field.
  This can lead to unspecified side effects, like exceptions and incorrect results.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Sample {
    private static final SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
    String method() {
      return df.format("");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  You can specify which types should be considered not thread-safe.
  Only fields with these exact types or initialized with these exact types are reported,
  because there may exist thread-safe subclasses of these types.
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadStartInConstruction" defaultSeverity="WARNING" displayName="Call to 'Thread.start()' during object construction" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;start()&lt;/code&gt; on &lt;code&gt;java.lang.Thread&lt;/code&gt;
or any of its subclasses during object construction.
&lt;p&gt;
  While occasionally useful, such constructs should be avoided due to inheritance issues.
  Subclasses of a class that launches a thread during the object construction will not have finished
  any initialization logic of their own before the thread has launched.
&lt;/p&gt;
&lt;p&gt;This inspection does not report if the class that starts a thread is declared &lt;code&gt;final&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyThread extends Thread {
    MyThread() {
      start();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AtomicFieldUpdaterNotStaticFinal" defaultSeverity="WARNING" displayName="'AtomicFieldUpdater' field not declared 'static final'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields of types:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;java.util.concurrent.atomic.AtomicLongFieldUpdater&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.concurrent.atomic.AtomicIntegerFieldUpdater&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.concurrent.atomic.AtomicReferenceFieldUpdater&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
that are not &lt;code&gt;static final&lt;/code&gt;.
Because only one atomic field updater is needed for updating a &lt;code&gt;volatile&lt;/code&gt; field in all instances
of a class, it can almost always be &lt;code&gt;static&lt;/code&gt;.

&lt;p&gt;Making the updater &lt;code&gt;final&lt;/code&gt; allows the JVM to optimize access for improved performance.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    private volatile int id;
    private AtomicIntegerFieldUpdater&amp;lt;Main&amp;gt; idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, "id");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    private volatile int id;
    private static final AtomicIntegerFieldUpdater&amp;lt;Main&amp;gt; idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, "id");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonSynchronizedMethodOverridesSynchronizedMethod" defaultSeverity="WARNING" displayName="Unsynchronized method overrides 'synchronized' method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-&lt;code&gt;synchronized&lt;/code&gt; methods overriding &lt;code&gt;synchronized&lt;/code&gt; methods.
&lt;p&gt;
  The overridden method will not be automatically synchronized if the superclass method
  is declared as &lt;code&gt;synchronized&lt;/code&gt;. This may result in unexpected race conditions when using the subclass.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    synchronized void process() {}
  }
  class Sub extends Super {
    // Unsynchronized method 'process()' overrides synchronized method
    void process() {}
  }  
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitWithoutCorrespondingNotify" defaultSeverity="WARNING" displayName="'wait()' without corresponding 'notify()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Object.wait()&lt;/code&gt;, for which no call to the corresponding &lt;code&gt;Object.notify()&lt;/code&gt; or
&lt;code&gt;Object.notifyAll()&lt;/code&gt; can be found.
&lt;p&gt;This inspection only reports calls with qualifiers referencing fields of the current class.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {
    public Object foo = new Object();

    void bar() throws InterruptedException {
      this.foo.wait();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AwaitNotInLoop" defaultSeverity="WARNING" displayName="'await()' not called in loop" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;java.util.concurrent.locks.Condition.await()&lt;/code&gt; not being called inside a loop.
&lt;p&gt;
  &lt;code&gt;await()&lt;/code&gt; and related methods are normally used to suspend a thread until some condition becomes true.
  As the thread could have been woken up for a different reason,
  the condition should be checked after the &lt;code&gt;await()&lt;/code&gt; call returns.
  A loop is a simple way to achieve this.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void acquire(Condition released) throws InterruptedException {
    released.await();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Good code should look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void acquire(Condition released) throws InterruptedException {
    while (acquired) {
      released.await();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizeOnLock" defaultSeverity="WARNING" displayName="Synchronization on a 'Lock' object" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;synchronized&lt;/code&gt; blocks that lock on an instance of &lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt;.
Such synchronization is almost certainly unintended, and appropriate versions of &lt;code&gt;.lock()&lt;/code&gt;
and &lt;code&gt;.unlock()&lt;/code&gt; should be used instead.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final ReentrantLock lock = new ReentrantLock();

  public void foo() {
    synchronized (lock) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizedOnLiteralObject" defaultSeverity="WARNING" displayName="Synchronization on an object initialized with a literal" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;synchronized&lt;/code&gt; blocks that lock on an object initialized with a literal.
&lt;p&gt;
  String literals are interned and &lt;code&gt;Character&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; literals can be allocated from a cache.
  Because of this, it is possible that some other part of the system, which uses an object initialized with the same literal, is actually
  holding a reference to the exact same object. This can create unexpected dead-lock situations, if the lock object was thought to be private.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    final String mutex = "Mutex";
    void method() {
      synchronized (mutex) {
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;strong&gt;Warn on all possible literals&lt;/strong&gt; option to report any synchronization on
  &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Character&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; objects.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadStopSuspendResume" defaultSeverity="WARNING" displayName="Call to 'Thread.stop()', 'suspend()' or 'resume()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Thread.stop()&lt;/code&gt;,
&lt;code&gt;Thread.suspend()&lt;/code&gt;, and &lt;code&gt;Thread.resume()&lt;/code&gt;.
&lt;p&gt;
  These calls are inherently prone to data corruption and deadlocks, and their use is strongly discouraged.
  It is better to use cooperative cancellation instead of &lt;code&gt;stop&lt;/code&gt;, and
  interruption instead of direct calls to &lt;code&gt;suspend&lt;/code&gt; and &lt;code&gt;resume&lt;/code&gt;.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AtomicFieldUpdaterIssues" defaultSeverity="WARNING" displayName="Inconsistent 'AtomicFieldUpdater' declaration" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports issues with &lt;code&gt;AtomicLongFieldUpdater&lt;/code&gt;,
&lt;code&gt;AtomicIntegerFieldUpdater&lt;/code&gt;, or &lt;code&gt;AtomicReferenceFieldUpdater&lt;/code&gt; fields (the &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; package).
&lt;p&gt;The reported issues are identical to the runtime problems that can happen with atomic field updaters:
  specified field not found, specified field not accessible, specified field has a wrong type, and so on.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;pre&gt;&lt;code&gt;
  class A {
    private static volatile int value = 0;
    private static final AtomicIntegerFieldUpdater updater =
    AtomicIntegerFieldUpdater.newUpdater((A.class), "value"); // warning: Field 'value' has 'static' modifier
  }
  &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;&lt;pre&gt;&lt;code&gt;
  class B {
    private static final AtomicIntegerFieldUpdater updater =
      AtomicIntegerFieldUpdater.newUpdater(B.class, "value"); // warning: No field named 'value' found in class 'B'
  }
  &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizationOnGetClass" defaultSeverity="WARNING" displayName="Synchronization on 'getClass()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports synchronization on a call to &lt;code&gt;getClass()&lt;/code&gt;.
&lt;p&gt;
  If the class containing the synchronization is subclassed, the subclass
  will
  synchronize on a different class object. Usually the call to &lt;code&gt;getClass()&lt;/code&gt; can be replaced with a class literal expression, for
  example &lt;code&gt;String.class&lt;/code&gt;. An even better solution is synchronizing on a &lt;code&gt;private static final&lt;/code&gt; lock object, access to
  which can be completely controlled.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; synchronized(getClass()) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SafeLock" defaultSeverity="WARNING" displayName="Lock acquired but not safely unlocked" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt; resources that are not acquired in front of a
&lt;code&gt;try&lt;/code&gt; block or not unlocked in the corresponding &lt;code&gt;finally&lt;/code&gt; block. Such resources may
be inadvertently leaked if an exception is thrown before the resource is closed.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  lock.lock(); // will be reported since the 'finally' block is missing
  try {
    doSmthWithLock();
  } catch (IOException e) {
    throw new UncheckedIOException(e);
  }
  lock.unlock();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadLocalNotStaticFinal" defaultSeverity="WARNING" displayName="'ThreadLocal' field not declared 'static final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields of type &lt;code&gt;java.lang.ThreadLocal&lt;/code&gt; that are not declared &lt;code&gt;static final&lt;/code&gt;.
&lt;p&gt;
  In the most common case, a &lt;code&gt;java.lang.ThreadLocal&lt;/code&gt; instance associates state with a thread.
  A non-static non-final &lt;code&gt;java.lang.ThreadLocal&lt;/code&gt; field associates state with an instance-thread combination.
  This is usually unnecessary and quite often is a bug that can cause memory leaks and incorrect behavior.
&lt;/p&gt;
&lt;p&gt;
  A quick-fix is suggested to make the field &lt;code&gt;static final&lt;/code&gt;.
&lt;p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private ThreadLocal tl = ThreadLocal.withInitial(() -&gt; Boolean.TRUE);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnconditionalWait" defaultSeverity="WARNING" displayName="Unconditional 'wait()' call" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;wait()&lt;/code&gt; being called unconditionally within a synchronized context.
&lt;p&gt;
  Normally, &lt;code&gt;wait()&lt;/code&gt; is used to block a thread until some condition is true. If
  &lt;code&gt;wait()&lt;/code&gt; is called unconditionally, it often indicates that the condition was
  checked before a lock was acquired. In that case a data race may occur, with the condition
  becoming true between the time it was checked and the time the lock was acquired.
&lt;/p&gt;
&lt;p&gt;
  While constructs found by this inspection are not necessarily incorrect, they are certainly worth examining.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar {
      void foo() throws InterruptedException {
          synchronized (this) {
              wait(); // warning
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsThread" defaultSeverity="WARNING" displayName="Class directly extends 'Thread'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that directly extend &lt;code&gt;java.lang.Thread&lt;/code&gt;.
It is usually recommended to prefer composition over inheritance to create more reusable code that is easier to modify later.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MainThread extends Thread {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadPriority" defaultSeverity="WARNING" displayName="Call to 'Thread.setPriority()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Thread.setPriority()&lt;/code&gt;.
Modifying priorities of threads is an inherently non-portable operation, as no guarantees
are given in the Java specification of how priorities are used in scheduling threads, or even
whether they are used at all.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WhileLoopSpinsOnField" defaultSeverity="WARNING" displayName="'while' loop spins on field" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;while&lt;/code&gt; loops that spin on the
value of a non-&lt;code&gt;volatile&lt;/code&gt; field, waiting for it to be changed by another thread.
&lt;p&gt;
In addition to being potentially extremely CPU intensive when little work is done inside the loop, such
loops are likely to have different semantics from what was intended. The Java Memory Model allows such loop to never complete even
if another thread changes the field's value.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SpinsOnField {
    boolean ready = false;

    void run() {
      while (!ready) { // the loop may never complete even after markAsReady call
                       // from the other thread
      }
      // do some work
    }

    void markAsReady() {
      ready = true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
Additionally, since Java 9 it's recommended to call &lt;code&gt;Thread.onSpinWait()&lt;/code&gt; inside a spin loop
on a &lt;code&gt;volatile&lt;/code&gt; field, which may significantly improve performance on some hardware.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the inspection options to only report empty &lt;code&gt;while&lt;/code&gt; loops.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitWhileHoldingTwoLocks" defaultSeverity="WARNING" displayName="'wait()' while holding two locks" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;wait()&lt;/code&gt; methods that may occur while the current thread is holding two locks.
&lt;p&gt;
  Since calling &lt;code&gt;wait()&lt;/code&gt; only releases one lock on its target,
  waiting with two locks held can easily lead to a deadlock.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (lockA) {
    synchronized (lockB) {
      lockB.wait(); //warning
      //thread A is stuck here holding lockA
    }
  }

  synchronized (lockA) { //thread B can't enter the block and release thread A
    lockB.notify();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticInitializerReferencesSubClass" defaultSeverity="WARNING" displayName="Static initializer references subclass" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that refer to their subclasses in static initializers or static fields.
&lt;p&gt;Such references can cause JVM-level deadlocks in multithreaded environment, when one thread tries to load the superclass
  and another thread tries to load the subclass at the same time.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    static final Child field = new Child();
  }
  class Child extends Parent { }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedSynchronizedStatement" defaultSeverity="WARNING" displayName="Nested 'synchronized' statement" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports nested &lt;code&gt;synchronized&lt;/code&gt; statements.
It is recommended to avoid nested synchronization if possible, because in some cases it may lead to a deadlock.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (lockA){
    //thread 1 is waiting for lockB
    synchronized (lockB){ //warning
    }
  }
  ...
  synchronized (lockB) {
    //thread 2 is waiting for lockA
    synchronized (lockA) { //warning
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizedMethod" defaultSeverity="WARNING" displayName="'synchronized' method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the &lt;code&gt;synchronized&lt;/code&gt; modifier on methods.
&lt;p&gt;
  There are several reasons a &lt;code&gt;synchronized&lt;/code&gt; modifier on a method may be a bad idea:
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    As little work as possible should be performed under a lock. Therefore it is often better to use a &lt;code&gt;synchronized&lt;/code&gt; block and
    keep there only the code that works with shared state.
  &lt;/li&gt;
  &lt;li&gt;
    Synchronization becomes a part of a method's interface. This makes a transition to a different locking mechanism difficult.
  &lt;/li&gt;
  &lt;li&gt;
    Keeping track of what is locking a particular object gets harder.
  &lt;/li&gt;
  &lt;li&gt;
    The DoS (denial-of-service) attack becomes feasible either on purpose or unknowingly when inheriting the method's class.
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
  As an alternative, consider synchronizing on a &lt;code&gt;private final&lt;/code&gt; lock object, access to which can be completely controlled.
&lt;/p&gt;
&lt;p&gt;A quick-fix is provided to wrap the method body with &lt;code&gt;synchronized(this)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public synchronized void fooBar() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public void fooBar() {
      synchronized (this) {
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;You can configure the following options for this inspection:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Include native methods&lt;/strong&gt; - include native methods into the inspection's scope.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ignore methods overriding a synchronized method&lt;/strong&gt; -
    do not report methods that override a &lt;code&gt;synchronized&lt;/code&gt; method.&lt;/li&gt;
&lt;/ol&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadYield" defaultSeverity="WARNING" displayName="Call to 'Thread.yield()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Thread.yield()&lt;/code&gt;.
&lt;p&gt;
  The behavior of &lt;code&gt;yield()&lt;/code&gt; is non-deterministic and platform-dependent, and it is rarely appropriate to use this method.
  Its use should be combined with detailed profiling and benchmarking to ensure that it actually has the desired effect.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public static void main(String[] args) {
    Runnable r = () -&gt; {
      for (int i = 0; i &amp;lt; 10; i++) {
        System.out.println(i);
        Thread.yield();
      }
    };
    new Thread(r).start();
    new Thread(r).start();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SynchronizeOnThis" defaultSeverity="WARNING" displayName="Synchronization on 'this'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports synchronization on &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; expressions.
The reported constructs include &lt;code&gt;synchronized&lt;/code&gt; blocks and calls to &lt;code&gt;wait()&lt;/code&gt;,
&lt;code&gt;notify()&lt;/code&gt; or &lt;code&gt;notifyAll()&lt;/code&gt;.
&lt;p&gt;There are several reasons synchronization on &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; expressions may be a bad idea:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    it makes synchronization a part of the external interface of the class,
    which makes a future change to a different locking mechanism difficult,
  &lt;/li&gt;
  &lt;li&gt;
    it becomes hard to track just who is locking on a given object,
  &lt;/li&gt;
  &lt;li&gt;
    it makes a denial-of-service attack possible, either on purpose or it can happen easily by accident when subclassing.
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As an alternative, consider synchronizing on a &lt;code&gt;private final&lt;/code&gt; lock object, access to which can be completely controlled.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void print() {
    synchronized(this) { // warning: Lock operations on 'this' may have unforeseen side-effects
      System.out.println("synchronized");
    }
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitOrAwaitWithoutTimeout" defaultSeverity="WARNING" displayName="'wait()' or 'await()' without timeout" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Object.wait()&lt;/code&gt; or &lt;code&gt;Condition.await()&lt;/code&gt; without specifying a timeout.
&lt;p&gt;
  Such calls may be dangerous in high-availability programs, as failures in one
  component may result in blockages of the waiting component
  if &lt;code&gt;notify()&lt;/code&gt;/&lt;code&gt;notifyAll()&lt;/code&gt;
  or &lt;code&gt;signal()&lt;/code&gt;/&lt;code&gt;signalAll()&lt;/code&gt; never get called.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object bar) throws InterruptedException {
    bar.wait();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SignalWithoutCorrespondingAwait" defaultSeverity="WARNING" displayName="'signal()' without corresponding 'await()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Condition.signal()&lt;/code&gt; or &lt;code&gt;Condition.signalAll()&lt;/code&gt;
for which no call to a corresponding &lt;code&gt;Condition.await()&lt;/code&gt; can be found.
&lt;p&gt;Only calls that target fields of the current class are reported by this inspection.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Queue {
    private final Condition isEmpty = ...;

    void add(Object elem) {
      // ...
      isEmpty.signal(); // warning: Call to 'signal()' without corresponding 'await()'
      // ...
    }

    void remove(Object elem) throws InterruptedException {
      // ...
      //      isEmpty.await();
      // ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionSignal" defaultSeverity="WARNING" displayName="Call to 'signal()' instead of 'signalAll()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.util.concurrent.locks.Condition.signal()&lt;/code&gt;. While occasionally useful, in almost all cases
&lt;code&gt;signalAll()&lt;/code&gt; is a better and safer choice.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AwaitWithoutCorrespondingSignal" defaultSeverity="WARNING" displayName="'await()' without corresponding 'signal()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Condition.await()&lt;/code&gt;,
for which no call to a corresponding &lt;code&gt;Condition.signal()&lt;/code&gt; or &lt;code&gt;Condition.signalAll()&lt;/code&gt; can be found.
&lt;p&gt;
  Calling &lt;code&gt;Condition.await()&lt;/code&gt; in a thread without corresponding &lt;code&gt;Condition.signal()&lt;/code&gt; may cause the thread
  to become disabled until it is interrupted or "spurious wakeup" occurs.
&lt;/p&gt;
&lt;p&gt;Only calls that target fields of the current class are reported by this inspection.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Queue {
    private final Condition isEmpty = ...;

    void add(Object elem) {
      // ...
      // isEmpty.signal();
      // ...
    }

    void remove(Object elem) throws InterruptedException {
      // ...
      isEmpty.await(); // 'await()' doesn't contain corresponding 'signal()'/'signalAll()' call
      // ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitNotInLoop" defaultSeverity="WARNING" displayName="'wait()' not called in loop" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;wait()&lt;/code&gt; that are not made inside a loop.
&lt;p&gt;
  &lt;code&gt;wait()&lt;/code&gt; is normally used to suspend a thread until some condition becomes true.
  As the thread could have been waken up for a different reason,
  the condition should be checked after the &lt;code&gt;wait()&lt;/code&gt; call returns.
  A loop is a simple way to achieve this.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class BoundedCounter {
    private int count;
    synchronized void inc() throws InterruptedException {
      if (count &gt;= 10) wait();
      ++count;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Good code should look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class BoundedCounter {
    private int count;
    synchronized void inc() throws InterruptedException {
      while (count &gt;= 10) wait();
      ++count;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectNotify" defaultSeverity="WARNING" displayName="Call to 'notify()' instead of 'notifyAll()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Object.notify()&lt;/code&gt;. While occasionally useful, in almost all cases
&lt;code&gt;Object.notifyAll()&lt;/code&gt; is a better choice because calling &lt;code&gt;Object.notify()&lt;/code&gt; may lead to deadlocks.
See Doug Lea's &lt;i&gt;Concurrent Programming in Java&lt;/i&gt; for a discussion.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NakedNotify" defaultSeverity="WARNING" displayName="'notify()' or 'notifyAll()' without corresponding state change" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Object.notify()&lt;/code&gt; or &lt;code&gt;Object.notifyAll()&lt;/code&gt; being called without any detectable state change occurring.
&lt;p&gt;
  Normally, &lt;code&gt;Object.notify()&lt;/code&gt; and &lt;code&gt;Object.notifyAll()&lt;/code&gt; are used to inform other threads that a state change has
  occurred. That state change should occur in a synchronized context that contains the &lt;code&gt;Object.notify()&lt;/code&gt; or
  &lt;code&gt;Object.notifyAll()&lt;/code&gt; call, and prior to the call. While not having such a state change isn't necessarily incorrect, it is
  certainly worth examining.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  synchronized (this) {
    notify();
  }
  // no state change
  synchronized (this) {
    notify(); // this notify might be redundant
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SharedThreadLocalRandom" defaultSeverity="WARNING" displayName="'ThreadLocalRandom' instance might be shared" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;java.util.concurrent.ThreadLocalRandom&lt;/code&gt; instances which might be shared between threads.
&lt;p&gt;
  A &lt;code&gt;ThreadLocalRandom&lt;/code&gt; should not be shared between threads because that is not thread-safe.
  The inspection reports instances that are assigned to a field used as a method argument,
  or assigned to a local variable and used in anonymous or nested classes as they might get shared between threads.
&lt;/p&gt;
&lt;p&gt;
  Usages of &lt;code&gt;ThreadLocalRandom&lt;/code&gt; should typically look like &lt;code&gt;ThreadLocalRandom.current().nextInt(...)&lt;/code&gt;
  (or &lt;code&gt;nextDouble(...)&lt;/code&gt; etc.).
  When all usages are in this form, &lt;code&gt;ThreadLocalRandom&lt;/code&gt; instances cannot be used accidentally by multiple threads.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    class Main {
      void printRandomNumbersAsync() {
        ThreadLocalRandom random = ThreadLocalRandom.current();
        CompletableFuture.supplyAsync(() -&amp;gt; generateNumbers(random))
          .thenAccept(numbers -&amp;gt; System.out.println(Arrays.toString(numbers)));
      }

      private int[] generateNumbers(Random random) {
        return random.ints(1000, 0, 100).toArray();
      }
    }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the options to list methods that are safe to be passed to &lt;code&gt;ThreadLocalRandom&lt;/code&gt; instances as an argument.
  It's possible to use regular expressions for method names.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicFieldAccessedInSynchronizedContext" defaultSeverity="WARNING" displayName="Non-private field accessed in 'synchronized' context" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-&lt;code&gt;final&lt;/code&gt;, non-&lt;code&gt;private&lt;/code&gt; fields that are accessed in a synchronized context.
&lt;p&gt;
  A non-&lt;code&gt;private&lt;/code&gt; field cannot be guaranteed to always be accessed in a synchronized manner, and such "partially synchronized"
  access may result in unexpectedly inconsistent data structures.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar {
    public String field1;
  }
  public Bar myBar;

  synchronized public void sample() {
   myBar.field1 = "bar";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WaitCalledOnCondition" defaultSeverity="WARNING" displayName="'wait()' called on 'java.util.concurrent.locks.Condition' object" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;wait()&lt;/code&gt; made on a &lt;code&gt;java.util.concurrent.locks.Condition&lt;/code&gt;
object. This is probably a programming error, and some variant of the &lt;code&gt;await()&lt;/code&gt; method was intended instead.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void acquire(Condition released) throws InterruptedException {
    while (acquired) {
      released.wait();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Good code would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void acquire(Condition released) throws InterruptedException {
    while (acquired) {
      released.await();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Migration" path="Kotlin"><inspection shortName="KotlinDeprecation" defaultSeverity="WARNING" displayName="Usage of redundant or deprecated syntax or deprecated symbols" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports obsolete language features and unnecessarily verbose code constructs during the code cleanup operation (&lt;b&gt;Code | Code Cleanup&lt;/b&gt;).
&lt;p&gt;
A quick-fix automatically replaces usages of obsolete language features or unnecessarily verbose code constructs with compact and up-to-date syntax.
&lt;p&gt;
It also replaces deprecated symbols with their proposed substitutions.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ObsoleteExperimentalCoroutines" defaultSeverity="ERROR" displayName="Experimental coroutines usages are deprecated since 1.3" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code that uses experimental coroutines.
&lt;p&gt;Such usages are incompatible with Kotlin 1.3+ and should be updated.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastDueToProgressionResolutionChangeMigration" defaultSeverity="WARNING" displayName="Progression resolution change since 1.9" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
    Reports overloaded function calls where an argument requires an explicit cast to resolve to a proper declaration.
    The current compiler warning (available since Kotlin 1.6.20) will become an error in Kotlin 1.8.
&lt;/p&gt;
&lt;p&gt;
    Progressions and ranges types (&lt;code&gt;kotlin.ranges&lt;/code&gt;) will start implementing the &lt;code&gt;Collection&lt;/code&gt; interface in Kotlin
    1.9 and later. This update will cause a change in resolution for overloaded functions. For instance, in the example below, the
    &lt;code&gt;test(1..5)&lt;/code&gt; call will be resolved to &lt;code&gt;test(t: Any)&lt;/code&gt; in Kotlin 1.8 and earlier and to
    &lt;code&gt;test(t: Collection&amp;lt;*&amp;gt;)&lt;/code&gt; in Kotlin 1.9 and later.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(t: Any) { }
  fun test(t: Collection&amp;lt;*&amp;gt;) { }
  fun invoke() {
    test(1..5) // IntRange becomes Collection in 1.9
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The provided quick-fix captures the behaviour specific to the compiler of version 1.8 and earlier:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(t: Any) { }
  fun test(t: Collection&amp;lt;*&amp;gt;) { }

  fun invoke() {
    test(1..5) // resolved to 'test(t: T)' before Kotlin 1.9
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(t: Any) { }
  fun test(t: Collection&amp;lt;*&amp;gt;) { }

  fun invoke() {
    test((1..5) as Iterable&amp;lt;Int&amp;gt;) // resolved to 'test(t: T)' in Kotlin 1.9
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inspection is available for the Kotlin language level starting from 1.6.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonExhaustiveWhenStatementMigration" defaultSeverity="WARNING" displayName="Non-exhaustive 'when' statements will be prohibited since 1.7" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a non-exhaustive &lt;code&gt;when&lt;/code&gt; statements that will lead to compilation error since 1.7.
&lt;p&gt;Motivation types:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;
        Problematic/meaningless usage patterns need to be discouraged/blocked (e.g. counterintuitive behaviors)
        &lt;ul&gt;
            &lt;li&gt;
                Code is error-prone
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;
        Inconsistency in the design (things are done differently in different contexts)
    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Impact types:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;
        Compilation. Some code that used to compile won't compile any more
        &lt;ul&gt;
            &lt;li&gt;
                There were cases when such code worked with no exceptions
                &lt;ul&gt;
                    &lt;li&gt;
                        Some such code could compile without any warnings
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;More details:&lt;/b&gt; &lt;a href="https://youtrack.jetbrains.com/issue/KT-47709"&gt;KT-47709: Make when statements with enum, sealed, and Boolean subjects exhaustive by default&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The quick-fix adds the missing &lt;code&gt;else -&gt; {}&lt;/code&gt; branch.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class &lt;b&gt;Base&lt;/b&gt; {
      class &lt;b&gt;A&lt;/b&gt; : &lt;b&gt;Base&lt;/b&gt;()
      class &lt;b&gt;B&lt;/b&gt; : &lt;b&gt;Base&lt;/b&gt;()
  }

  fun test(base: &lt;b&gt;Base&lt;/b&gt;) {
      when (base) {
          is &lt;b&gt;Base&lt;/b&gt;.&lt;b&gt;A&lt;/b&gt; -&gt; ""
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class &lt;b&gt;Base&lt;/b&gt; {
      class &lt;b&gt;A&lt;/b&gt; : &lt;b&gt;Base&lt;/b&gt;()
      class &lt;b&gt;B&lt;/b&gt; : &lt;b&gt;Base&lt;/b&gt;()
  }

  fun test(base: &lt;b&gt;Base&lt;/b&gt;) {
      when (base) {
          is &lt;b&gt;Base&lt;/b&gt;.&lt;b&gt;A&lt;/b&gt; -&gt; ""
          else -&gt; {}
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the Kotlin language level of the project or module is 1.6 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProhibitTypeParametersForLocalVariablesMigration" defaultSeverity="ERROR" displayName="Local variable with type parameters" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports local variables with type parameters.&lt;/p&gt;
&lt;p&gt;A type parameter for a local variable doesn't make sense because it can't be specialized.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val &amp;lt;T&amp;gt; x = ""
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val x = ""
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the Kotlin language level of the project or module is 1.4 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ProhibitUseSiteTargetAnnotationsOnSuperTypesMigration" defaultSeverity="ERROR" displayName="Meaningless annotations targets on superclass" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports meaningless annotation targets on superclasses since Kotlin 1.4.&lt;/p&gt;
&lt;p&gt;Annotation targets such as &lt;code&gt;@get:&lt;/code&gt; are meaningless on superclasses and are prohibited.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface Foo

  annotation class Ann

  class E : @field:Ann @get:Ann @set:Ann @setparam:Ann Foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface Foo

  annotation class Ann

  class E : Foo
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the Kotlin language level of the project or module is 1.4 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RestrictReturnStatementTargetMigration" defaultSeverity="ERROR" displayName="Target label does not denote a function since 1.4" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports labels that don't points to a functions.
&lt;p&gt;It's forbidden to declare a target label that does not denote a function.&lt;/p&gt;
&lt;p&gt;The quick-fix removes the label.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun testValLabelInReturn() {
      L@ val fn = { return@L }
      fn()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun testValLabelInReturn() {
      L@ val fn = { return }
      fn()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 1.4 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProhibitRepeatedUseSiteTargetAnnotationsMigration" defaultSeverity="ERROR" displayName="Repeated annotation which is not marked as '@Repeatable'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports the repeated use of a non-&lt;code&gt;@Repeatable&lt;/code&gt; annotation on property accessors.&lt;/p&gt;
&lt;p&gt;
    As a result of using non-&lt;code&gt;@Repeatable&lt;/code&gt; annotation multiple times, both annotation usages
    will appear in the bytecode leading to an ambiguity in reflection calls.
&lt;/p&gt;
&lt;p&gt;
    Since Kotlin 1.4 it's mandatory to either mark annotation as &lt;code&gt;@Repeatable&lt;/code&gt; or not
    repeat the annotation, otherwise it will lead to compilation error.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  annotation class Foo(val x: Int)

  @get:&lt;b&gt;Foo&lt;/b&gt;(10)
  val a: String
      @&lt;b&gt;Foo&lt;/b&gt;(20) get() = "foo" // annotation repeated twice but not marked as @Repeatable
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the Kotlin language level of the project or module is 1.4 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AddConversionCallMigration" defaultSeverity="WARNING" displayName="Explicit conversion from `Int` needed since 1.9" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports expressions that will be of type &lt;code&gt;Int&lt;/code&gt;, thus causing compilation errors in Kotlin 1.9 and later.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun takeByte(x: Byte) {}

  fun foo() {
      takeByte(1 + 1) // will be resolved to Int in 1.9
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun takeByte(x: Byte) {}

  fun foo() {
      takeByte((1 + 1).toByte()) // will be resolved to Int in 1.9
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inspection is available for Kotlin language level starting from 1.7.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NoConstructorMigration" defaultSeverity="ERROR" displayName="Forbidden constructor call" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a constructor calls on functional supertypes that will lead to compilation error since 1.9.
&lt;p&gt;Motivation types:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;
        The implementation does not abide by a published spec or documentation
    &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;More details:&lt;/b&gt; &lt;a href="https://youtrack.jetbrains.com/issue/KT-46344"&gt;KT-46344: No error for a super class constructor call on a function interface in supertypes list&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The quick-fix removes a constructor call.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class A : () -&gt; Int()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class A : () -&gt; Int
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the Kotlin language level of the project or module is 1.7 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FromClosedRangeMigration" defaultSeverity="WEAK WARNING" displayName="MIN_VALUE step in fromClosedRange() since 1.3" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;IntProgression.fromClosedRange()&lt;/code&gt; and &lt;code&gt;LongProgression.fromClosedRange()&lt;/code&gt; with
&lt;code&gt;MIN_VALUE&lt;/code&gt; step.
&lt;p&gt;
It is prohibited to call &lt;code&gt;IntProgression.fromClosedRange()&lt;/code&gt; and &lt;code&gt;LongProgression.fromClosedRange()&lt;/code&gt; with
&lt;code&gt;MIN_VALUE&lt;/code&gt; step. All such calls should be checked during migration to Kotlin 1.3+.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  IntProgression.fromClosedRange(12, 143, Int.MIN_VALUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix the problem change the step of the progression.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OverrideDeprecatedMigration" defaultSeverity="ERROR" displayName="Do not propagate method deprecation through overrides since 1.9" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a declarations that are propagated by &lt;code&gt;@Deprecated&lt;/code&gt; annotation that will lead to compilation error since 1.9.
&lt;p&gt;Motivation types:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;
        Implementation changes are required for implementation design/architectural reasons
    &lt;/li&gt;
    &lt;li&gt;
        Inconsistency in the design (things are done differently in different contexts)
    &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;More details:&lt;/b&gt; &lt;a href="https://youtrack.jetbrains.com/issue/KT-47902"&gt;KT-47902: Do not propagate method deprecation through overrides&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The quick-fix copies &lt;code&gt;@Deprecated&lt;/code&gt; annotation from the parent declaration.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  open class &lt;b&gt;Base&lt;/b&gt; {
      @Deprecated("Don't use")
      open fun foo() {}
  }

  class &lt;b&gt;Derived&lt;/b&gt; : &lt;b&gt;Base&lt;/b&gt;() {
      override fun foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  open class &lt;b&gt;Base&lt;/b&gt; {
      @Deprecated("Don't use")
      open fun foo() {}
  }

  class &lt;b&gt;Derived&lt;/b&gt; : &lt;b&gt;Base&lt;/b&gt;() {
      @Deprecated("Don't use")
      override fun foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the Kotlin language level of the project or module is 1.6 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObsoleteKotlinJsPackages" defaultSeverity="ERROR" displayName="'kotlin.browser' and 'kotlin.dom' packages are deprecated since 1.4" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;kotlin.dom&lt;/code&gt; and &lt;code&gt;kotlin.browser&lt;/code&gt; packages.
&lt;p&gt;These packages were moved to &lt;code&gt;kotlinx.dom&lt;/code&gt; and &lt;code&gt;kotlinx.browser&lt;/code&gt;
    respectively in Kotlin 1.4+.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantLabelMigration" defaultSeverity="WEAK WARNING" displayName="Redundant label" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports redundant labels which cause compilation errors since Kotlin 1.4.&lt;/p&gt;
&lt;p&gt;Since Kotlin 1.0, one can mark any statement with a label:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
    L1@ val x = L2@bar()
  }
&lt;/code&gt;&lt;/pre&gt;
However, these labels can be referenced only in a limited number of ways:
&lt;ul&gt;
    &lt;li&gt;break / continue from a loop&lt;/li&gt;
    &lt;li&gt;non-local return from an inline lambda or inline anonymous function&lt;/li&gt;sssss
&lt;/ul&gt;
&lt;p&gt;Such labels are prohibited since Kotlin 1.4.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the Kotlin language level of the project or module is 1.4 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AmbiguousExpressionInWhenBranchMigration" defaultSeverity="WARNING" displayName="Ambiguous logical expressions in 'when' branches since 1.7" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports ambiguous logical expressions in &lt;code&gt;when&lt;/code&gt; branches which cause compilation errors in Kotlin 1.8 and later.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Int.matches(strict: Boolean): Boolean = when (strict) {
      true -&gt; this == 6
      this in (4..7) -&gt; true // is ambiguous
      else -&gt; false
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Int.matches(strict: Boolean): Boolean = when (strict) {
      true -&gt; this == 6
      (this in (4..7)) -&gt; true // wrapped in parentheses
      else -&gt; false
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inspection is available for Kotlin language level starting from 1.7.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InlineClassDeprecatedMigration" defaultSeverity="WARNING" displayName="Inline classes are deprecated since 1.5" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
    Reports inline classes that are deprecated and cause compilation warnings in Kotlin 1.5 and later.
    See &lt;a href="https://kotlinlang.org/docs/whatsnew15.html#inline-classes"&gt;What's new in Kotlin 1.5.0&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  inline class Password(val s: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @JvmInline
  value class Password(val s: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inspection is available for Kotlin language level starting from 1.5.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WarningOnMainUnusedParameterMigration" defaultSeverity="WEAK WARNING" displayName="Unused 'args' on 'main' since 1.4" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;main&lt;/code&gt; function with an unused single parameter.
&lt;p&gt;Since Kotlin 1.4, it is possible to use the &lt;code&gt;main&lt;/code&gt; function without parameter as the entry point to the Kotlin program.
The compiler reports a warning for the &lt;code&gt;main&lt;/code&gt; function with an unused parameter.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ProhibitJvmOverloadsOnConstructorsOfAnnotationClassesMigration" defaultSeverity="ERROR" displayName="'@JvmOverloads' annotation cannot be used on constructors of annotation classes since 1.4" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports &lt;code&gt;@JvmOverloads&lt;/code&gt; on constructors of annotation classes because it's meaningless.&lt;/p&gt;
&lt;p&gt;
    There is no footprint of &lt;code&gt;@JvmOverloads&lt;/code&gt; in the generated bytecode and Kotlin metadata,
    so &lt;code&gt;@JvmOverloads&lt;/code&gt; doesn't affect the generated bytecode and the code behavior.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@JvmOverloads&lt;/code&gt; on constructors of annotation classes causes a compilation error since Kotlin 1.4.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  annotation class A &lt;b&gt;@JvmOverloads&lt;/b&gt; constructor(val x: Int = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  annotation class A constructor(val x: Int = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="JSON and JSON5" path=""><inspection shortName="JsonPathUnknownFunction" defaultSeverity="WARNING" displayName="Unknown JSONPath function" enabled="true" language="JSONPath" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unknown name in a JSONPath function call instead of known standard function names:
&lt;code&gt;concat&lt;/code&gt;, &lt;code&gt;keys&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt;, &lt;code&gt;stddev&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonPathUnknownOperator" defaultSeverity="WARNING" displayName="Unknown JSONPath operator" enabled="true" language="JSONPath" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unknown operator on a JSONPath expression instead of one of the standard ones: 
&lt;code&gt;in&lt;/code&gt;, &lt;code&gt;nin&lt;/code&gt;, &lt;code&gt;subsetof&lt;/code&gt;, &lt;code&gt;anyof&lt;/code&gt;, &lt;code&gt;noneof&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt;.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonSchemaRefReference" defaultSeverity="WARNING" displayName="Unresolved '$ref' and '$schema' references" enabled="true" language="JSON" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unresolved &lt;code&gt;$ref&lt;/code&gt; or &lt;code&gt;$schema&lt;/code&gt; path in a JSON schema.&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonSchemaCompliance" defaultSeverity="WARNING" displayName="Compliance with JSON schema" enabled="true" language="JSON" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports inconsistence between a JSON file and the &lt;a href="https://json-schema.org"&gt;JSON schema&lt;/a&gt; that is assigned to it.&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonSchemaDeprecation" defaultSeverity="WEAK WARNING" displayName="Deprecated JSON property" enabled="true" language="JSON" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a deprecated property in a JSON file.&lt;br&gt;
Note that deprecation mechanism is not defined in the JSON Schema specification yet,
and this inspection uses a non-standard extension 'deprecationMessage'.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonPathEvaluateUnknownKey" defaultSeverity="WARNING" displayName="Unknown property key used for JSONPath evaluate expression" enabled="true" language="JSONPath" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a key in a JSONPath expression that is missing in the source JSON document to evaluate.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonDuplicatePropertyKeys" defaultSeverity="WARNING" displayName="Duplicate keys in object literals" enabled="true" language="JSON" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a duplicate key in an object literal.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Json5StandardCompliance" defaultSeverity="ERROR" displayName="Compliance with JSON5 standard" enabled="true" language="JSON5" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports inconsistency with &lt;a href="http://json5.org"&gt;the language specification&lt;/a&gt; in a JSON5 file.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JsonStandardCompliance" defaultSeverity="ERROR" displayName="Compliance with JSON standard" enabled="true" language="JSON" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the following discrepancies of a JSON file with  &lt;a href="https://tools.ietf.org/html/rfc7159"&gt;the language specification&lt;/a&gt;:
&lt;ul&gt;
  &lt;li&gt;A line or  block comment (configurable).&lt;/li&gt;
  &lt;li&gt;Multiple top-level values (expect for JSON Lines files, configurable for others).&lt;/li&gt;
  &lt;li&gt;A trailing comma in an object or array (configurable).&lt;/li&gt;
  &lt;li&gt;A single quoted string.&lt;/li&gt;
  &lt;li&gt;A property key is a not a double quoted strings.&lt;/li&gt;
  &lt;li&gt;A NaN or Infinity/-Infinity numeric value as a floating point literal (configurable).&lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Naming conventions" path="Kotlin"><inspection shortName="TestFunctionName" defaultSeverity="WEAK WARNING" displayName="Test function naming convention" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports test function names that do not follow the &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#names-for-test-methods"&gt;recommended naming conventions&lt;/a&gt;.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PropertyName" defaultSeverity="WEAK WARNING" displayName="Property naming convention" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports property names that do not follow the recommended naming conventions.&lt;/p&gt;
&lt;p&gt;
    Consistent naming allows for easier code reading and understanding.
    According to the &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;Kotlin official style guide&lt;/a&gt;,
    property names should start with a lowercase letter and use camel case.
&lt;/p&gt;
&lt;p&gt;It is possible to introduce other naming rules by changing the "Pattern" regular expression.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val My_Cool_Property = ""
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix renames the class according to the Kotlin naming conventions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val myCoolProperty = ""
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassName" defaultSeverity="WEAK WARNING" displayName="Class naming convention" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports class names that do not follow the recommended naming conventions.
&lt;p&gt;
    Consistent naming allows for easier code reading and understanding.
    According to the &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;Kotlin official style guide&lt;/a&gt;,
    class names should start with an uppercase letter and use camel case.
&lt;/p&gt;
&lt;p&gt;It is possible to introduce other naming rules by changing the "Pattern" regular expression.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class user(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix renames the class according to the Kotlin naming conventions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageName" defaultSeverity="WEAK WARNING" displayName="Package naming convention" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports package names that do not follow the naming conventions.
&lt;p&gt;You can specify the required pattern in the inspection options.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;Recommended naming conventions&lt;/a&gt;: names of packages are always lowercase and should not contain underscores.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;code&gt;org.example.project&lt;/code&gt;
&lt;p&gt;Using multi-word names is generally discouraged, but if you do need to use multiple words, you can either just concatenate them together or use camel case&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;code&gt;org.example.myProject&lt;/code&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PrivatePropertyName" defaultSeverity="WEAK WARNING" displayName="Private property naming convention" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports private property names that do not follow the recommended naming conventions.&lt;/p&gt;
&lt;p&gt;
    Consistent naming allows for easier code reading and understanding.
    According to the &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;Kotlin official style guide&lt;/a&gt;,
    private property names should start with a lowercase letter and use camel case.
    Optionally, underscore prefix is allowed but only for &lt;b&gt;private&lt;/b&gt; properties.
&lt;/p&gt;
&lt;p&gt;It is possible to introduce other naming rules by changing the "Pattern" regular expression.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val _My_Cool_Property = ""
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix renames the class according to the Kotlin naming conventions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val _myCoolProperty = ""
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnumEntryName" defaultSeverity="WEAK WARNING" displayName="Enum entry naming convention" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports enum entry names that do not follow the recommended naming conventions.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum class Foo {
    _Foo,
    foo
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix the problem rename enum entries to match the recommended naming conventions.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalVariableName" defaultSeverity="WEAK WARNING" displayName="Local variable naming convention" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local variables that do not follow the naming conventions.
&lt;p&gt;You can specify the required pattern in the inspection options.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#function-names"&gt;Recommended naming conventions&lt;/a&gt;: it has to start with a lowercase letter, use camel case and no underscores.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun fibonacciNumber(index: Int): Long = when(index) {
      0 -&gt; 0
      else -&gt; {
          // does not follow naming conventions: contains underscore symbol (`_`)
          var number_one: Long = 0
          // does not follow naming conventions: starts with an uppercase letter
          var NUMBER_TWO: Long = 1
          // follow naming conventions: starts with a lowercase letter, use camel case and no underscores.
          var numberThree: Long = number_one + NUMBER_TWO

          for(currentIndex in 2..index) {
              numberThree = number_one + NUMBER_TWO
              number_one = NUMBER_TWO
              NUMBER_TWO = numberThree
          }
          numberThree
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionName" defaultSeverity="WEAK WARNING" displayName="Function naming convention" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports function names that do not follow the recommended naming conventions.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Foo() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix the problem change the name of the function to match the recommended naming conventions.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectPropertyName" defaultSeverity="WEAK WARNING" displayName="Object property naming convention" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports properties that do not follow the naming conventions.
&lt;p&gt;The following properties are reported:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Top-level properties&lt;/li&gt;
    &lt;li&gt;Properties in objects and companion objects&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can specify the required pattern in the inspection options.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kotlinlang.org/docs/coding-conventions.html#naming-rules"&gt;Recommended naming conventions&lt;/a&gt;: it has to start with an uppercase letter, use camel case and no underscores.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // top-level property
  val USER_NAME_FIELD = "UserName"
  // top-level property holding reference to singleton object
  val PersonComparator: Comparator&amp;lt;Person&amp;gt; = /*...*/

  class Person {
    companion object {
      // property in companion object
      val NO_NAME = Person()
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InconsistentCommentForJavaParameter" defaultSeverity="WARNING" displayName="Inconsistent comment for Java parameter" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports inconsistent parameter name for &lt;b&gt;java&lt;/b&gt; method specified in a comment block.
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Java
  public class JavaService {
      public void invoke(String command) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
  // Kotlin
  fun main() {
      JavaService().invoke(/* name = */ "fix")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix corrects parameter name in a comment block:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      JavaService().invoke(/* command = */ "fix")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstPropertyName" defaultSeverity="WEAK WARNING" displayName="Const property naming convention" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;const&lt;/code&gt; property names that do not follow the recommended naming conventions.
&lt;p&gt;
    Consistent naming allows for easier code reading and understanding.
    According to the &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#property-names"&gt;Kotlin official style guide&lt;/a&gt;,
    &lt;code&gt;const&lt;/code&gt; properties should use uppercase underscore-separated names.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  const val Planck: Double = 6.62607015E-34
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix renames the property:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  const val PLANCK: Double = 6.62607015E-34
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Class metrics" path="Java"><inspection shortName="AnonymousClassComplexity" defaultSeverity="WARNING" displayName="Overly complex anonymous class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports anonymous inner classes whose total complexity exceeds the specified maximum.
&lt;p&gt;The total complexity of a class is the sum of cyclomatic complexities of all the methods
  and initializers the class declares. Inherited methods and initializers are not counted
  toward the total complexity.&lt;/p&gt;
&lt;p&gt;Anonymous classes should have very low complexity otherwise they are hard to understand and should be promoted to become named inner classes.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Cyclomatic complexity limit&lt;/b&gt; field to specify the maximum allowed complexity for a class.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstructorCount" defaultSeverity="WARNING" displayName="Class with too many constructors" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes whose number of constructors exceeds the specified maximum.
&lt;p&gt;Classes with too many constructors are prone to initialization errors, and often modeling such a class as multiple subclasses is preferable.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Constructor count limit&lt;/b&gt; field to specify the maximum allowed number of constructors in a class.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore deprecated constructors&lt;/b&gt; option to avoid adding deprecated constructors to the total count.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassNestingDepth" defaultSeverity="WARNING" displayName="Inner class too deeply nested" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes whose number of nested inner classes exceeds the specified maximum.
&lt;p&gt;Nesting inner classes inside other inner classes is confusing and indicates that a refactoring may be necessary.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Nesting limit&lt;/b&gt; field to specify the maximum allowed nesting depth for a class.&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassInheritanceDepth" defaultSeverity="WARNING" displayName="Class too deep in inheritance tree" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that are too deep in the inheritance hierarchy.
&lt;p&gt;Classes that are too deeply inherited may be confusing and indicate that a refactoring is necessary.&lt;/p&gt;
&lt;p&gt;All superclasses from a library are treated as a single superclass, libraries are considered unmodifiable.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Inheritance depth limit&lt;/b&gt; field to specify the maximum inheritance depth for a class.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousClassMethodCount" defaultSeverity="WARNING" displayName="Anonymous inner class with too many methods" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports anonymous inner classes whose method count exceeds the specified maximum.
&lt;p&gt;Anonymous classes with numerous methods may be
  difficult to understand and should be promoted to become named inner classes.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Method count limit&lt;/b&gt; field to specify the maximum allowed number of methods in an anonymous inner class.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldCount" defaultSeverity="WARNING" displayName="Class with too many fields" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes whose number of fields exceeds the specified maximum.
&lt;p&gt;Classes with a large number of fields are often trying to do too much. Consider splitting such a class into multiple smaller classes.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Field count limit&lt;/b&gt; field to specify the maximum allowed number of fields in a class.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Include constant fields in count&lt;/b&gt; option to indicate whether constant fields should be counted.&lt;/li&gt;
  &lt;li&gt;By default only immutable &lt;code&gt;static final&lt;/code&gt; objects are counted as constants. Use the &lt;b&gt;'static final' fields count as constant&lt;/b&gt; option
    to count any &lt;code&gt;static final&lt;/code&gt; field as constant.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Include enum constants in count&lt;/b&gt; option to specify whether &lt;code&gt;enum&lt;/code&gt; constants in &lt;code&gt;enum&lt;/code&gt; classes
    should be counted.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassCoupling" defaultSeverity="WARNING" displayName="Overly coupled class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that reference too many other classes.
&lt;p&gt;Classes with too high coupling can be very fragile, and should probably be split into smaller classes.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Class coupling limit&lt;/b&gt; field to specify the maximum allowed coupling for a class.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Include couplings to java system classes&lt;/b&gt; option to specify whether references to system classes
    (those in the &lt;code&gt;java.&lt;/code&gt;or &lt;code&gt;javax.&lt;/code&gt; packages) should be counted.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Include couplings to library classes&lt;/b&gt; option to specify whether references to any library classes should be counted.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodCount" defaultSeverity="WARNING" displayName="Class with too many methods" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes whose number of methods exceeds the specified maximum.
&lt;p&gt;Classes with too many methods are often trying to 'do too much'. Consider splitting such a class into multiple smaller classes.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Method count limit&lt;/b&gt; field to specify the maximum allowed number of methods in a class.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore simple getter and setter methods&lt;/b&gt; option to ignore simple getters and setters in method count.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore methods overriding/implementing a super method&lt;/b&gt; to ignore methods that override or implement a method
    from a superclass.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassComplexity" defaultSeverity="WARNING" displayName="Overly complex class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes whose total complexity exceeds the specified maximum.
&lt;p&gt;The total complexity of a class is the sum of cyclomatic complexities of all the methods
  and initializers the class declares. Inherited methods and initializers are not counted
  toward the total complexity.&lt;/p&gt;
&lt;p&gt;Too high complexity indicates that the class should be refactored into several smaller classes.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Cyclomatic complexity limit&lt;/b&gt; field below to specify the maximum allowed complexity for a class.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Kotlin" path=""><inspection shortName="KotlinInvalidBundleOrProperty" defaultSeverity="ERROR" displayName="Invalid property key" enabled="true" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unresolved references to &lt;code&gt;.properties&lt;/code&gt; file keys and resource bundles in Kotlin files.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DifferentKotlinGradleVersion" defaultSeverity="WARNING" displayName="Kotlin Gradle and IDE plugins versions are different" enabled="true" language="Groovy" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports that different IDE and Gradle plugin versions are used.
&lt;p&gt;This can cause inconsistencies between IDE and Gradle builds in error reporting or code behavior.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:0.0.1"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix the problem change the kotlin gradle plugin version to match the version of kotlin that is bundled into the IDE plugin.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DifferentStdlibGradleVersion" defaultSeverity="WARNING" displayName="Kotlin library and Gradle plugin versions are different" enabled="true" language="Groovy" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports different Kotlin stdlib and compiler versions.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
    classpath "org.jetbrains.kotlin:kotlin-stdlib:0.0.1"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix the problem change the kotlin stdlib version to match the kotlin compiler version.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeprecatedGradleDependency" defaultSeverity="WARNING" displayName="Deprecated library is used in Gradle" enabled="true" language="Groovy" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports deprecated dependencies in Gradle build scripts.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
      compile "org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.0"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  dependencies {
      compile "org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.2.0"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Control flow issues" path="Java"><inspection shortName="NegatedConditionalExpression" defaultSeverity="WARNING" displayName="Negated conditional expression" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports conditional expressions which are negated with a prefix expression, as
such constructions may be confusing.
&lt;p&gt;There is a fix that propagates the outer negation to both branches.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  !(i == 1 ? a : b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  i == 1 ? !a : !b
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementWithTooFewBranches" defaultSeverity="WARNING" displayName="Minimum 'switch' branches" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;switch&lt;/code&gt; statements and expressions with too few &lt;code&gt;case&lt;/code&gt; labels, and suggests rewriting them as &lt;code&gt;if&lt;/code&gt;
and
&lt;code&gt;else if&lt;/code&gt; statements.
&lt;p&gt;Example (minimum branches == 3):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (expression) {
    case "foo" -&amp;gt; foo();
    case "bar" -&amp;gt; bar();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if ("foo".equals(expression)) {
    foo();
  } else if ("bar".equals(expression)) {
    bar();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Minimum number of branches&lt;/b&gt; field to specify the minimum expected number of &lt;code&gt;case&lt;/code&gt; labels.&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Do not report pattern switch statements&lt;/b&gt; option to avoid reporting switch statements and expressions that
have pattern branches. E.g.:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String result = switch(obj) {
    case String str -&gt; str.trim();
    default -&gt; "none";
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It might be preferred to keep the switch even with a single pattern branch, rather than using the &lt;code&gt;instanceof&lt;/code&gt; statement.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConfusingElse" defaultSeverity="INFORMATION" displayName="Redundant 'else'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant &lt;code&gt;else&lt;/code&gt; keywords in &lt;code&gt;if&lt;/code&gt;&amp;mdash;&lt;code&gt;else&lt;/code&gt; statements and statement chains.
&lt;p&gt;
The &lt;code&gt;else&lt;/code&gt; keyword is redundant when it cannot be reached because the code in previous branches ends with the
&lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, or &lt;code&gt;continue&lt;/code&gt; statement. In this case,
the statements from the &lt;code&gt;else&lt;/code&gt; branch can be placed after the &lt;code&gt;if&lt;/code&gt; statement, and the
&lt;code&gt;else&lt;/code&gt; keyword can be removed.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (name == null) {
      throw new IllegalArgumentException();
  } else {
      System.out.println(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (name == null) {
      throw new IllegalArgumentException();
  }
  System.out.println(name);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Disable the &lt;b&gt;Report when there are no more statements after the 'if' statement&lt;/b&gt; option to ignore the cases in which the &lt;code&gt;if&lt;/code&gt;&amp;mdash;&lt;code&gt;else&lt;/code&gt; statement is the last statement in a code block.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopWithImplicitTerminationCondition" defaultSeverity="WARNING" displayName="Loop with implicit termination condition" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any &lt;code&gt;while&lt;/code&gt;,
&lt;code&gt;do-while&lt;/code&gt;, and &lt;code&gt;for&lt;/code&gt;
loops that have the &lt;code&gt;true&lt;/code&gt; constant as their
only condition. At the same time, such loops can be still terminated by a containing
&lt;code&gt;if&lt;/code&gt; statement which can break out of the loop.
&lt;p&gt;Such an &lt;code&gt;if&lt;/code&gt; statement must be the first or the only statement
in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt;
loop and the last or the only statement in a &lt;code&gt;do-while&lt;/code&gt; loop.&lt;/p&gt;

&lt;p&gt;Removing the &lt;code&gt;if&lt;/code&gt; statement and making its condition an explicit
  loop condition simplifies the loop.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessNullCheck" defaultSeverity="WARNING" displayName="Unnecessary 'null' check before method call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports null checks followed by a method call that will definitely return
&lt;code&gt;false&lt;/code&gt; when &lt;code&gt;null&lt;/code&gt; is passed (e.g. &lt;code&gt;Class.isInstance&lt;/code&gt;).
&lt;p&gt;Such a check seems excessive as the method call will always return &lt;code&gt;false&lt;/code&gt; in this case.&lt;/p&gt;
&lt;p&gt;Example: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x != null &amp;&amp; myClass.isInstance(x)) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (myClass.isInstance(x)) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConditionalExpressionWithIdenticalBranches" defaultSeverity="WARNING" displayName="Conditional expression with identical branches" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports conditional expressions with identical &lt;code&gt;then&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; branches.
&lt;p&gt;Such expressions almost certainly indicate bugs. The inspection provides a fix that collapses conditional expressions.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = x == 10 ? 4 : 4;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = 4;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementDensity" defaultSeverity="WARNING" displayName="'switch' statement with too low of a branch density" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;switch&lt;/code&gt; statements or expressions
with a too low ratio of switch labels to executable statements.
&lt;p&gt;Such &lt;code&gt;switch&lt;/code&gt; statements
may be confusing and should probably be refactored.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch (i) { // one case and 5 executable statements -&gt; 20% density
        case 1:
            System.out.println("1");
            System.out.println("2");
            System.out.println("3");
            System.out.println("4");
            System.out.println("5");
            break;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;Use the &lt;b&gt;Minimum density of branches&lt;/b&gt; field to specify the allowed ratio of the switch labels to executable statements.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfCanBeAssertion" defaultSeverity="INFORMATION" displayName="Statement can be replaced with 'assert' or 'Objects.requireNonNull'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; statements that throw only &lt;code&gt;java.lang.Throwable&lt;/code&gt; from a &lt;code&gt;then&lt;/code&gt; branch
and do not have an &lt;code&gt;else&lt;/code&gt; branch. Such statements can be converted to more compact &lt;code&gt;assert&lt;/code&gt; statements.
&lt;p&gt;
The inspection also reports Guava's &lt;code&gt;Preconditions.checkNotNull()&lt;/code&gt;.
  They can be replaced with a &lt;code&gt;Objects.requireNonNull()&lt;/code&gt; call for which a library may not be needed.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;if&lt;/b&gt; (x == 2) &lt;b&gt;throw new&lt;/b&gt; RuntimeException("fail");
  &lt;b&gt;if&lt;/b&gt; (y == null) &lt;b&gt;throw new&lt;/b&gt; AssertionError();
  Preconditions.checkNotNull(z, "z");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;assert&lt;/b&gt; x != 2 : "fail";
  Objects.requireNonNull(y);
  Objects.requireNonNull(z, "z");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;By default, this inspection provides a quick-fix in the editor without code highlighting.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ForLoopWithMissingComponent" defaultSeverity="WARNING" displayName="'for' loop with missing components" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;for&lt;/code&gt; loops
that lack initialization, condition, or update clauses. Some coding styles prohibit such loops.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i = 0;;i++) {
    // body
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore collection iterations&lt;/b&gt; option to ignore loops which use an iterator.
This is a standard way to iterate over a collection in which the &lt;code&gt;for&lt;/code&gt; loop does not have an update clause.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IdempotentLoopBody" defaultSeverity="WARNING" displayName="Idempotent loop body" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports loops whose second and all subsequent iterations do not produce any additional side effects other
than the one produced by the first iteration, which can indicate a programming error.
&lt;p&gt;Such loops may iterate only zero, one, or infinite number of times.
If the infinite number of times case is unreachable, such a loop can be replaced with an &lt;code&gt;if&lt;/code&gt; statement.
  Otherwise, there's a possibility that the program can get stuck.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    public void foo(String baseName, String names) {
        int suffix = 1;
        String name = baseName;
        while (names.contains(name)) {
            // error: suffix is not updated making loop body idempotent
            name = baseName + suffix;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfStatementWithIdenticalBranches" defaultSeverity="WEAK WARNING" displayName="'if' statement with identical branches" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; statements in which common parts can be extracted from the branches.
&lt;p&gt;These common parts are independent from the condition and make &lt;code&gt;if&lt;/code&gt; statements harder to understand.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x &amp;gt; 12) {
    doSomethingBefore();
    doSomethingDifferent1();
    doSomethingAfter();
  } else {
    doSomethingBefore();
    doSomethingDifferent2();
    doSomethingAfter();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  doSomethingBefore();
  if (x &amp;gt; 12) {
    doSomethingDifferent1();
  } else {
    doSomethingDifferent2();
  }
  doSomethingAfter();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;Updated in 2018.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FallthruInSwitchStatement" defaultSeverity="WARNING" displayName="Fallthrough in 'switch' statement" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports 'fall-through' in a &lt;code&gt;switch&lt;/code&gt; statement.
&lt;p&gt;Fall-through occurs when a series of executable statements after a &lt;code&gt;case&lt;/code&gt; label is not guaranteed
to transfer control before the next &lt;code&gt;case&lt;/code&gt; label. For example, this can happen if the branch is missing a &lt;code&gt;break&lt;/code&gt; statement.
In that case, control falls through to the statements after
that &lt;code&gt;switch&lt;/code&gt; label, even though the &lt;code&gt;switch&lt;/code&gt; expression is not equal to
  the value of the fallen-through label. While occasionally intended, this construction is confusing and is often the result of a typo.&lt;/p&gt;
&lt;p&gt;
This inspection ignores any fall-through commented with a text matching the regex pattern &lt;code&gt;(?i)falls?\s*thro?u&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;There is a fix that adds a &lt;code&gt;break&lt;/code&gt; to the branch that can fall through to the next branch.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch(x) {
      case (4):
          if (condition) {
              System.out.println("3");
              // no break here
          } else {
              break;
          }
      case (6):
          System.out.println("4");
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch(x) {
        case (4):
            if (condition) {
                System.out.println("3");
            } else {
                break;
            }
            break;
        case (6):
            System.out.println("4");
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatement" defaultSeverity="WARNING" displayName="'switch' statement" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;switch&lt;/code&gt; statements.
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt; statements often (but not always) indicate a poor object-oriented design.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (i) {
    // code
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForLoopReplaceableByWhile" defaultSeverity="WARNING" displayName="'for' loop may be replaced by 'while' loop" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;for&lt;/code&gt; loops that contain neither initialization nor update components, and suggests converting them to &lt;code&gt;while&lt;/code&gt;
loops. This makes the code easier to read.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for(; exitCondition(); ) {
    process();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  while(exitCondition()) {
    process();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix is also available for other &lt;code&gt;for&lt;/code&gt; loops, so you can replace any &lt;code&gt;for&lt;/code&gt; loop with a
  &lt;code&gt;while&lt;/code&gt; loop.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore 'infinite' for loops without conditions&lt;/b&gt; option if you want to ignore &lt;code&gt;for&lt;/code&gt;
  loops with trivial or non-existent conditions.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DoubleNegation" defaultSeverity="WARNING" displayName="Double negation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports double negations that can be simplified.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (!!functionCall()) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (functionCall()) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (!(a != b)) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (a == b) {}
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InfiniteLoopStatement" defaultSeverity="WARNING" displayName="Infinite loop statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;,
or &lt;code&gt;do&lt;/code&gt; statements that
can only exit by throwing an exception. While such statements may be correct, they
often happen due to coding errors.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (;;) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore when placed in Thread.run&lt;/b&gt; option to ignore the
  infinite loop statements inside &lt;code&gt;Thread.run&lt;/code&gt;.
It may be useful for the daemon threads.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Thread(() -&amp;gt; {
    while (true) {
    }
  }).start();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExpressionMayBeFactorized" defaultSeverity="INFORMATION" displayName="Expression can be factorized" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!-- Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. --&gt;
&lt;html&gt;
&lt;body&gt;
Reports expressions that can be factorized, i.e. reorganized to pull out a common factor.
This reduces redundancy and could improve the readability of your code.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a &amp;amp;&amp;amp; b || a &amp;amp;&amp;amp; c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a &amp;amp;&amp;amp; (b || c)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2021.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="BooleanExpressionMayBeConditional" defaultSeverity="INFORMATION" displayName="Boolean expression could be replaced with conditional expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any &lt;code&gt;boolean&lt;/code&gt; expressions which can be formulated in a more compact and, arguably, clear way than by using a conditional expression.
&lt;p&gt;Use the quick-fix to replace the &lt;code&gt;boolean&lt;/code&gt; expression by a conditional expression.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a &amp;amp;&amp;amp; b || !a &amp;amp;&amp;amp; c;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a ? b : c;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfStatementWithTooManyBranches" defaultSeverity="WARNING" displayName="'if' statement with too many branches" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; statements with too many branches.
&lt;p&gt;Such statements may be confusing and are often a sign of inadequate levels of design
  abstraction.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Maximum number of branches&lt;/b&gt; field to specify the maximum number of branches an &lt;code&gt;if&lt;/code&gt; statement is allowed to have.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementWithConfusingDeclaration" defaultSeverity="WARNING" displayName="Local variable used and declared in different 'switch' branches" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local variables declared in one branch of a &lt;code&gt;switch&lt;/code&gt; statement
and used in another branch. Such declarations can be extremely confusing.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch(i) {
      case 2:
          int x = 0;
          break;
      case 3:
          x = 3;
          System.out.println(x);
          break;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;


&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegatedEqualityExpression" defaultSeverity="WARNING" displayName="Negated equality expression" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports equality expressions which are negated by a prefix expression.
&lt;p&gt;Such expressions can be simplified using the &lt;code&gt;!=&lt;/code&gt; operator.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  !(i == 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  i != 1
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedSwitchStatement" defaultSeverity="WARNING" displayName="Nested 'switch' statement" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports nested &lt;code&gt;switch&lt;/code&gt; statements or expressions.
&lt;p&gt;Nested &lt;code&gt;switch&lt;/code&gt; statements
may result in extremely confusing code. These statements may be extracted to a separate method.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int res = switch (i) {
            case 0 -&gt; 0;
            default -&gt; switch (i) {
                case 100 -&gt; 0;
                default -&gt; i;
            };
        };
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessBooleanExpression" defaultSeverity="WARNING" displayName="Pointless statement or boolean expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary or overly complicated boolean expressions.
&lt;p&gt;Such expressions include &lt;code&gt;&amp;&amp;&lt;/code&gt;-ing with &lt;code&gt;true&lt;/code&gt;,
&lt;code&gt;||&lt;/code&gt;-ing with &lt;code&gt;false&lt;/code&gt;,
  equality comparison with a boolean literal, or negation of a boolean literal. Such expressions can be simplified.&lt;/p&gt;
&lt;p&gt;Example:
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; a = !(x &amp;&amp; &lt;b&gt;false&lt;/b&gt;);
  &lt;b&gt;boolean&lt;/b&gt; b = &lt;b&gt;false&lt;/b&gt; || x;
  &lt;b&gt;boolean&lt;/b&gt; c = x != &lt;b&gt;true&lt;/b&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; a = &lt;b&gt;true&lt;/b&gt;;
  &lt;b&gt;boolean&lt;/b&gt; b = x;
  &lt;b&gt;boolean&lt;/b&gt; c = !x;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
Use the &lt;b&gt;Ignore named constants in determining pointless expressions &lt;/b&gt; option to ignore named constants when determining if an expression is pointless.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalExpression" defaultSeverity="INFORMATION" displayName="Conditional expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of the ternary condition operator and suggests converting them to &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; statements.
&lt;p&gt;Some code standards prohibit the use of the condition operator.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object result = (condition) ? foo() : bar();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object result;
  if (condition) {
    comp = foo();
  }
  else {
    comp = bar();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore for simple assignments and returns &lt;/b&gt; option to ignore simple assignments and returns and allow the following constructs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = (foo == null) ? "" : foo.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignore places where an if statement is not possible &lt;/b&gt; option to ignore conditional expressions in contexts in which automatic
  replacement with an if statement is not possible (for example, when the conditional expression is used as an argument to a
  &lt;code&gt;super()&lt;/code&gt; constructor call).
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyComplexBooleanExpression" defaultSeverity="WARNING" displayName="Overly complex boolean expression" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports boolean expressions with too many terms. Such expressions may be confusing and bug-prone.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  cond(x1) &amp;amp;&amp;amp; cond(x2) ^ cond(x3) &amp;amp;&amp;amp; cond(x4);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Maximum number of terms&lt;/b&gt; field to specify the maximum number of terms allowed in a boolean expression.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore pure conjunctions and disjunctions&lt;/b&gt; option to ignore boolean expressions which use only a single boolean operator repeatedly.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementWithTooManyBranches" defaultSeverity="WARNING" displayName="Maximum 'switch' branches" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;switch&lt;/code&gt; statements or expressions with too many &lt;code&gt;case&lt;/code&gt; labels.
&lt;p&gt;Such a long switch statement may be confusing and should probably be refactored.
  Sometimes, it is not a problem (for example, a domain is very complicated and has enums with a lot of constants).&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    switch (x) {
        case 1 -&gt; {}
        case 2 -&gt; {}
        case 3 -&gt; {}
        case 4 -&gt; {}
        case 5 -&gt; {}
        case 6 -&gt; {}
        case 7 -&gt; {}
        case 8 -&gt; {}
        case 9 -&gt; {}
        case 10 -&gt; {}
        case 11,12,13 -&gt; {}
        default -&gt; {}
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Maximum number of branches&lt;/b&gt; field to specify the maximum number of &lt;code&gt;case&lt;/code&gt; labels expected.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DefaultNotLastCaseInSwitch" defaultSeverity="WARNING" displayName="'default' not last case in 'switch'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;switch&lt;/code&gt; statements or expressions in which the &lt;code&gt;default&lt;/code&gt; case
comes before another case.
&lt;p&gt;This construct is unnecessarily confusing.
There is a quick-fix that moves the &lt;code&gt;default&lt;/code&gt; case to the last position.
  The fix is available only when a given branch has &lt;code&gt;break&lt;/code&gt;/&lt;code&gt;yield&lt;/code&gt; at the end.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (n) {
      default:
          System.out.println();
          break;
      case 1:
          break;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (n) {
    case 1:
        break;
    default:
        System.out.println();
        break;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BreakStatementWithLabel" defaultSeverity="WARNING" displayName="'break' statement with label" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;break&lt;/code&gt; statements with labels.
&lt;p&gt;Labeled &lt;code&gt;break&lt;/code&gt; statements complicate refactoring and can be confusing.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void handle(List&amp;lt;String&amp;gt; strs) {
    outer:
    for (String s: strs) {
      for (char ch : s.toCharArray()) {
        if ('s' == ch) break outer;
        handleChar(ch);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnumSwitchStatementWhichMissesCases" defaultSeverity="INFORMATION" displayName="Enum 'switch' statement that misses case" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;switch&lt;/code&gt; statements over enumerated types that are not exhaustive.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;enum&lt;/b&gt; AlphaBetaGamma {
    A, B, C;

    &lt;b&gt;void&lt;/b&gt; x(AlphaBetaGamma e) {
      &lt;b&gt;switch&lt;/b&gt; (e) {

      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;enum&lt;/b&gt; AlphaBetaGamma {
    A, B, C;

    &lt;b&gt;void&lt;/b&gt; x(AlphaBetaGamma e) {
      &lt;b&gt;switch&lt;/b&gt; (e) {
        &lt;b&gt;case&lt;/b&gt; A -&gt; {}
        &lt;b&gt;case&lt;/b&gt; B -&gt; {}
        &lt;b&gt;case&lt;/b&gt; C -&gt; {}
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore switch statements with a default branch &lt;/b&gt; option to ignore &lt;code&gt;switch&lt;/code&gt;
  statements that have a &lt;code&gt;default&lt;/code&gt; branch.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrivialIf" defaultSeverity="WARNING" displayName="Redundant 'if' statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; statements that can be simplified to a single assignment,
&lt;code&gt;return&lt;/code&gt;, or &lt;code&gt;assert&lt;/code&gt; statement.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (foo()) {
    return true;
  } else {
    return false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore chained 'if' statements &lt;/b&gt; option if want to hide a warning for chained &lt;code&gt;if&lt;/code&gt; statements.&lt;/p&gt;
&lt;p&gt;For example, in the following code the warning will be hidden, but the quick-fix will still be available:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (condition1) return true;
  if (condition2) return false;
  return true;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore 'assert' statements &lt;/b&gt; option if want to hide a warning for &lt;code&gt;if&lt;/code&gt; statements
  containing only &lt;code&gt;assert&lt;/code&gt; statement in their bodies.&lt;/p&gt;
&lt;p&gt;For example, in the following code the warning will be hidden:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (isTrue()) assert false;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedConditionalExpression" defaultSeverity="WARNING" displayName="Nested conditional expression" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports nested conditional expressions as they
may result in extremely confusing code.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int y = a == 10 ? b == 20 ? 10 : a : b;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalCanBePushedInsideExpression" defaultSeverity="INFORMATION" displayName="Conditional can be pushed inside branch expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports conditional expressions with &lt;code&gt;then&lt;/code&gt; and &lt;c&gt;else&lt;/c&gt; branches that are similar enough so that the expression can be moved
inside. This action shortens the code.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double g(int a, int b) {
    return a == b ? Math.cos(0) : Math.cos(1);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double g(int a, int b) {
    return Math.cos(a == b ? 0 : 1);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointlessIndexOfComparison" defaultSeverity="WARNING" displayName="Pointless 'indexOf()' comparison" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary comparisons with
&lt;code&gt;.indexOf()&lt;/code&gt; expressions. An example of such an expression
is comparing the result of &lt;code&gt;.indexOf()&lt;/code&gt; with numbers smaller than -1.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertionCanBeIf" defaultSeverity="INFORMATION" displayName="Assertion can be replaced with 'if' statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;assert&lt;/code&gt; statements and suggests replacing them with
&lt;code&gt;if&lt;/code&gt; statements that throw &lt;code&gt;java.lang.AssertionError&lt;/code&gt;.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assert param != null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (param == null) throw new AssertionError();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchStatementsWithoutDefault" defaultSeverity="INFORMATION" displayName="'switch' statement without 'default' branch" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;switch&lt;/code&gt; statements that do not contain &lt;code&gt;default&lt;/code&gt; labels.
&lt;p&gt;Adding the &lt;code&gt;default&lt;/code&gt; label guarantees that all possible scenarios are covered, and it becomes
easier to make assumptions about the current state of the program.&lt;/p&gt;
&lt;p&gt;
&lt;!-- tooltip end --&gt;
  Note that by default, the inspection does not report &lt;code&gt;switch&lt;/code&gt; statements if all cases for enums or &lt;code&gt;sealed&lt;/code&gt; classes are covered.
  Use the &lt;b&gt;Ignore exhaustive switch statements&lt;/b&gt; option if you want to change this behavior.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableConditionalExpression" defaultSeverity="WARNING" displayName="Simplifiable conditional expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports conditional expressions and suggests simplifying them.
&lt;p&gt;Examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;condition ? true : foo &amp;rarr; condition || foo&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;condition ? false : foo &amp;rarr; !condition &amp;&amp; foo&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;condition ? foo : !foo &amp;rarr; condition == foo&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;condition ? true : false &amp;rarr; condition&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;a == b ? b : a &amp;rarr; a&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;result != null ? result : null &amp;rarr; result&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LabeledStatement" defaultSeverity="WARNING" displayName="Labeled statement" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports labeled statements that can complicate refactorings and control flow of the method.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  label:
  while (true) {
      // code
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegatedConditional" defaultSeverity="WARNING" displayName="Conditional expression with negated condition" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports conditional expressions whose conditions are negated.
&lt;p&gt;Flipping the order of the conditional expression branches usually increases the clarity of such statements.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignore '!= null' comparisons&lt;/b&gt; and &lt;b&gt;Ignore '!= 0' comparisons&lt;/b&gt; options to ignore comparisons of the form
  &lt;code&gt;obj != null&lt;/code&gt; or &lt;code&gt;num != 0&lt;/code&gt;.
  Since &lt;code&gt;obj != null&lt;/code&gt; effectively means "obj exists",
  the meaning of the whole expression does not involve any negation
  and is therefore easy to understand.
&lt;p&gt;
  The same reasoning applies to &lt;code&gt;num != 0&lt;/code&gt; expressions, especially when using bit masks.
&lt;p&gt;
  These forms have the added benefit of mentioning the interesting case first.
  In most cases, the value for the &lt;code&gt;== null&lt;/code&gt; branch is &lt;code&gt;null&lt;/code&gt; itself,
  like in the following examples:

&lt;pre&gt;&lt;code&gt;
    static String getName(Person p) {
        return p != null ? p.getName() : null;
    }

    static String getExecutableString(int fileMode) {
        return (fileMode &amp; 0b001001001) != 0 ? "executable" : "non-executable";
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalBreakInInfiniteLoop" defaultSeverity="WARNING" displayName="Conditional break inside infinite loop" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports conditional breaks at the beginning or at the end of a loop and suggests using a loop condition instead to shorten the code.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;while&lt;/b&gt; (true) {
    &lt;b&gt;if&lt;/b&gt; (i  == 23) &lt;b&gt;break&lt;/b&gt;;
    i++;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;while&lt;/b&gt; (i != 23) {
    i++;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantConditionalExpression" defaultSeverity="WARNING" displayName="Constant conditional expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports conditional expressions in which the condition is either a &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; constant.
These expressions sometimes occur as a result of automatic refactorings and may be simplified.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return true ? "Yes" : "No";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return "Yes";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopConditionNotUpdatedInsideLoop" defaultSeverity="WARNING" displayName="Loop variable not updated inside loop" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any variables and parameters that are used in a loop condition
and are not updated inside the loop.
&lt;p&gt;Such variables and parameters are usually used by mistake as they
  may cause an infinite loop if they are executed.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void loopDoesNotLoop(boolean b) {
    while (b) {
      System.out.println();
      break;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignore possible non-local changes&lt;/b&gt; option to disable this inspection
  if the condition can be updated indirectly (e.g. via the called method or concurrently from another thread).
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NegatedIfElse" defaultSeverity="WARNING" displayName="'if' statement with negated condition" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; statements
that contain &lt;code&gt;else&lt;/code&gt; branches and whose conditions are negated.
&lt;p&gt;Flipping the order of the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt;
  branches usually increases the clarity of such statements.&lt;/p&gt;
&lt;p&gt;There is a fix that inverts the current &lt;code&gt;if&lt;/code&gt; statement.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void m(Object o1, Object o2) {
        if (o1 != o2) {
            System.out.println(1);
        }
        else {
            System.out.println(2);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After applying the quick-fix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void m(Object o1, Object o2) {
        if (o1 == o2) {
            System.out.println(2);
        } else {
            System.out.println(1);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore '!= null' comparisons&lt;/b&gt; option to ignore comparisons of the &lt;code&gt;!= null&lt;/code&gt; form.&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore '!= 0' comparisons&lt;/b&gt; option to ignore comparisons of the &lt;code&gt;!= 0&lt;/code&gt; form.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopStatementsThatDontLoop" defaultSeverity="WARNING" displayName="Loop statement that does not loop" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any instance of &lt;code&gt;for&lt;/code&gt;,
&lt;code&gt;while&lt;/code&gt;, and &lt;code&gt;do&lt;/code&gt; statements whose
bodies will be executed once at most. Normally, this is an indication of a bug.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore enhanced for loops&lt;/b&gt; option to ignore the foreach loops.
They are sometimes used to perform an action only on the first item of an iterable in a compact way.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;for&lt;/b&gt; (String s : stringIterable) {
    doSomethingOnFirstString(s);
    &lt;b&gt;break&lt;/b&gt;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueStatementWithLabel" defaultSeverity="WARNING" displayName="'continue' statement with label" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;continue&lt;/code&gt; statements with labels.
&lt;p&gt;Labeled &lt;code&gt;continue&lt;/code&gt; statements complicate refactoring and can be confusing.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void handle(List&amp;lt;String&amp;gt; strs) {
    outer:
    for (String s: strs) {
      for (char ch : s.toCharArray()) {
        if ('s' == ch) continue outer;
        handleChar(ch);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ContinueStatement" defaultSeverity="WARNING" displayName="'continue' statement" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;continue&lt;/code&gt; statements.
&lt;p&gt;&lt;code&gt;continue&lt;/code&gt; statements complicate refactoring and can be confusing.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(List&amp;lt;String&amp;gt; strs) {
    for (String str : strs) {
      if (str.contains("skip")) continue;
      handleStr(str);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableBooleanExpression" defaultSeverity="WARNING" displayName="Simplifiable boolean expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports boolean expressions that can be simplified.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(boolean foo, boolean bar) {
    boolean b = !(foo ^ bar);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(boolean foo, boolean bar) {
    boolean b = foo == bar;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(boolean foo, boolean bar) {
    boolean b = (foo &amp;&amp; bar) || !foo;
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(boolean foo, boolean bar) {
    boolean b = !foo || bar;
  }
  &lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BreakStatement" defaultSeverity="WARNING" displayName="'break' statement" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;break&lt;/code&gt; statements that are used in places
other than at the end of a &lt;code&gt;switch&lt;/code&gt; statement branch.
&lt;p&gt;&lt;code&gt;break&lt;/code&gt; statements complicate refactoring and can be confusing.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
void foo(List&amp;lt;String&amp;gt; strs) {
  for (String str : strs) {
    if (str.contains("stop")) break;
    handleStr(str);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateCondition" defaultSeverity="WARNING" displayName="Duplicate condition" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports duplicate conditions in &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; expressions
and branches of &lt;code&gt;if&lt;/code&gt; statements.
While sometimes duplicate conditions are intended, in most cases they the result of an oversight.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean result = digit1 != digit2 || digit1 != digit2;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  To ignore conditions that may produce side effects, use the &lt;b&gt;Ignore conditions with side effects&lt;/b&gt; option.
Disabling this option may lead to false-positives, for example, when the same method returns different values on subsequent invocations.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (iterator.next() != null || iterator.next() != null) {
    System.out.println("Got it");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Due to possible side effects of &lt;code&gt;iterator.next()&lt;/code&gt; (on the example), the warning will only be
  triggered if the &lt;b&gt;Ignore conditions with side effects&lt;/b&gt; option is disabled.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Code style issues" path="Java"><inspection shortName="UnnecessarySuperConstructor" defaultSeverity="WARNING" displayName="Unnecessary call to 'super()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to no-arg superclass constructors during object construction.
&lt;p&gt;Such calls are unnecessary and may be removed.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {
      super();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantOnWrongSideOfComparison" defaultSeverity="WARNING" displayName="Constant on wrong side of comparison" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports comparison operations where the constant value is on the wrong side.
&lt;p&gt;Some coding conventions specify that constants should be on a specific side of a comparison, either left or right.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean compare(int x) {
    return 1 &amp;gt; x; // Constant '1' on the left side of the comparison
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean compare(int x) {
    return x &amp;lt; 1;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the inspection settings to choose the side of constants in comparisons
  and whether to warn if &lt;code&gt;null&lt;/code&gt; literals are on the wrong side.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2019.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LiteralAsArgToStringEquals" defaultSeverity="WARNING" displayName="String literal may be 'equals()' qualifier" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;String.equals()&lt;/code&gt; or &lt;code&gt;String.equalsIgnoreCase()&lt;/code&gt; calls
with a string literal argument.
&lt;p&gt;Some coding standards specify that string literals should be the qualifier of &lt;code&gt;equals()&lt;/code&gt;, rather than
  argument, thus minimizing &lt;code&gt;NullPointerException&lt;/code&gt;-s.&lt;/p&gt;
&lt;p&gt;A quick-fix is available to exchange the literal and the expression.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean isFoo(String value) {
    return value.equals("foo");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean isFoo(String value) {
    return "foo".equals(value);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToStringConcatCanBeReplacedByOperator" defaultSeverity="WARNING" displayName="Call to 'String.concat()' can be replaced with '+'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.lang.String.concat()&lt;/code&gt;.
&lt;p&gt;
  Such calls can be replaced with the &lt;code&gt;+&lt;/code&gt; operator for clarity and possible increased
  performance if the method was invoked on a constant with a constant argument.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String foo(String name) {
    return name.concat("foo");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String foo(String name) {
    return name + "foo";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ChainedMethodCall" defaultSeverity="WARNING" displayName="Chained method calls" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method calls whose target is another method call.
The quick-fix suggests to introduce a local variable.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
    int foo(File f) {
      return f.getName().length();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
    int foo(File f) {
      final String name = f.getName();
      return name.length();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the inspection options to toggle warnings for the following cases:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;
      chained method calls in field initializers,
      for instance, &lt;code&gt;private final int i = new Random().nextInt();&lt;/code&gt;
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      chained method calls operating on the same type,
      for instance, &lt;code&gt;new StringBuilder().append("x: ").append(new X()).append("y: ").append(new Y()).toString();&lt;/code&gt;.
    &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodRefCanBeReplacedWithLambda" defaultSeverity="INFORMATION" displayName="Method reference can be replaced with lambda" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method references, like &lt;code&gt;MyClass::myMethod&lt;/code&gt; and &lt;code&gt;myObject::myMethod&lt;/code&gt;,
  and suggests replacing them with an equivalent lambda expression.
&lt;p&gt;Lambda expressions can be easier to modify than method references.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out::println
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  s -&amp;gt; System.out.println(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;By default, this inspection does not highlight the code in the editor, but only provides a quick-fix.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaCanBeReplacedWithAnonymous" defaultSeverity="INFORMATION" displayName="Lambda can be replaced with anonymous class" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports lambda expressions that can be replaced with anonymous classes.
&lt;p&gt;
  Expanding lambda expressions to anonymous classes may be useful if you need to implement other
  methods inside an anonymous class or if you need to downgrade to one of the previous Java versions.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  s -&gt; System.out.println(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Consumer&amp;lt;String&amp;gt;() {
  @Override
  public void accept(String s) {
    System.out.println(s);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection is available in Java 8 and later.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestedMethodCall" defaultSeverity="WARNING" displayName="Nested method call" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method calls used as parameters to another method call.
&lt;p&gt;The quick-fix introduces a variable to make the code simpler and easier to debug.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int y() { return 1; }
  public int f(int x) { return 2 * x; }

  public void foo() {
      int x = f(y());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int y() { return 1; }
  public int f(int x) { return 2 * x; }

  public void foo() {
      int y = y();
      int x = f(y);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the inspection options to toggle the reporting of:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;method calls in field initializers&lt;/li&gt;
  &lt;li&gt;calls to static methods&lt;/li&gt;
  &lt;li&gt;calls to simple getters&lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissortedModifiers" defaultSeverity="WARNING" displayName="Missorted modifiers" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports declarations whose modifiers are not in the canonical
preferred order (as stated in the Java Language Specification).
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    native public final void foo();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public final native void foo();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the inspection settings to:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;
      toggle the reporting of misplaced annotations:
      (annotations with &lt;code&gt;ElementType.TYPE_USE&lt;/code&gt; &lt;em&gt;not&lt;/em&gt; directly
      before the type and after the modifier keywords, or
      other annotations &lt;em&gt;not&lt;/em&gt; before the modifier keywords).
      When this option is disabled, any annotation can be positioned before or after the modifier keywords.
      Modifier lists with annotations in between the modifier keywords will always be reported.
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      specify whether the &lt;code&gt;ElementType.TYPE_USE&lt;/code&gt; annotation should be positioned directly before
      a type, even when the annotation has other targets specified.
    &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsCalledOnEnumConstant" defaultSeverity="WARNING" displayName="'equals()' called on enum value" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;equals()&lt;/code&gt; calls on enum constants.
&lt;p&gt;Such calls can be replaced by an identity comparison (&lt;code&gt;==&lt;/code&gt;) because two
  enum constants are equal only when they have the same identity.&lt;/p&gt;
&lt;p&gt;A quick-fix is available to change the call to a comparison.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean foo(MyEnum value) {
    return value.equals(MyEnum.FOO);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean foo(MyEnum value) {
    return value == MyEnum.FOO;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FillPermitsList" defaultSeverity="INFORMATION" displayName="Same file subclasses are missing from permits clause of a sealed class" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports sealed classes whose permits clauses do not contain some of the subclasses from the same file.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class A {}
  final class B extends A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class A permits B {}
  final class B extends A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2020.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnqualifiedInnerClassAccess" defaultSeverity="WARNING" displayName="Unqualified inner class access" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports references to inner classes that are not qualified with the name
of the enclosing class.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import foo.Foo.Bar;

  class Foo {
    class Bar {}
  }

  class Baz {
    void f(Bar bar) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    class Bar {}
  }

  class Baz {
    void f(Foo.Bar bar) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the inspection settings to ignore references to inner classes within the same class,
  which therefore do not require an import.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnThis" defaultSeverity="WARNING" displayName="Return of 'this'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods returning &lt;code&gt;this&lt;/code&gt;.
&lt;p&gt;
  While such a return is valid, it is rarely necessary, and usually indicates that the method is intended to be used
  as part of a chain of similar method calls (for example, &lt;code&gt;buffer.append("foo").append("bar").append("baz")&lt;/code&gt;).
  Such chains are frowned upon by many coding standards.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public Builder append(String str) {
    // [...]
    return this;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DiamondCanBeReplacedWithExplicitTypeArguments" defaultSeverity="INFORMATION" displayName="Diamond can be replaced with explicit type arguments" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instantiation of generic classes in which the &lt;b&gt;&amp;lt;&amp;gt;&lt;/b&gt; symbol (diamond) is used instead of
  type parameters.

&lt;p&gt;The quick-fix replaces &lt;b&gt;&amp;lt;&amp;gt;&lt;/b&gt; (diamond) with explicit type parameters.
  This action can be useful to make the code compatible with Java 6.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List &amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List &amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BlockMarkerComments" defaultSeverity="WARNING" displayName="Block marker comment" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports comments which are used as code block markers.
The quick-fix removes such comments.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  while (i &amp;lt; 10) {
    i++;
  } // end while
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  while (i &amp;lt; 10) {
    i++;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StreamToLoop" defaultSeverity="INFORMATION" displayName="Stream API call chain can be replaced with loop" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Stream API chains, &lt;code&gt;Iterable.forEach()&lt;/code&gt;, and &lt;code&gt;Map.forEach()&lt;/code&gt; calls that can be automatically converted into classical loops.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String joinNonEmpty(List&amp;lt;String&amp;gt; list) {
    return list.stream() // Stream can be converted to loop
      .filter(s -&gt; !s.isEmpty())
      .map(String::trim)
      .collect(Collectors.joining(", "));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String joinNonEmpty(List&amp;lt;String&amp;gt; list) {
    StringJoiner joiner = new StringJoiner(", ");
    for (String s : list) {
      if (!s.isEmpty()) {
        String trim = s.trim();
        joiner.add(trim);
      }
    }
    return joiner.toString();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  Note that sometimes this inspection might cause slight semantic changes.
  Special care should be taken when it comes to short-circuiting, as it's not specified how many elements will be actually read when
  the stream short-circuits.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Iterate unknown Stream sources via Stream.iterator()&lt;/b&gt; option to suggest conversions for streams with unrecognized source.
  In this case, iterator will be created from the stream.
  For example, when checkbox is selected, the conversion will be suggested here:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;ProcessHandle&amp;gt; handles = ProcessHandle.allProcesses().collect(Collectors.toList());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, the result will be as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;ProcessHandle&amp;gt; handles = new ArrayList&amp;lt;&amp;gt;();
  for (Iterator&amp;lt;ProcessHandle&amp;gt; it = ProcessHandle.allProcesses().iterator(); it.hasNext(); ) {
    ProcessHandle allProcess = it.next();
    handles.add(allProcess);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;New in 2017.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaParameterTypeCanBeSpecified" defaultSeverity="INFORMATION" displayName="Lambda parameter type can be specified" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports lambda parameters that do not have their type specified and suggests
adding the missing type declarations.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Function&amp;lt;String, Integer&amp;gt; length = a -&amp;gt; a.length();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Function&amp;lt;String, Integer&amp;gt; length = (String a) -&amp;gt; a.length();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BoundedWildcard" defaultSeverity="WARNING" displayName="Can use bounded wildcard" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports generic method parameters that can make use of &lt;a href="https://en.wikipedia.org/wiki/Wildcard_(Java)"&gt;bounded wildcards&lt;/a&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process(Consumer&amp;lt;Number&amp;gt; consumer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;should be replaced with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process(Consumer&amp;lt;? super Number&amp;gt; consumer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  This method signature is more flexible because it accepts more types: not only
  &lt;code&gt;Consumer&amp;lt;Number&amp;gt;&lt;/code&gt;, but also &lt;code&gt;Consumer&amp;lt;Object&amp;gt;&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;Likewise, type parameters in covariant position:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  T produce(Producer&amp;lt;T&amp;gt; p);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;should be replaced with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  T produce(Producer&amp;lt;? extends T&amp;gt; p);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  To quote &lt;a href="https://en.wikipedia.org/wiki/Joshua_Bloch#Effective_Java"&gt;Joshua Bloch&lt;/a&gt; in &lt;em&gt;Effective Java&lt;/em&gt; third Edition:
&lt;/p&gt;
&lt;blockquote&gt;
  &lt;h4&gt;Item 31: Use bounded wildcards to increase API flexibility&lt;/h4&gt;
  Using wildcard types in your APIs, while tricky, makes the APIs far more flexible.
  If you write a library that will be widely used, the proper use of wildcard types should be considered mandatory.
  Remember the basic rule: producer-extends, consumer-super (PECS).
  Also remember that all Comparables and Comparators are consumers.
&lt;/blockquote&gt;

&lt;p&gt;
  Use the inspection options to toggle the reporting for:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;
      invariant classes. An example of an invariant class is &lt;code&gt;java.util.List&amp;lt;T&amp;gt;&lt;/code&gt; because it both accepts values
      (via the &lt;code&gt;List.add(T)&lt;/code&gt; method)
      and produces values (via the &lt;code&gt;T List.get()&lt;/code&gt; method).
    &lt;/p&gt;
    &lt;p&gt;
      On the
      other hand, &lt;code&gt;contravariant&lt;/code&gt; classes only receive values, for example, &lt;code&gt;java.util.function.Consumer&amp;lt;T&amp;gt;&lt;/code&gt;
      with the only method &lt;code&gt;accept(T)&lt;/code&gt;. Similarly, &lt;code&gt;covariant&lt;/code&gt; classes
      only produce values, for example, &lt;code&gt;java.util.function.Supplier&amp;lt;T&amp;gt;&lt;/code&gt;
      with the only method &lt;code&gt;T get()&lt;/code&gt;.
    &lt;/p&gt;
    &lt;p&gt;
      People often use bounded wildcards in covariant/contravariant
      classes but avoid wildcards in invariant classes, for example, &lt;code&gt;void process(List&amp;lt;? extends T&amp;gt; l)&lt;/code&gt;.
      Disable this option to ignore such invariant classes and leave them rigidly typed, for example, &lt;code&gt;void
      process(List&amp;lt;T&amp;gt; l)&lt;/code&gt;.
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      &lt;code&gt;private&lt;/code&gt; methods, which can be considered as not a part of the public API
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      instance methods
    &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ChainedEquality" defaultSeverity="WARNING" displayName="Chained equality comparisons" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports chained equality comparisons.
&lt;p&gt;Such comparisons may be confusing: &lt;code&gt;a == b == c&lt;/code&gt; means &lt;code&gt;(a == b) == c&lt;/code&gt;,
  but possibly &lt;code&gt;a == b &amp;&amp; a == c&lt;/code&gt; is intended.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean chainedEquality(boolean a, boolean b, boolean c) {
    return a == b == c;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can use parentheses to make the comparison less confusing:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean chainedEquality(boolean a, boolean b, boolean c) {
    return (a == b) == c;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableIfStatement" defaultSeverity="INFORMATION" displayName="'if' statement can be replaced with conditional or boolean expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; statements that can be replaced with conditions using the &lt;code&gt;&amp;&amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;,
&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, or &lt;code&gt;?:&lt;/code&gt; operator.
&lt;p&gt;The result is usually shorter, but not always clearer, so it's not advised to apply the fix  in every case.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (condition) return true; else return foo;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return condition || foo;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
  Use the &lt;b&gt;Don't suggest '?:' operator&lt;/b&gt; option to disable the warning when the &lt;code&gt;?:&lt;/code&gt; operator is suggested. In this case, only
  &lt;code&gt;&amp;&amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, and &lt;code&gt;!=&lt;/code&gt; suggestions will be highlighted. The
  quick-fix will still be available in the editor.
&lt;/li&gt;
&lt;li&gt;
  Use the &lt;b&gt;Ignore chained 'if' statements&lt;/b&gt; option to disable the warning for &lt;code&gt;if-else&lt;/code&gt; chains. The quick-fix will
  still be available in the editor.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;New in 2018.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableEqualsExpression" defaultSeverity="WARNING" displayName="Unnecessary 'null' check before 'equals()' call" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports comparisons to &lt;code&gt;null&lt;/code&gt; that are followed by a call to &lt;code&gt;equals()&lt;/code&gt; with a constant argument.

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (s != null &amp;&amp; s.equals("literal")) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if ("literal".equals(s)) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
    Use the inspection settings to report &lt;code&gt;equals()&lt;/code&gt; calls with a non-constant argument
    when the argument to &lt;code&gt;equals()&lt;/code&gt; is proven not to be &lt;code&gt;null&lt;/code&gt;.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MoveFieldAssignmentToInitializer" defaultSeverity="INFORMATION" displayName="Field assignment can be moved to initializer" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Suggests replacing initializations of a field via assignment with field initializers.
&lt;p&gt;The code is highlighted only if the field initializer is located in the initializer, and
  joining it with the field declaration is likely to be safe.
  In other cases, the inspection provides a quick-fix without code highlighting, as the fix may change the code semantics.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    static final int intConstant;
    
    static {
      intConstant = 10;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
The quick fix moves the assigned value to the field initializer removing the class initializer section if possible:
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    static final int intConstant = 10;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;small&gt;Since 2017.2&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExtendsObject" defaultSeverity="WARNING" displayName="Class explicitly extends 'Object'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any classes that are explicitly declared to extend &lt;code&gt;java.lang.Object&lt;/code&gt;.
&lt;p&gt;Such declaration is redundant and can be safely removed.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass extends Object {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix removes the redundant &lt;code&gt;extends Object&lt;/code&gt; clause:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarilyQualifiedInnerClassAccess" defaultSeverity="INFORMATION" displayName="Unnecessarily qualified inner class access" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any references to inner classes that are unnecessarily qualified with the name
of the enclosing class.
&lt;p&gt;Such a qualification can be safely removed, which sometimes adds an import for the inner class.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
     X.Y foo;
     class Y{}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
     Y foo;
     class Y{}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore references for which an import is needed&lt;/b&gt; option to ignore references to inner classes, where
  removing the qualification adds an import.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalAssignedToNull" defaultSeverity="WARNING" displayName="Null value for Optional type" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;null&lt;/code&gt; assigned to &lt;code&gt;Optional&lt;/code&gt; variable or returned from method returning &lt;code&gt;Optional&lt;/code&gt;.
&lt;p&gt;It's recommended that you use &lt;code&gt;Optional.empty()&lt;/code&gt; (or &lt;code&gt;Optional.absent()&lt;/code&gt; for Guava) to denote an empty value.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional&amp;lt;Integer&amp;gt; foo(boolean flag) {
    return flag ? Optional.of(42) : null;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional&amp;lt;Integer&amp;gt; foo(boolean flag) {
    return flag ? Optional.of(42) : Optional.empty();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;
  Use the &lt;b&gt;Report comparison of Optional with null&lt;/b&gt; option to also report comparisons like &lt;code&gt;optional == null&lt;/code&gt;. While in rare cases (e.g. lazily initialized
  optional field) this might be correct, optional variable is usually never null, and probably &lt;code&gt;optional.isPresent()&lt;/code&gt; was
  intended.
&lt;/p&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FuseStreamOperations" defaultSeverity="WARNING" displayName="Subsequent steps can be fused into Stream API chain" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Detects transformations outside a Stream API chain that could be incorporated into it.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = stream.collect(Collectors.toList());
  list.sort(null);
  return list.toArray(new String[list.size()]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the conversion:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return stream.sorted().toArray(String[]::new);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  Note that sometimes the converted stream chain may replace explicit &lt;code&gt;ArrayList&lt;/code&gt; with &lt;code&gt;Collectors.toList()&lt;/code&gt; or explicit
  &lt;code&gt;HashSet&lt;/code&gt; with &lt;code&gt;Collectors.toSet()&lt;/code&gt;. The current library implementation uses these collections internally. However,
  this approach is not very reliable and might change in the future altering the semantics of your code.&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;If you are concerned about it, use the &lt;b&gt;Do not suggest 'toList()' or 'toSet()' collectors&lt;/b&gt; option to suggest
  &lt;code&gt;Collectors.toCollection()&lt;/code&gt; instead of &lt;code&gt;toList&lt;/code&gt; and &lt;code&gt;toSet&lt;/code&gt; collectors.
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;!--&lt;p&gt;&lt;small&gt;New in 2017.3&lt;/small&gt;&lt;/p&gt;--&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalCanBeFinal" defaultSeverity="WARNING" displayName="Local variable or parameter can be 'final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports parameters or local variables found in the specified inspection
scope to which the &lt;code&gt;final&lt;/code&gt; modifier can be added.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList();
  fill(list);
  return list;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList();
  fill(list);
  return list;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the inspection's options to define whether parameters or local variables should be reported.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConfusingOctalEscape" defaultSeverity="WARNING" displayName="Confusing octal escape sequence" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports string literals containing an octal escape sequence immediately followed by
a digit.
&lt;p&gt;Such strings may be confusing, and are often the result of errors in escape code creation.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println("\1234"); // Octal escape sequence '\123' immediately followed by a digit
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JoinDeclarationAndAssignmentJava" defaultSeverity="INFORMATION" displayName="Assignment can be joined with declaration" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports variable assignments that can be joined with a variable declaration.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x;
  x = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix converts the assignment into an initializer:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CStyleArrayDeclaration" defaultSeverity="WARNING" displayName="C-style array declaration" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports array declarations written in C-style syntax in which the array indicator brackets
  are placed after the variable name or after the method parameter list.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public&lt;/b&gt; String process(String value[])[] {
    return value;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Most code styles prefer Java-style array declarations in which the array indicator brackets are attached to the type name, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public&lt;/b&gt; String[] process(String[] value) {
    return value;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore C-style declarations in variables&lt;/b&gt; option to report C-style array declaration of method return types only.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryFullyQualifiedName" defaultSeverity="INFORMATION" displayName="Unnecessary fully qualified name" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fully qualified class names that can be shortened.
&lt;p&gt;The quick-fix shortens fully qualified names and adds import statements if necessary.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class ListWrapper {
    java.util.List&amp;lt;Integer&amp;gt; l;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.List;
  class ListWrapper {
    List&amp;lt;Integer&amp;gt; l;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;

&lt;p&gt;
  Use the &lt;b&gt;Ignore in Java 9 module statements&lt;/b&gt; option to ignore fully qualified names inside the Java 9
  &lt;code&gt;provides&lt;/code&gt; and &lt;code&gt;uses&lt;/code&gt; module statements.
&lt;p&gt;
  In &lt;a href="settings://preferences.sourceCode.Java?JavaDoc%20Inner"&gt;Settings | Editor | Code Style | Java | Imports&lt;/a&gt;,
  use the following options to configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Insert imports for inner classes&lt;/b&gt; option if references to inner classes should be qualified with the outer class.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Use fully qualified class names in JavaDoc&lt;/b&gt; option to allow fully qualified names in Javadocs.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryBlockStatement" defaultSeverity="INFORMATION" displayName="Unnecessary code block" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code blocks that are redundant to the semantics of the program and can
be replaced with their contents.
&lt;p&gt;The code blocks that are the bodies of &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;,
&lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;for&lt;/code&gt; statements will not be reported by this
  inspection.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo() {
    { // unnecessary
      int result = call();
      analyze(result);
    } // unnecessary
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore branches of 'switch' statements&lt;/b&gt; option to ignore the code blocks that are used as branches of switch statements.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarilyQualifiedStaticUsage" defaultSeverity="WARNING" displayName="Unnecessarily qualified static access" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of static members qualified with the class name.
&lt;p&gt;
  Such qualification is unnecessary and may be safely removed.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      Foo.foo();
      System.out.println(Foo.x);
    }

    static void baz() { Foo.foo(); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      foo();
      System.out.println(x);
    }

    static void baz() { foo(); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the inspection options to toggle the reporting for:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Static fields access:&lt;br&gt;&lt;code&gt;void bar() { System.out.println(Foo.x); }&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Calls to static methods:&lt;br&gt;&lt;code&gt;void bar() { Foo.foo(); }&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  Also, you can configure the inspection to only report static member usage
  in a static context. In this case, only &lt;code&gt;static void baz() { Foo.foo(); }&lt;/code&gt; will be reported.
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SingleStatementInBlock" defaultSeverity="INFORMATION" displayName="Code block contains single statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports control flow statements with a single statement in their code block and
suggests removing the braces from the control flow statement body.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x &gt; 0) {
    System.out.println("x is positive");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x &gt; 0) System.out.println("x is positive");
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ArrayCanBeReplacedWithEnumValues" defaultSeverity="INFORMATION" displayName="Array can be replaced with enum values" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports arrays of enum constants that can be replaced with a call to &lt;code&gt;EnumType.values()&lt;/code&gt;.
&lt;p&gt;Usually, when updating such an enum, you have to update the array as well. However, if you use &lt;code&gt;EnumType.values()&lt;/code&gt;
 instead, no modifications are required.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum States {
     NOT_RUN, IN_PROGRESS, FINISHED;
  }
  
  handleStates(new States[] {NOT_RUN, IN_PROGRESS, FINISHED});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  handleStates(States.values());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;New in 2019.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryThis" defaultSeverity="WARNING" displayName="Unnecessary 'this' qualifier" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary &lt;code&gt;this&lt;/code&gt; qualifier.
&lt;p&gt;
  Using &lt;code&gt;this&lt;/code&gt; to disambiguate a code reference is discouraged by many coding styles
  and may easily become unnecessary
  via automatic refactorings.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int x;
    void foo() {
      this.x = 2;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int x;
    void foo() {
      x = 2;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the inspection settings to ignore assignments to fields.
  For instance, &lt;code&gt;this.x = 2;&lt;/code&gt; won't be reported, but &lt;code&gt;int y = this.x;&lt;/code&gt; will be.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnSeparatedFromComputation" defaultSeverity="INFORMATION" displayName="'return' separated from the result computation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;return&lt;/code&gt; statements that return a local variable where the value of the variable is computed
somewhere else within the same method.
&lt;p&gt;The quick-fix inlines the returned variable by moving the return statement to the location in which the value
  of the variable is computed.
  When the returned value can't be inlined into the &lt;code&gt;return&lt;/code&gt; statement, 
  the quick-fix attempts to move the return statement as close to the computation of the returned value as possible.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = -1;
  for (int i = 0; i &amp;lt; a.length; i++) {
    if (a[i] == b) {
      n = i;
      break;
    }
  }
  return n;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = -1;
  for (int i = 0; i &amp;lt; a.length; i++) {
    if (a[i] == b) {
      return i;
    }
  }
  return n;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryConstructor" defaultSeverity="WARNING" displayName="Redundant no-arg constructor" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary constructors.
&lt;p&gt;
  A constructor is unnecessary if it is the only constructor of a class, has no parameters,
  has the same access modifier as its containing class,
  and does not perform any initialization except explicitly or implicitly calling the superclass constructor without arguments.
  Such a constructor can be safely removed as it will be generated by the compiler even if not specified.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {
    public Foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the inspection settings to ignore unnecessary constructors that have an annotation.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryFinalOnLocalVariableOrParameter" defaultSeverity="WARNING" displayName="Unnecessary 'final' on local variable or parameter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local variables or parameters unnecessarily declared &lt;code&gt;final&lt;/code&gt;.
&lt;p&gt;Some coding standards frown upon variables declared &lt;code&gt;final&lt;/code&gt; for reasons of terseness.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo(Object o) {}

    void bar(final Object o) {
      new Foo(o);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo(Object o) {}

    void bar(Object o) {
      new Foo(o);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the inspection options to toggle the reporting for:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    local variables
  &lt;/li&gt;
  &lt;li&gt;
    parameters (including
    parameters of &lt;code&gt;catch&lt;/code&gt; blocks and enhanced &lt;code&gt;for&lt;/code&gt; statements)
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  Also, you can configure the inspection to only report &lt;code&gt;final&lt;/code&gt; parameters of &lt;code&gt;abstract&lt;/code&gt; or interface
  methods, which may be considered extra unnecessary as such markings don't
  affect the implementation of these methods.
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnqualifiedStaticUsage" defaultSeverity="WARNING" displayName="Unqualified static access" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usage of static members that is not qualified
with the class name.
&lt;p&gt;
This is legal if the static member is in
the same class, but may be confusing.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      foo();
      System.out.println(x);
    }

    static void baz() { foo(); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      Foo.foo();
      System.out.println(Foo.x);
    }

    static void baz() { Foo.foo(); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the inspection settings to toggle the reporting for the following items:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;
      static fields access&lt;br&gt;
      &lt;code&gt;void bar() { System.out.println(x); }&lt;/code&gt;
    &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      calls to static methods&lt;br&gt;
      &lt;code&gt;void bar() { foo(); }&lt;/code&gt;&lt;br&gt;
      &lt;code&gt;static void baz() { foo(); }&lt;/code&gt;
    &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  You can also configure the inspection to only report static member usage from a non-static context.
  In the above example, &lt;code&gt;static void baz() { foo(); }&lt;/code&gt; will not be reported.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantFieldInitialization" defaultSeverity="WARNING" displayName="Redundant field initialization" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields explicitly initialized to their default values.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo = 0;
    List bar = null;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo;
    List bar;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the inspection settings to only report explicit &lt;code&gt;null&lt;/code&gt; initialization, for example:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo = 0;     // no warning
    List bar = null; // redundant field initialization warning
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryQualifierForThis" defaultSeverity="WARNING" displayName="Unnecessary qualifier for 'this' or 'super'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary qualification of &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt;.
&lt;p&gt;
  Using a qualifier on &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt; to
  disambiguate a code reference may easily become unnecessary via automatic refactorings and should be deleted for clarity.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void foo() {}
  }

  class Bar extends Foo {
    void bar() {
      Bar.super.foo();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void foo() {}
  }

  class Bar extends Foo {
    void bar() {
      super.foo();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CharsetObjectCanBeUsed" defaultSeverity="WARNING" displayName="Standard 'Charset' object can be used" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods and constructors in which constant charset &lt;code&gt;String&lt;/code&gt; literal (for example, &lt;code&gt;"UTF-8"&lt;/code&gt;) can be replaced with
the predefined &lt;code&gt;StandardCharsets.UTF_8&lt;/code&gt; code.
&lt;p&gt;The code after the fix may work faster, because the charset lookup becomes unnecessary.
  Also, catching &lt;code&gt;UnsupportedEncodingException&lt;/code&gt; may become unnecessary as well. In this case,
  the catch block will be removed automatically.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    byte[] bytes = "str".getBytes("UTF-8");
  } catch (UnsupportedEncodingException e) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  byte[] bytes = "str".getBytes(StandardCharsets.UTF_8);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;The inspection is available in Java 7 and later.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2018.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayCreationWithoutNewKeyword" defaultSeverity="INFORMATION" displayName="Array creation without 'new' expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports array initializers without &lt;code&gt;new&lt;/code&gt; array expressions and suggests adding them.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int[] a = {42}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int[] a = new int[]{42}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnnecessaryCallToStringValueOf" defaultSeverity="WARNING" displayName="Unnecessary conversion to 'String'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to static methods like &lt;code&gt;String.valueOf()&lt;/code&gt; or &lt;code&gt;Integer.toString()&lt;/code&gt; when they are used in
 a string concatenation or as an argument of a library method in which the explicit string conversion is not needed.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println("Number: " + Integer.toString(count));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println("Number: " + count);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Library methods in which explicit string conversion is considered redundant:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Classes &lt;code&gt;java.io.PrintWriter&lt;/code&gt;, &lt;code&gt;java.io.PrintStream&lt;/code&gt;
    &lt;ul&gt;&lt;li&gt;&lt;code&gt;print()&lt;/code&gt;, &lt;code&gt;println()&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    Classes &lt;code&gt;java.lang.StringBuilder&lt;/code&gt;, &lt;code&gt;java.lang.StringBuffer&lt;/code&gt;
    &lt;ul&gt;&lt;li&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
  &lt;/li&gt;

  &lt;li&gt;
    Class &lt;code&gt;org.slf4j.Logger&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;trace()&lt;/code&gt;, &lt;code&gt;debug()&lt;/code&gt;, &lt;code&gt;info()&lt;/code&gt;, &lt;code&gt;warn()&lt;/code&gt;, &lt;code&gt;error()&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RecordCanBeClass" defaultSeverity="INFORMATION" displayName="Record can be converted to class" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports record classes and suggests converting them to ordinary classes.
&lt;p&gt;This inspection makes it possible to move a Java record to a codebase using an earlier Java version
  by applying the quick-fix to this record.&lt;/p&gt;
&lt;p&gt;
  Note that the resulting class is not completely equivalent to the original record:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The resulting class no longer extends &lt;code&gt;java.lang.Record&lt;/code&gt;,
    so &lt;code&gt;instanceof Record&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Reflection methods like &lt;code&gt;Class.isRecord()&lt;/code&gt; and
    &lt;code&gt;Class.getRecordComponents()&lt;/code&gt; produce different results.&lt;/li&gt;
  &lt;li&gt;The generated &lt;code&gt;hashCode()&lt;/code&gt; implementation may produce a different result
    because the formula to calculate record &lt;code&gt;hashCode&lt;/code&gt; is deliberately not specified.&lt;/li&gt;
  &lt;li&gt;Record serialization mechanism differs from that of an ordinary class.
    Refer to &lt;i&gt;Java Object Serialization Specification&lt;/i&gt; for details.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record Point(int x, int y) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final class Point {
    private final int x;
    private final int y;

    Point(int x, int y) {
      this.x = x;
      this.y = y;
    }

    public int x() { return x; }

    public int y() { return y; }

    @Override
    public boolean equals(Object obj) {
      if (obj == this) return true;
      if (obj == null || obj.getClass() != this.getClass()) return false;
      var that = (Point)obj;
      return this.x == that.x &amp;&amp;
             this.y == that.y;
    }

    @Override
    public int hashCode() {
      return Objects.hash(x, y);
    }

    @Override
    public String toString() {
      return "Point[" +
             "x=" + x + ", " +
             "y=" + y + ']';
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 16 higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2020.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnqualifiedMethodAccess" defaultSeverity="WARNING" displayName="Instance method call not qualified with 'this'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to non-&lt;code&gt;static&lt;/code&gt; methods on the same instance that are not qualified with &lt;code&gt;this&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void bar() {}

    void foo() {
      bar();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void bar() {}

    void foo() {
      this.bar();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalContainsCollection" defaultSeverity="WARNING" displayName="'Optional' contains array or collection" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;java.util.Optional&lt;/code&gt; or &lt;code&gt;com.google.common.base.Optional&lt;/code&gt; types with an array or collection type parameter.
&lt;p&gt;In such cases, it is more clear to just use an empty array or collection to indicate the absence of result.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; foo() {
    return Optional.empty();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code could look like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; foo() {
    return new List&amp;lt;&amp;gt;();
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ListIndexOfReplaceableByContains" defaultSeverity="WARNING" displayName="'List.indexOf()' expression can be replaced with 'contains()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any &lt;code&gt;List.indexOf()&lt;/code&gt;
expressions that can be replaced with the 
  &lt;code&gt;List.contains()&lt;/code&gt; method.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean hasEmptyString(List&amp;lt;String&amp;gt; list) {
    // Warning: can be simplified
    return list.indexOf("") &amp;gt;= 0;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The provided quick-fix replaces the &lt;code&gt;indexOf&lt;/code&gt; call with the &lt;code&gt;contains&lt;/code&gt; call:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean hasEmptyString(List&amp;lt;String&amp;gt; list) {
    // Quick-fix is applied
    return list.contains("");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarilyQualifiedStaticallyImportedElement" defaultSeverity="WARNING" displayName="Unnecessarily qualified statically imported element" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usage of statically imported members qualified with
their containing class name.
&lt;p&gt;Such qualification is unnecessary and can be removed
  because statically imported members can be accessed directly by member name.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import static foo.Test.WIDTH;

  class Bar {
    void bar() {
      System.out.println(Test.WIDTH);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import static foo.Test.WIDTH;

  class Bar {
    void bar() {
      System.out.println(WIDTH);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnclearBinaryExpression" defaultSeverity="INFORMATION" displayName="Multiple operators with different precedence" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports binary, conditional, or &lt;code&gt;instanceof&lt;/code&gt; expressions that consist of different operators
without parentheses. Such expressions can be less readable due to different precedence rules of operators.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = 3 + 9 * 8 + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = 3 + (9 * 8) + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitCallToSuper" defaultSeverity="WARNING" displayName="Implicit call to 'super()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports constructors that do not begin with a call to "super" constructor or
another constructor of the same class.
&lt;p&gt;Such constructors can be thought of as implicitly beginning with a
  call to &lt;code&gt;super()&lt;/code&gt;. Some coding standards prefer that such calls to
  &lt;code&gt;super()&lt;/code&gt; be made explicitly.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {
      super();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the inspection settings to ignore classes extending directly from &lt;code&gt;Object&lt;/code&gt;.
  For instance:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    Foo() {} // Not reported
  }

  class Bar extends Foo {
    Bar() {} // Implicit call to 'super()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldMayBeFinal" defaultSeverity="WARNING" displayName="Field may be 'final'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields that can be safely made &lt;code&gt;final&lt;/code&gt;.
All &lt;code&gt;final&lt;/code&gt; fields have a value and this value does not change, which can make the code easier to reason about.
&lt;p&gt;To avoid too expensive analysis, this inspection only reports if the field has a &lt;code&gt;private&lt;/code&gt; modifier
  or it is defined in a local or anonymous class.
  A field can be &lt;code&gt;final&lt;/code&gt; if:
&lt;ul&gt;
  &lt;li&gt;It is &lt;code&gt;static&lt;/code&gt; and initialized once in its declaration or in one &lt;code&gt;static&lt;/code&gt; initializer.&lt;/li&gt;
  &lt;li&gt;It is non-&lt;code&gt;static&lt;/code&gt; and initialized once in its declaration, in one instance initializer or in every constructor&lt;/li&gt;
&lt;/ul&gt;
And it is not modified anywhere else.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Person {
    private String name; // can be final

    Person(String name) {
      this.name = name;
    }

    public String getName() {
      return name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Person {
    private final String name;

    Person(String name) {
      this.name = name;
    }

    public String getName() {
      return name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SwitchLabeledRuleCanBeCodeBlock" defaultSeverity="INFORMATION" displayName="Labeled switch rule can have code block" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports rules of &lt;code&gt;switch&lt;/code&gt; expressions or enhanced &lt;code&gt;switch&lt;/code&gt; statements with an expression body.
These can be converted to code blocks.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String message = switch (errorCode) {
    case 404 -&gt; "Not found!";
    ...
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String message = switch (errorCode) {
    case 404 -&gt; {
                yield "Not found!";
            }
    ...
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;The inspection only reports if the language level of the project or module is 14 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2019.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryParentheses" defaultSeverity="INFORMATION" displayName="Unnecessary parentheses" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any instance of unnecessary parentheses.
&lt;p&gt;Parentheses are considered unnecessary if the evaluation order of an expression remains
  unchanged after you remove the parentheses.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = 3 + (9 * 8);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int n = 3 + 9 * 8;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore clarifying parentheses&lt;/b&gt; option to ignore parentheses that help clarify a binary
    expression. Parentheses are clarifying if the parenthesized expression is an
    &lt;code&gt;instanceof&lt;/code&gt; expression that is a part of a larger expression or has a different operator than the parent expression.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore parentheses around the condition of conditional expressions&lt;/b&gt; option to ignore any
    parentheses around the condition of conditional expressions. Some coding standards specify that all such
    conditions must be surrounded by parentheses.&lt;/li&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Ignore parentheses around single no formal type lambda parameter&lt;/b&gt; option to ignore parentheses
    around a single lambda parameter within a lambda expression.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryConstantArrayCreationExpression" defaultSeverity="WARNING" displayName="Redundant 'new' expression in constant array creation" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports constant new array expressions that can be replaced with an array initializer. Array initializers can omit the type because
it is already specified in the left side of the assignment.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int[] foo = new int[] {42};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int[] foo = {42};
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeParameterExtendsObject" defaultSeverity="WARNING" displayName="Type parameter explicitly extends 'Object'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports type parameters and wildcard type arguments that are explicitly declared to extend &lt;code&gt;java.lang.Object&lt;/code&gt;.
&lt;p&gt;Such 'extends' clauses are redundant as &lt;code&gt;java.lang.Object&lt;/code&gt; is a supertype for all classes.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class ClassA&amp;lt;T extends Object&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  If you need to preserve the 'extends Object' clause because of annotations, disable the
  &lt;b&gt;Ignore when java.lang.Object is annotated&lt;/b&gt; option.
  This might be useful, for example, when you use a nullness analyzer, and the 'extends Object' clause
  holds a &lt;code&gt;@Nullable&lt;/code&gt;/&lt;code&gt;@NotNull&lt;/code&gt; annotation.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class MyClass&amp;lt;T extends @NotNull Object&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessarySemicolon" defaultSeverity="WARNING" displayName="Unnecessary semicolon" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any unnecessary semicolons, including semicolons that are used between class members, inside block statements, or after
class definitions.
&lt;p&gt;Even though these semicolons are valid in Java, they are redundant and may be removed.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    ;
    void m() throws Exception {
        try (AutoCloseable r1 = createAutoCloseable();) {
          ;
        }
    }
    ;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    void m() throws Exception {
      try (AutoCloseable r1 = createAutoCloseable()) {
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryToStringCall" defaultSeverity="WARNING" displayName="Unnecessary call to 'toString()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;toString()&lt;/code&gt; that are used in the following cases:
&lt;ul&gt;
  &lt;li&gt;In string concatenations&lt;/li&gt;
  &lt;li&gt;In the &lt;code&gt;java.lang.StringBuilder#append()&lt;/code&gt; or &lt;code&gt;java.lang.StringBuffer#append()&lt;/code&gt; methods&lt;/li&gt;
  &lt;li&gt;In the methods of &lt;code&gt;java.io.PrintWriter&lt;/code&gt; or &lt;code&gt;java.io.PrintStream&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;in the methods &lt;code&gt;org.slf4j.Logger&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In these cases, conversion to string will be handled by the underlying library methods, and the explicit call to &lt;code&gt;toString()&lt;/code&gt; is not needed.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(this.toString())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(this)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Note that without the &lt;code&gt;toString()&lt;/code&gt; call, the code semantics might be different: if the expression is null,
  then the &lt;code&gt;null&lt;/code&gt; string will be used instead of throwing a &lt;code&gt;NullPointerException&lt;/code&gt;.&lt;/p&gt;
  &lt;p&gt;Use the &lt;b&gt;Report only when qualifier is known to be not-null&lt;/b&gt; option to avoid warnings for the values that could potentially be null.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryModifier" defaultSeverity="WARNING" displayName="Unnecessary modifier" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant modifiers and suggests to remove them.
The resulting code will be shorter, but the behaviour and meaning will remain the same.
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // all code is implicitly strictfp under Java 17 and higher
  strictfp class X {

    // inner enums are implicitly static
    static enum Inner {
        A, B, C
    }

    // inner records are implicitly static
    static record R() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final record R() {
    // all records are implicitly final
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;Example 3:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // all interfaces are implicitly abstract
  abstract interface Printer {

    // all interface members are implicitly public
    public int size();

    // all inner classes of interfaces are implicitly static
    static class Inner {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantLabeledSwitchRuleCodeBlock" defaultSeverity="WARNING" displayName="Labeled switch rule has redundant code block" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports labeled rules of &lt;code&gt;switch&lt;/code&gt; statements or &lt;code&gt;switch&lt;/code&gt; expressions that have a redundant code block.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = switch (n) {
    case 1 -&gt; { yield Integer.toString(n); }
    default -&gt; "default";
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = switch (n) {
    case 1 -&gt; Integer.toString(n);
    default -&gt; "default";
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 14 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2019.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionalCanBeOptional" defaultSeverity="INFORMATION" displayName="Conditional can be replaced with Optional" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports null-check conditions and suggests replacing them with &lt;code&gt;Optional&lt;/code&gt; chains.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return str == null ? "" : str.trim();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After applying the quick-fix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return Optional.ofNullable(str).map(String::trim).orElse("");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While the replacement is not always shorter, it could be helpful for further refactoring
  (for example, for changing the method return value to &lt;code&gt;Optional&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Note that when a not-null branch of the condition returns null, the corresponding mapping step will
  produce an empty &lt;code&gt;Optional&lt;/code&gt; possibly changing the semantics. If it cannot be statically
  proven that semantics will be preserved, the quick-fix action name will contain the "(may change semantics)"
  notice, and the inspection highlighting will be turned off.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2018.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TryStatementWithMultipleResources" defaultSeverity="INFORMATION" displayName="'try' statement with multiple resources can be split" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;try&lt;/code&gt; statements with multiple resources that can be automatically split into
  multiple try-with-resources statements.
&lt;p&gt;This conversion can be useful for further refactoring
(for example, for extracting the nested &lt;code&gt;try&lt;/code&gt; statement into a separate method). &lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try (FileInputStream in = new FileInputStream("in.txt");
     FileOutputStream out = new FileOutputStream("out.txt")) {
     /*read and write*/
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try (FileInputStream in = new FileInputStream("in.txt")) {
    try (FileOutputStream out = new FileOutputStream("out.txt")) {
      /*read and write*/
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AssertMessageNotString" defaultSeverity="WARNING" displayName="'assert' message is not a string" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;assert&lt;/code&gt; messages that are not of the &lt;code&gt;java.lang.String&lt;/code&gt; type.
&lt;p&gt;Using a string provides more information to help diagnose the failure
  or the assertion reason.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(List&amp;lt;Integer&amp;gt; myList) {
    assert myList.isEmpty() : false;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Only warn when the &lt;code&gt;assert&lt;/code&gt; message type is 'boolean' or 'java.lang.Boolean'&lt;/b&gt; option to only warn when the &lt;code&gt;assert&lt;/code&gt; message type is &lt;code&gt;boolean&lt;/code&gt; or &lt;code&gt;java.lang.Boolean&lt;/code&gt;.
A &lt;code&gt;boolean&lt;/code&gt; detail message is unlikely to provide additional information about an assertion failure
  and could result from a mistakenly entered &lt;code&gt;:&lt;/code&gt; instead of &lt;code&gt;&amp;&lt;/code&gt;.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SizeReplaceableByIsEmpty" defaultSeverity="WARNING" displayName="'size() == 0' can be replaced with 'isEmpty()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;.size()&lt;/code&gt; or &lt;code&gt;.length()&lt;/code&gt;
comparisons with a &lt;code&gt;0&lt;/code&gt; literal that can be replaced with a call to &lt;code&gt;.isEmpty()&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean emptyList = list.size() == 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean emptyList = list.isEmpty();
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignored classes&lt;/b&gt; table to add classes for which any &lt;code&gt;.size()&lt;/code&gt; or &lt;code&gt;.length()&lt;/code&gt; comparisons should not be replaced.
&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore expressions which would be replaced with &lt;code&gt;!isEmpty()&lt;/code&gt;&lt;/b&gt; option to ignore any expressions which would be replaced with &lt;code&gt;!isEmpty()&lt;/code&gt;.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalIsPresent" defaultSeverity="WARNING" displayName="Non functional style 'Optional.isPresent()' usage" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports conditions, like &lt;code&gt;if(Optional.isPresent())&lt;/code&gt;, that can be rewritten in the functional style,
as it is shorter and easier to read.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (str.isPresent()) str.get().trim();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  str.ifPresent(String::trim);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleVariablesInDeclaration" defaultSeverity="INFORMATION" displayName="Multiple variables in one declaration" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports multiple variables that are declared in a single declaration and suggest
creating a separate declaration for each variable.
&lt;p&gt;Some coding standards prohibit such declarations.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x = 1, y = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x = 1;
  int y = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use the &lt;b&gt;Ignore 'for' loop declarations&lt;/b&gt; option to ignore multiple variables declared in the initialization of a 'for' loop statement, for example:
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;for&lt;/b&gt; (int i = 0, max = list.size(); i &amp;gt; max; i++) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;Use the &lt;b&gt;Only warn on different array dimensions in a single declaration&lt;/b&gt; option to only warn when variables with different array dimensions are declared in a single declaration, for example:
&lt;pre&gt;&lt;code&gt;
  String s = "", array[];
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;small&gt;New in 2019.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SingleElementAnnotation" defaultSeverity="INFORMATION" displayName="Non-normalized annotation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports annotations in a shorthand form and suggests rewriting them in a normal form with an attribute name.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @SuppressWarnings("foo")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @SuppressWarnings(value = "foo")
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnnecessarySuperQualifier" defaultSeverity="WARNING" displayName="Unnecessary 'super' qualifier" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary &lt;code&gt;super&lt;/code&gt;
qualifiers in method calls and field references.
&lt;p&gt;
  A &lt;code&gt;super&lt;/code&gt; qualifier is unnecessary
  when the field or method of the superclass is not hidden/overridden in the calling class.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void foo() {}
  }

  class Bar extends Foo {
    void bar() {
      super.foo();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    void foo() {}
  }

  class Bar extends Foo {
    void bar() {
      foo();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the inspection settings to ignore qualifiers that help to distinguish superclass members access
  from the identically named members of the outer class.
&lt;p&gt;
&lt;p&gt;
  See also the following inspections:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;i&gt;Java | Visibility | Access to inherited field looks like access to element from surrounding code&lt;/i&gt;&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Java | Visibility | Call to inherited method looks like call to local method&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultiCatchCanBeSplit" defaultSeverity="INFORMATION" displayName="Multi-catch can be split into separate catch blocks" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports multi-&lt;code&gt;catch&lt;/code&gt; sections and suggests splitting them into separate &lt;code&gt;catch&lt;/code&gt; blocks.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    int i = getIndex();
  } catch (NullPointerException|IndexOutOfBoundsException e) {
    e.printStackTrace();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    int i = getIndex();
  } catch (NullPointerException e) {
    e.printStackTrace();
  } catch (IndexOutOfBoundsException e) {
    e.printStackTrace();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 7 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ObjectsEqualsCanBeSimplified" defaultSeverity="INFORMATION" displayName="'Objects.equals()' can be replaced with 'equals()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Objects.equals(a, b)&lt;/code&gt; in which the first argument is statically known to be non-null.
&lt;p&gt;Such a call can be safely replaced with &lt;code&gt;a.equals(b)&lt;/code&gt; or &lt;code&gt;a == b&lt;/code&gt; if both arguments are primitives.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String defaultName = "default";
  boolean isDefault = Objects.equals(defaultName, name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String defaultName = "default";
  boolean isDefault = defaultName.equals(name);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableAnnotation" defaultSeverity="WARNING" displayName="Simplifiable annotation" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports annotations that can be simplified to their 'single element'
or 'marker' shorthand form.
&lt;p&gt;Annotations that contain whitespace between the @-sign and the name
  of the annotation are also reported.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @interface Foo { String[] value(); }

  @ Foo({"foo"})
  public String name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @interface Foo { String[] value(); }

  @Foo("foo")
  public String name;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantExpression" defaultSeverity="INFORMATION" displayName="Constant expression can be evaluated" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports compile-time constant expressions and suggests replacing them with their
  actual values. For example, you will be prompted to replace "2 + 2" with "4".

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalToIf" defaultSeverity="INFORMATION" displayName="'Optional' can be replaced with sequence of 'if' statements" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Optional&lt;/code&gt; call chains that can be replaced with a sequence of &lt;code&gt;if&lt;/code&gt; statements.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return Optional.ofNullable(name)
    .map(this::extractInitials)
    .map(initials -&gt; initials.toUpperCase(Locale.ENGLISH))
    .orElseGet(this::getDefault);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (name != null) {
    String initials = extractInitials(name);
    if (initials != null) return initials.toUpperCase(Locale.ENGLISH);
  }
  return getDefault();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2020.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnqualifiedFieldAccess" defaultSeverity="WARNING" displayName="Instance field access not qualified with 'this'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports field access operations that are not qualified with &lt;code&gt;this&lt;/code&gt; or some other qualifier.
&lt;p&gt;
  Some coding styles mandate that all field access operations are qualified to prevent confusion with local
  variable or parameter access.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo;

    void bar() {
      foo += 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    int foo;

    void bar() {
      this.foo += 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ControlFlowStatementWithoutBraces" defaultSeverity="INFORMATION" displayName="Control flow statement without braces" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, or &lt;code&gt;for&lt;/code&gt; statements without braces.
Some code styles, e.g. the &lt;a href="https://google.github.io/styleguide/javaguide.html"&gt;Google Java Style guide&lt;/a&gt;,
require braces for all control statements.
&lt;p&gt;
  When adding further statements to control statements without braces, it is important not to forget adding braces.
  When commenting out a line of code, it is also necessary to be more careful when not using braces,
  to not inadvertently make the next statement part of the control flow statement.
  Always using braces makes insertion or commenting out of a line of code safer.
&lt;p&gt;
  It's likely the &lt;a href="https://www.imperialviolet.org/2014/02/22/applebug.html"&gt;goto fail vulnerability&lt;/a&gt; would not have happened,
  if an always use braces code style was used.
  Control statements with braces make the control flow easier to see, without relying on, possibly incorrect, indentation.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Strange {
    void x(boolean one, boolean two) {
      if(one)
        if(two)
          foo();
      else
        bar();
    }

    void foo() {}
    void bar() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix wraps the statement body with braces:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Strange {
    void x(boolean one, boolean two) {
      if(one) {
        if(two) {
          foo();
        } else {
          bar();
        }
      }
    }

    void foo() {}
    void bar() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaBodyCanBeCodeBlock" defaultSeverity="INFORMATION" displayName="Lambda body can be code block" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports lambdas whose body is an expression and suggests converting expression bodies to code blocks.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  n&amp;nbsp;-&amp;gt;&amp;nbsp;n&amp;nbsp;+&amp;nbsp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n -&amp;gt; {
  return n + 1;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Numeric issues" path="Java"><inspection shortName="BadOddness" defaultSeverity="WARNING" displayName="Suspicious oddness check" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports odd-even checks of the following form: &lt;code&gt;x % 2 == 1&lt;/code&gt;.
Such checks fail when used with negative odd values.
Consider using &lt;code&gt;x % 2 != 0&lt;/code&gt; or &lt;code&gt;(x &amp; 1) == 1&lt;/code&gt; instead.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CharUsedInArithmeticContext" defaultSeverity="WARNING" displayName="'char' expression used in arithmetic context" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports expressions of the &lt;code&gt;char&lt;/code&gt; type used in addition or subtraction expressions.
&lt;p&gt;Such code is not necessarily an issue but may result in bugs (for example,
  if a string is expected).&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;int a = 'a' + 42;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;After the quick-fix is applied: &lt;code&gt;int a = (int) 'a' + 42;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;For the &lt;code&gt;String&lt;/code&gt; context:
&lt;pre&gt;&lt;code&gt;int i1 = 1;
int i2 = 2;
System.out.println(i2 + '-' + i1 + &amp;quot; = &amp;quot; + (i2 - i1));&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;code&gt;System.out.println(i2 + &amp;quot;-&amp;quot; + i1 + &amp;quot; = &amp;quot; + (i2 - i1));&lt;/code&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparisonOfShortAndChar" defaultSeverity="WARNING" displayName="Comparison of 'short' and 'char' values" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports equality comparisons between &lt;code&gt;short&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; values.
&lt;p&gt;Such comparisons may cause subtle bugs because while both values are 2-byte long, &lt;code&gt;short&lt;/code&gt; values are
  signed, and &lt;code&gt;char&lt;/code&gt; values are unsigned.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if (Character.MAX_VALUE == shortValue()) {} //never can be true
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonReproducibleMathCall" defaultSeverity="WARNING" displayName="Non-reproducible call to 'Math'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.lang.Math&lt;/code&gt; methods, which results are not guaranteed to be reproduced precisely.
&lt;p&gt;In environments where reproducibility of results is required, &lt;code&gt;java.lang.StrictMath&lt;/code&gt;
  should be used instead.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IntegerDivisionInFloatingPointContext" defaultSeverity="WARNING" displayName="Integer division in floating point context" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports integer divisions where the result is used as a floating-point number.
Such division is often an error and may have unexpected results
due to the truncation that happens in integer division.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  float x = 3.0F + 3/5;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BigDecimalEquals" defaultSeverity="WARNING" displayName="'equals()' called on 'BigDecimal'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;.equals()&lt;/code&gt; being called to compare two &lt;code&gt;java.math.BigDecimal&lt;/code&gt; numbers.
&lt;p&gt;This is normally a mistake, as two &lt;code&gt;java.math.BigDecimal&lt;/code&gt; numbers are only equal if
  they are equal in both value and scale.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (new BigDecimal("2.0").equals(new BigDecimal("2.00"))) {}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (new BigDecimal("2.0").compareTo(new BigDecimal("2.00")) == 0) {}&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CachedNumberConstructorCall" defaultSeverity="WARNING" displayName="Number constructor call with primitive argument" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instantiations of new &lt;code&gt;Long&lt;/code&gt;,
&lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt;, or
&lt;code&gt;Byte&lt;/code&gt; objects that have a primitive &lt;code&gt;long&lt;/code&gt;,
&lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, or
&lt;code&gt;byte&lt;/code&gt;
argument.
&lt;p&gt;It is recommended that you use the static method &lt;code&gt;valueOf()&lt;/code&gt;
  introduced in Java 5. By default, this method caches objects for values between -128 and
  127 inclusive.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer i = new Integer(1);
  Long l = new Long(1L);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied, the code changes to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer i = Integer.valueOf(1);
  Long l = Long.valueOf(1L);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 5 or higher&lt;/p&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignore new number expressions with a String argument&lt;/b&gt; option to ignore calls to number constructors with a &lt;code&gt;String&lt;/code&gt; argument.&lt;/p&gt;
&lt;p&gt;
  Use the &lt;b&gt;Report only when constructor is @Deprecated&lt;/b&gt;  option to only report calls to deprecated constructors.
  &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Short&lt;/code&gt; and &lt;code&gt;Byte&lt;/code&gt; constructors are deprecated since JDK 9.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BigDecimalMethodWithoutRoundingCalled" defaultSeverity="WARNING" displayName="Call to 'BigDecimal' method without a rounding mode argument" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;divide()&lt;/code&gt; or &lt;code&gt;setScale()&lt;/code&gt; without a rounding mode argument.
&lt;p&gt;Such calls can lead to an &lt;code&gt;ArithmeticException&lt;/code&gt; when the exact value cannot be represented in the result
  (for example, because it has a non-terminating decimal expansion).&lt;/p&gt;
&lt;p&gt;Specifying a rounding mode prevents the &lt;code&gt;ArithmeticException&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  BigDecimal.valueOf(1).divide(BigDecimal.valueOf(3));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousLiteralUnderscore" defaultSeverity="WARNING" displayName="Suspicious underscore in number literal" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports decimal number literals that use the underscore numeric separator with groups where the number of digits is not three.
Such literals may contain a typo.
&lt;p&gt;This inspection will not warn on literals containing two consecutive underscores.
It is also allowed to omit underscores in the fractional part of &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; literals.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;int oneMillion = 1_000_0000;&lt;/code&gt;&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FloatingPointEquality" defaultSeverity="WARNING" displayName="Floating point equality comparison" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports floating-point values that are being compared using the &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt; operator.
&lt;p&gt;Floating-point values are inherently inaccurate, and comparing them for exact equality is seldom the desired semantics.&lt;/p&gt;
&lt;p&gt;This inspection ignores comparisons with zero and infinity literals.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  void m(double d1, double d2) {
    if (d1 == d2) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LongLiteralsEndingWithLowercaseL" defaultSeverity="WARNING" displayName="'long' literal ending with 'l' instead of 'L'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;long&lt;/code&gt; literals ending with lowercase 'l'. These
literals may be confusing, as lowercase 'l' looks very similar to '1'.
&lt;p&gt;The quick-fix for this inspection replaces lowercase 'l' with uppercase 'L'.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OctalAndDecimalIntegersMixed" defaultSeverity="WARNING" displayName="Octal and decimal integers in same array" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports mixed octal and decimal integer literals in a single array initializer.
This situation might happen when you copy a list of numbers into an array initializer.
Some numbers in the array might be zero-padded and the compiler will interpret them as octal.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] elapsed = {1, 13, 052};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix that removes a leading zero is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] elapsed = {1, 13, 52};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If it is an octal number (for example, after a variable inline), then you can use another quick-fix that converts octal to decimal:&lt;/p&gt;
&lt;code&gt;int[] elapsed = {1, 13, 42};&lt;/code&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConfusingFloatingPointLiteral" defaultSeverity="WARNING" displayName="Confusing floating point literal" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any floating point numbers that don't have a decimal point, numbers before the decimal point,
or numbers after the decimal point.
&lt;p&gt;Such literals may be confusing, and violate several coding standards.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double d = .03;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double d = 0.03;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore floating point literals in scientific notation&lt;/b&gt; option to ignore floating point numbers in scientific notation.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnaryPlus" defaultSeverity="WARNING" displayName="Unary plus" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of the &lt;code&gt;+&lt;/code&gt; unary operator. The unary plus is usually a null operation, and
its presence might represent a coding error. For example, in a combination with the increment operator (like in &lt;code&gt;+++&lt;/code&gt;)
or with the equal operator (like in &lt;code&gt;=+&lt;/code&gt;).
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void unaryPlus(int i) {
    int x = + +i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following quick fixes are suggested:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;Remove &lt;code&gt;+&lt;/code&gt; operators before the &lt;code&gt;i&lt;/code&gt; variable:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void unaryPlus(int i) {
    int x = i;
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;p&gt;Replace &lt;code&gt;+&lt;/code&gt; operators with the prefix increment operator:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void unaryPlus(int i) {
    int x = ++i;
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the checkbox below to report unary pluses that are used together with a binary or another unary expression.
It means the inspection will not report situations when a unary plus expression is used in array
initializer expressions or as a method argument.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DivideByZero" defaultSeverity="WARNING" displayName="Division by zero" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports division by zero or remainder by zero.
Such expressions will produce an &lt;code&gt;Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt; or &lt;code&gt;NaN&lt;/code&gt; result for doubles or floats,
and will throw an &lt;code&gt;ArithmeticException&lt;/code&gt; for integers.
&lt;p&gt;When the expression has a &lt;code&gt;NaN&lt;/code&gt; result, the fix suggests replacing the division expression with the &lt;code&gt;NaN&lt;/code&gt; constant.
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryUnaryMinus" defaultSeverity="WARNING" displayName="Unnecessary unary minus" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary unary minuses. Such expressions might be hard to understand and might contain errors.
&lt;p&gt;&lt;b&gt;For example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    int x = - -i;
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following quick fixes are suggested here:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;Remove &lt;code&gt;-&lt;/code&gt; operators before the &lt;code&gt;i&lt;/code&gt; variable:&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    int x = i;
  }&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
 &lt;p&gt;Replace &lt;code&gt;-&lt;/code&gt; operators with the prefix decrement operator:&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    int x = --i;
  }&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;Another example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    i += - 8;
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void unaryMinus(int i) {
    i -= 8;
  }&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OctalLiteral" defaultSeverity="WARNING" displayName="Octal integer" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports octal integer literals. Some coding standards prohibit the
use of octal literals, as they may be easily confused with decimal literals.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 015;
  int j = 0_777;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This inspection has two different quick-fixes.
  After the &lt;b&gt;Convert octal literal to decimal literal&lt;/b&gt; quick-fix is applied, the code changes to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 13;
  int j = 511;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the &lt;b&gt;Remove leading zero to make decimal&lt;/b&gt; quick-fix is applied, the code changes to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 15;
  int j = 777;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NumericOverflow" defaultSeverity="WARNING" displayName="Numeric overflow" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports expressions that overflow during computation.
Usually, this happens by accident and indicates a bug. For example, a wrong type is used or a shift should be done in an opposite direction .
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  float a = 1.0f/0.0f;
  long b = 30 * 24 * 60 * 60 * 1000;
  long c = 1000L &amp;lt;&amp;lt; 62;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparisonToNaN" defaultSeverity="WARNING" displayName="Comparison to 'Double.NaN' or 'Float.NaN'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any comparisons to &lt;code&gt;Double.NaN&lt;/code&gt; or &lt;code&gt;Float.NaN&lt;/code&gt;.
Such comparisons are never meaningful, as NaN is not equal to anything, including itself.
Use the &lt;code&gt;Double.isNaN()&lt;/code&gt; or &lt;code&gt;Float.isNaN()&lt;/code&gt; methods instead.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (x == Double.NaN) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (Double.isNaN(x)) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnpredictableBigDecimalConstructorCall" defaultSeverity="WARNING" displayName="Unpredictable 'BigDecimal' constructor call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;BigDecimal&lt;/code&gt; constructors that accept a &lt;code&gt;double&lt;/code&gt; value.
These constructors produce &lt;code&gt;BigDecimal&lt;/code&gt; that is exactly equal to the supplied &lt;code&gt;double&lt;/code&gt; value.
However, because doubles are encoded in the IEEE 754 64-bit double-precision binary floating-point format, the exact value can be unexpected.
&lt;p&gt;For example, &lt;code&gt;new BigDecimal(0.1)&lt;/code&gt; yields a &lt;code&gt;BigDecimal&lt;/code&gt; object. Its value is
  &lt;small&gt;&lt;code&gt;0.1000000000000000055511151231257827021181583404541015625&lt;/code&gt;&lt;/small&gt;
  which is the nearest number to 0.1 representable as a double.
  To get &lt;code&gt;BigDecimal&lt;/code&gt; that stores the same value as written in the source code,
  use either &lt;code&gt;new BigDecimal("0.1")&lt;/code&gt; or &lt;code&gt;BigDecimal.valueOf(0.1)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Constructor {
    void foo() {
      new BigDecimal(0.1);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Constructor {
    void foo() {
      new BigDecimal("0.1");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitNumericConversion" defaultSeverity="WARNING" displayName="Implicit numeric conversion" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports implicit conversion between numeric types.
&lt;p&gt;Implicit numeric conversion is not a problem in itself but, if unexpected, may cause difficulties when tracing bugs.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double m(int i) {
    return i * 10;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double m(int i) {
    return (double) (i * 10);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore widening conversions&lt;/b&gt; option to ignore implicit conversion that cannot result in data loss
    (for example, &lt;code&gt;int&lt;/code&gt;-&amp;gt;&lt;code&gt;long&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore conversions from and to 'char'&lt;/b&gt; option to ignore conversion from and to &lt;code&gt;char&lt;/code&gt;. The inspection will
    still report conversion from and to floating-point numbers.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore conversion from constants and literals&lt;/b&gt; to make the inspection ignore conversion from literals and
    compile-time constants.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantMathCall" defaultSeverity="WARNING" displayName="Constant call to 'Math'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.lang.Math&lt;/code&gt; or &lt;code&gt;java.lang.StrictMath&lt;/code&gt; methods that can be determined as simple compile-time constants.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double v = Math.sin(0.0);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double v = 0.0;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OverlyComplexArithmeticExpression" defaultSeverity="WARNING" displayName="Overly complex arithmetic expression" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports arithmetic expressions with the excessive number of terms. Such expressions might be hard to understand and might contain errors.
&lt;p&gt;Parameters, field references, and other primary expressions are counted as a term.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
  &lt;pre&gt;&lt;code&gt;int calc(int a, int b) {
        return a + a + a + b + b + b + b; // The line contains 7 terms and will be reported.
    }&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the field below to specify a number of terms allowed in arithmetic expressions.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveLiteralUnderscores" defaultSeverity="INFORMATION" displayName="Underscores in numeric literal" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports numeric literals with underscores and suggests removing them with a quick-fix.
This may be useful if you need to lower the language level.
&lt;p&gt;The quick-fix removes underscores from numeric literals. For example &lt;code&gt;1_000_000&lt;/code&gt; will be converted to &lt;code&gt;1000000&lt;/code&gt;.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 7 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2020.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InsertLiteralUnderscores" defaultSeverity="INFORMATION" displayName="Unreadable numeric literal" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports long numeric literals without underscores and suggests adding them. Underscores make such literals easier to read.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  1000000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  1_000_000
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project of module is 7 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2020.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PointlessArithmeticExpression" defaultSeverity="WARNING" displayName="Pointless arithmetic expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports pointless arithmetic expressions. Such expressions include adding or subtracting zero,
multiplying by zero or one, and division by one.
&lt;p&gt;Such expressions may be the result of automated refactorings and they are unlikely to be what the developer intended to do.&lt;/p&gt;
&lt;p&gt;The quick-fix simplifies such expressions.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int a) {
    int x = a - a;
    int y = a + 0;
    int res = x / x;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int a) {
    int x = 0;
    int y = a;
    int res = 1;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Note that in rare cases, the suggested replacement might not be completely equivalent to the original code
  for all possible inputs. For example, the inspection suggests replacing &lt;code&gt;x / x&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt;.
  However, if &lt;code&gt;x&lt;/code&gt; is zero, the original code throws &lt;code&gt;ArithmeticException&lt;/code&gt; or results in &lt;code&gt;NaN&lt;/code&gt;.
  Also, if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;, then the result is also &lt;code&gt;NaN&lt;/code&gt;. It's very unlikely that such behavior is  intended.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Probable bugs" path="Groovy"><inspection shortName="GroovyConstructorNamedArguments" defaultSeverity="WARNING" displayName="Named arguments of constructor call" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports named arguments of a default class constructor call which don't correspond to properties of this class.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
      def name
      def age
  }

  // 'firstName' property doesn't exist
  new Person(firstName: "John")
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrEqualsBetweenInconvertibleTypes" defaultSeverity="WARNING" displayName="'equals()' between objects of inconvertible types" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;equals()&lt;/code&gt; where the target and argument are of incompatible types.
&lt;p&gt;While such a call might theoretically be useful, most likely it represents a bug.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    new HashSet&amp;lt;String&amp;gt;() == new TreeSet&amp;lt;Integer&amp;gt;())
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SecondUnsafeCall" defaultSeverity="WARNING" displayName="Second unsafe call" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports possible &lt;b&gt;NullPointerException&lt;/b&gt; during chain methods or properties call.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  domain?.getZone().getName()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  domain?.getZone()?.getName()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInfiniteRecursion" defaultSeverity="WARNING" displayName="Infinite recursion" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods which must either recurse infinitely or throw an exception.
Methods reported by this inspection could not be finished correct.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
// this function always dive deeper
def fibonacci(int n) {
  return fibonacci(n-1) + fibonacci(n-2)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyLabeledStatement" defaultSeverity="WARNING" displayName="Labeled statement inspection" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports labels already used in parent workflow.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
cycle:
for (element in list) {
  cycle: // confusing label repeat
  element.chars().forEach {
  }
}
&lt;/code&gt;
&lt;/pre&gt;


&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInfiniteLoopStatement" defaultSeverity="WARNING" displayName="Infinite loop statement" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;do&lt;/code&gt; statements which
can only exit by throwing an exception. While such statements may be correct, they usually
happen by mistake.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
while(true) {
  Thread.sleep(1000)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyRangeTypeCheck" defaultSeverity="WARNING" displayName="Incorrect range arguments" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports types used in ranges that do not have a &lt;code&gt;next()&lt;/code&gt; or &lt;code&gt;previous()&lt;/code&gt; method
or do not implement the &lt;code&gt;java.lang.Comparable&lt;/code&gt; interface.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrPermitsClause" defaultSeverity="ERROR" displayName="Non-extending permitted subclasses" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports permitted classes that do not extend the sealed base class.&lt;p&gt;
&lt;p&gt;Groovy does not require that all permitted classes should be available in compile-time and compiled along with base class. Compiler will not warn the user on dealing with non-extending permitted subclass, but it contradicts the nature of sealed classes.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A permits B {} // reports B
  class B {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyResultOfObjectAllocationIgnored" defaultSeverity="WARNING" displayName="Result of object allocation ignored" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports object allocation where the result of this operation is ignored.
&lt;p&gt;
  Such allocation expressions are legal Groovy, but are usually either inadvertent, or
  evidence of a complicated object initialization strategy.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyInArgumentCheck" defaultSeverity="WARNING" displayName="Incompatible 'in' argument types" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of membership operator &lt;code&gt;in&lt;/code&gt; with items and containers of incompatible types.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = [1, 2]
if ("foo" in list) {} // list of Integers can't contain String
&lt;/code&gt;
&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNonShortCircuitBoolean" defaultSeverity="WARNING" displayName="Non short-circuit boolean" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the non-short-circuit forms of boolean operators 'and' and 'or' ( &lt;code&gt;&amp;&lt;/code&gt;
and &lt;code&gt;|&lt;/code&gt; ).
&lt;p&gt;
  The non-short-circuit versions are occasionally useful, but
  their presence is often due to typos of the short-circuit forms ( &lt;code&gt;&amp;&amp;&lt;/code&gt;
  and &lt;code&gt;||&lt;/code&gt; ), and may lead to subtle bugs.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if (a &amp; b) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if (a &amp;&amp; b) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrUnresolvedAccess" defaultSeverity="WEAK WARNING" displayName="Unresolved reference expression" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports reference expressions which cannot be resolved.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrSwitchExhaustivenessCheck" defaultSeverity="WEAK WARNING" displayName="Exhaustiveness check for switch expressions" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports switch expressions that do not cover all possible outcomes of the matched expression.&lt;p&gt;
&lt;p&gt;Groovy does not require that switch expression must be exhaustive. It acts as if an implicit &lt;code&gt;default -&gt; null&lt;/code&gt; branch is inserted.
  It may cause unexpected nulls if a developer forgets to insert necessary &lt;code&gt;case&lt;/code&gt; branches.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum A { X, Y }

  def foo(A a) {
    def x = switch (a) { // reports switch
      case A.X -&gt; ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyAccessibility" defaultSeverity="WARNING" displayName="Inaccessible element" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports references which exceed access rights.
&lt;p&gt;Access to private members breaks encapsulation.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyUntypedAccess" defaultSeverity="WARNING" displayName="Untyped reference expression" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports reference expressions whose type can't be determined.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDocCheck" defaultSeverity="ERROR" displayName="Unresolved GroovyDoc reference" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unresolved references inside GroovyDoc comments.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDivideByZero" defaultSeverity="WARNING" displayName="Division by zero" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports divisions by zero or remainders by zero.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def a = 42
  a / 0 // warning
  a % 0.0 // warning
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Logging" path="Java"><inspection shortName="ClassWithMultipleLoggers" defaultSeverity="WARNING" displayName="Class with multiple loggers" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that have multiple loggers declared.
Ensuring that every class has a single dedicated logger is an important step in providing a unified logging
implementation for an application.
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Critical {
    &lt;b&gt;protected static final&lt;/b&gt; Logger LOG = Logger.getLogger(Critical.class);

    &lt;b&gt;protected static final&lt;/b&gt; Logger myLogger = Logger.getLogger(getClass());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the table below to specify Logger class names.
Classes which declare multiple fields that have the type of one of the specified classes will be reported by this inspection.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenationArgumentToLogCall" defaultSeverity="WARNING" displayName="Non-constant string concatenation as argument to logging call" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-constant string concatenations that are used as arguments to &lt;b&gt;SLF4J&lt;/b&gt; and &lt;b&gt;Log4j 2&lt;/b&gt; logging methods.
Non-constant concatenations are evaluated at runtime even when the logging message is not logged; this can negatively impact performance.
It is recommended to use a parameterized log message instead, which will not be evaluated when logging is disabled.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Vital {
    &lt;b&gt;private static final&lt;/b&gt; Logger LOG = LoggerFactory.getLogger(Vital.class);

    &lt;b&gt;public void&lt;/b&gt; saveTheWorld(&lt;b&gt;int&lt;/b&gt; i, String s, &lt;b&gt;boolean&lt;/b&gt; b) {
      LOG.info("saveTheWorld(" + i + ", " + s + ", "  + b + ")");
      // todo
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Vital {
    &lt;b&gt;private static final&lt;/b&gt; Logger LOG = LoggerFactory.getLogger(Vital.class);

    &lt;b&gt;public void&lt;/b&gt; saveTheWorld(&lt;b&gt;int&lt;/b&gt; i, String s, &lt;b&gt;boolean&lt;/b&gt; b) {
      LOG.info("saveTheWorld({}, {}, {})", i, s, b);
      // todo
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Warn on&lt;/b&gt; list to ignore certain higher logging levels. Higher logging levels may be enabled even in production, and the arguments will always be evaluated.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoggingConditionDisagreesWithLogStatement" defaultSeverity="WARNING" displayName="Log condition does not match logging call" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;em&gt;is log enabled for&lt;/em&gt; conditions of &lt;code&gt;if&lt;/code&gt; statements that
do not match the log level of the contained logging call.
&lt;p&gt;
For example:
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;if&lt;/b&gt; (LOG.isTraceEnabled()) {
    // debug level logged, but checked for trace level
    LOG.debug("some log message");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection understands the &lt;em&gt;java.util.logging&lt;/em&gt;, &lt;em&gt;log4j&lt;/em&gt;, &lt;em&gt;Log4j 2&lt;/em&gt;, &lt;em&gt;Apache Commons Logging&lt;/em&gt;
and the &lt;em&gt;SLF4J&lt;/em&gt; logging frameworks.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithoutLogger" defaultSeverity="WARNING" displayName="Class without logger" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes which do not have a declared logger.
&lt;p&gt;Ensuring that every class has a dedicated logger is an important step in providing a unified logging
  implementation for an application. Interfaces, enumerations, annotations, inner classes, and abstract classes are not reported by this inspection.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; NoLoggerDeclared {

    &lt;b&gt;int&lt;/b&gt; calculateNthDigitOfPi(&lt;b&gt;int&lt;/b&gt; n) {
      // todo
      &lt;b&gt;return&lt;/b&gt; 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the table in the &lt;b&gt;Options&lt;/b&gt; section to specify logger class names.
Classes which do not declare a field with the type of one of the specified classes will be reported by this inspection.

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoggerInitializedWithForeignClass" defaultSeverity="WARNING" displayName="Logger initialized with foreign class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Logger&lt;/code&gt; instances that are initialized with a &lt;code&gt;class&lt;/code&gt; literal from a different class than the &lt;code&gt;Logger&lt;/code&gt;
is contained in. This can easily happen when copy-pasting some code from another class and
may result in logging events under an unexpected category and cause filters to be applied incorrectly.
&lt;p&gt;A quick-fix is provided to replace the foreign class literal with one from the surrounding class.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Paramount {
    &lt;b&gt;protected static final&lt;/b&gt; Logger LOG = Logger.getLogger(Critical.class);

    // ... other fields and methods
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Paramount {
    &lt;b&gt;protected static final&lt;/b&gt; Logger LOG = Logger.getLogger(Paramount.class);

    // ... other fields and methods
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the table to specify the logger factory classes and logger factory methods recognized by this inspection.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore loggers initialized with a superclass&lt;/b&gt; option to ignore loggers that are initialized with a superclass of
  the class containing the logger.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore loggers in non-public classes&lt;/b&gt; to only warn on loggers in &lt;code&gt;public&lt;/code&gt; classes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LogStatementGuardedByLogCondition" defaultSeverity="WARNING" displayName="Logging call not guarded by log condition" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports logging calls with non-constant arguments that are not surrounded by a guard condition.
The evaluation of the arguments of a logging call can be expensive.
Surrounding a logging call with a guard clause prevents that cost when logging
is disabled for the level used by the logging statement. This is especially useful for the
least serious level (trace, debug, finest) of logging calls, because those are
most often disabled in a production environment.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Principal {
    &lt;b&gt;void&lt;/b&gt; bad(Object object) {
      &lt;b&gt;if&lt;/b&gt; (true) {
        LOG.debug("log log log " + expensiveCalculation(object));
      }
      LOG.debug("some more logging " + expensiveCalculation(1));
    }

    &lt;b&gt;void&lt;/b&gt; good(Object) {
      &lt;b&gt;if&lt;/b&gt; (LOG.isDebug()) {
        LOG.debug("value: " + expensiveCalculation(object));
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
      Use the &lt;b&gt;Logger class name&lt;/b&gt; field to specify the logger class name used.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;
      Use the table to specify the logging methods this inspection should warn on, with the corresponding log condition text.
  &lt;/li&gt;
  &lt;li&gt;
      Use the &lt;b&gt;Flag all unguarded logging calls&lt;/b&gt; option to have the inspection flag all unguarded log calls, not only those with non-constant arguments.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicMethodWithoutLogging" defaultSeverity="WARNING" displayName="'public' method without logging" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any public methods that do not contain a logging statement. This inspection does not report
simple getters and setters.
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Crucial {
    &lt;b&gt;private static final &lt;/b&gt;Logger LOG = LoggerFactory.getLogger(Crucial.class);
    &lt;b&gt;public void&lt;/b&gt; doImportantStuff() {
      // warning on this method
    }

    &lt;b&gt;public void&lt;/b&gt; doOtherStuff() {
      LOG.info("do other stuff");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the table below to specify Logger class names.
Public methods that do not use instance methods of the specified classes will be reported by this inspection.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PlaceholderCountMatchesArgumentCount" defaultSeverity="WARNING" displayName="Number of placeholders does not match number of arguments in logging call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports SLF4J or Log4j 2 logging calls, such as &lt;code&gt;logger.info("{}: {}", key)&lt;/code&gt; where the number of &lt;code&gt;{}&lt;/code&gt; placeholders
in the logger message doesn't match the number of other arguments to the logging call.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonStaticFinalLogger" defaultSeverity="WARNING" displayName="Non-constant logger" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports logger fields that are not declared &lt;code&gt;static&lt;/code&gt; and/or &lt;code&gt;final&lt;/code&gt;.
Ensuring that every class logger is effectively constant and bound to that class
simplifies the task of providing a unified logging implementation for an application.
&lt;p&gt;A quick-fix is provided to change the logger modifiers to &lt;code&gt;static final&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Significant {
    &lt;b&gt;private&lt;/b&gt; Logger LOG = Logger.getLogger(Critical.class);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Significant {
    &lt;b&gt;private static final&lt;/b&gt; Logger LOG = Logger.getLogger(Critical.class);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Logger class name&lt;/b&gt; table to specify logger class names. The inspection will report the fields that are not &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;final&lt;/code&gt; and are of the type equal to one of the specified class names.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JavaBeans issues" path="Java"><inspection shortName="ClassWithoutNoArgConstructor" defaultSeverity="WARNING" displayName="Class without no-arg constructor" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes without a constructor that takes no arguments.
No-argument constructors are necessary in some contexts. For example, if a class needs to be created using reflection.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the checkbox below to ignore classes without explicit constructors.
  The compiler provides a default no-argument constructor to such classes.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithoutConstructor" defaultSeverity="WARNING" displayName="Class without constructor" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes without constructors.
&lt;p&gt;Some coding standards prohibit such classes.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousGetterSetter" defaultSeverity="WARNING" displayName="Suspicious getter/setter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports getter or setter methods that access a field that is not expected by its name.
For example, when &lt;code&gt;getY()&lt;/code&gt; returns the &lt;code&gt;x&lt;/code&gt; field. Usually, it might be a copy-paste error.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Point {
    private int x;
    private int y;

    public void setX(int x) { // Warning: setter 'setX()' assigns field 'y'
      this.y = x;
    }

    public int getY() { // Warning: getter 'getY()' returns field 'x'
      return x;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the checkbox below to report situations when a field in the class has a name that matches a name of a getter or a setter.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PropertyValueSetToItself" defaultSeverity="WARNING" displayName="Property value set to itself" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls of setter methods with the same object getter as a value.
Usually, this code does nothing and probably was not intended.
&lt;p&gt;&lt;b&gt;For example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bean.setPayerId(bean.getPayerId());&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldHasSetterButNoGetter" defaultSeverity="WARNING" displayName="Field has setter but no getter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields that have setter methods but no getter methods.
&lt;p&gt;
  In certain bean containers, when used within the Java beans specification, such fields might be difficult
  to work with.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Potentially confusing code constructs" path="Groovy"><inspection shortName="GrPackage" defaultSeverity="WARNING" displayName="Package mismatch" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports files with a declared package that does not match the package expected. Also, reports files without &lt;code&gt;package&lt;/code&gt; statements if the class is not located directly in
the source root directory.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrDeprecatedAPIUsage" defaultSeverity="WARNING" displayName="Deprecated API usage" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports references to deprecated classes, fields, and methods.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyResultOfIncrementOrDecrementUsed" defaultSeverity="WARNING" displayName="Result of increment or decrement used" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports increment or decrement expressions nested inside other expressions.
&lt;p&gt;
  Such expressions may be confusing, and violate the general design principle that a
  given construct should do precisely one thing.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnnecessaryQualifiedReference" defaultSeverity="WARNING" displayName="Unnecessary qualified reference" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports fully qualified references, which can be replaced with import.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  def swingBuilder = new groovy.swing.SwingBuilder()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import groovy.swing.SwingBuilder
 
  def swingBuilder = new SwingBuilder()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNestedConditional" defaultSeverity="WARNING" displayName="Nested conditional expression" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports ternary conditional expressions that are nested inside other conditional expressions.
Such nested conditionals may be very confusing. "Elvis" expressions are counted as conditionals
for purpose of this inspection.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
return (condition ? "result" : null) ?: "fail"
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GroovyNestedSwitch" defaultSeverity="WARNING" displayName="Nested switch statement" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;switch&lt;/code&gt; statements that are nested inside other &lt;code&gt;switch&lt;/code&gt; statements.
Such nested switch statements are confusing, and may result in unexpected behaviour.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
switch (outer) {
  case 1:
    switch (inner) {
      case 1:
        print "inner 1"
        break
      default:
        print "inner default"
    }
    break
  default:
    print "default"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GroovyOverlyComplexArithmeticExpression" defaultSeverity="WARNING" displayName="Overly complex arithmetic expression" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports arithmetic expressions with too many terms.
&lt;p&gt;
  Such expressions may be confusing and bug-prone.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 Use the &lt;b&gt;Maximum number of terms&lt;/b&gt; field to specify the maximum number of terms allowed in an arithmetic expression.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyNegatedIf" defaultSeverity="WARNING" displayName="Negated if condition expression" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; statements
which contain &lt;code&gt;else&lt;/code&gt; branches and whose conditions are negated.
Flipping the order of the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt;
branches will usually increase the clarity of such statements.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (!condition) {
  return "1"
} else {
  return "2"
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyImplicitNullArgumentCall" defaultSeverity="WEAK WARNING" displayName="Implicit null argument" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls with no arguments to method that has exactly one parameter.
This is equivalent to call with &lt;code&gt;null&lt;/code&gt;, and that behavior is often confusing and unintended.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def foo(String s){}
foo() // this call is actually 'foo(null)' call
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOverlyComplexBooleanExpression" defaultSeverity="WARNING" displayName="Overly complex boolean expression" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports boolean expressions with too many terms.
&lt;p&gt;
  Such expressions may be confusing and bug-prone.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
 Use the &lt;b&gt;Maximum number of terms&lt;/b&gt; field to specify the maximum number of terms allowed in a boolean expression.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDoubleNegation" defaultSeverity="WARNING" displayName="Double negation" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports double negation that can be simplified.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (!!functionCall()) {} // double negation
if (!(a != b)) {} // double negation
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (functionCall()) {}
if (a == b) {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GroovyEmptyStatementBody" defaultSeverity="WARNING" displayName="Statement with empty body" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt; statements
with empty bodies. While occasionally intended, this construction is confusing, and often the result of a typo.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
if (condition) {}
while(true){}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyPointlessBoolean" defaultSeverity="WARNING" displayName="Pointless boolean expression" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports pointless or pointlessly complicated boolean expressions.
&lt;p&gt;
  Such expressions include conjunction with true,
  disjunction with false,
  equality comparison with a boolean literal, or negation of a boolean literal. Such expressions may be
  the result of automated refactorings
  not completely followed through to completion, and in any case are unlikely to be what the developer
  intended to do.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (someBool &amp;&amp; true) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (someBool) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ClashingGetters" defaultSeverity="WARNING" displayName="Clashing getters" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports boolean methods which can be accessed via the same property name.
&lt;p&gt;The result of accessing such property might be unexpected.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
      boolean isFoo() { true }
      boolean getFoo() { false }
  }

  // getFoo() will be called
  new X().foo
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyPointlessArithmetic" defaultSeverity="WARNING" displayName="Pointless arithmetic expression" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports pointless arithmetic expressions.
&lt;p&gt;
  Such expressions include adding or subtracting zero, multiplying by zero or one,
  division by one, and shift by zero. Such expressions may be the result of automated refactorings
  not completely followed through to completion, and in any case are unlikely to be what the developer
  intended to do.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a + 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ClashingTraitMethods" defaultSeverity="WARNING" displayName="Clashing trait methods" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes which implement two or more traits that contain methods with same signatures.
&lt;p&gt;The result of calling such methods might be unexpected.&lt;/p&gt;
&lt;p&gt;The quick-fix adds an explicit overriding method.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  trait T1 {
      def foo() {}
  }

  trait T2 {
      def foo() {}
  }

  class X implements T1, T2 {}

  // T2.foo() will be called
  new X().foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X implements T1, T2 {
      @Override
      Object foo() {
          return T2.super.foo()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NewInstanceOfSingleton" defaultSeverity="WARNING" displayName="New instance of class annotated with @groovy.lang.Singleton" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports new instance creation of classes annotated with &lt;code&gt;@groovy.lang.Singleton&lt;/code&gt;.
  Such constructions can lead to runtime exception &lt;b&gt;Can't instantiate singleton&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton
  class Foo{
  }
  
  Foo foo = &lt;b&gt;new Foo()&lt;/b&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton
  class Foo{
  }
  
  Foo foo = &lt;b&gt;Foo.instance&lt;/b&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyOctalInteger" defaultSeverity="WARNING" displayName="Octal integer" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports octal integer literals.
&lt;p&gt;
  Some coding standards prohibit the
  use of octal literals, as they may be easily confused with decimal literals.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyGStringKey" defaultSeverity="WARNING" displayName="GString map key" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports statements which use a &lt;code&gt;groovy.lang.GString&lt;/code&gt; object as a key to map.
In general &lt;code&gt;GString&lt;/code&gt; objects are mutable and probably should not be used as keys.
Also, a &lt;code&gt;GString&lt;/code&gt; entry cannot be accessed with a &lt;code&gt;java.lang.String&lt;/code&gt; object with same value.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = [:]
def key = 'foo'
map &amp;lt&amp;lt ["${key}": 'bar']
assert map[key] == null // confusing 'true' result of comparison
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="GroovyNegatedConditional" defaultSeverity="WARNING" displayName="Negated conditional expression" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports conditional expressions whose conditions are negated.
Flipping the order of the conditional expression branches will usually increase the clarity of such
statements.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
~condition ? "1" : "2"
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrReassignedInClosureLocalVar" defaultSeverity="WARNING" displayName="Local variable is reassigned in closure or anonymous class" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local variables assigned to expression with different type inside of closure or anonymous class.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int sum = 0
  [1, 2, 3].each { sum += 'as' }
  println(sum)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a result, the &lt;code&gt;integer&lt;/code&gt; variable &lt;b&gt;sum&lt;/b&gt; is reassigned to a &lt;code&gt;String&lt;/code&gt; expression.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Test frameworks" path="Java"><inspection shortName="SimplifiableAssertion" defaultSeverity="WARNING" displayName="Simplifiable assertion" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any &lt;code&gt;assert&lt;/code&gt; calls that can be replaced with simpler and equivalent calls.
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;Example&lt;/th&gt;&lt;th&gt;&amp;rarr;&lt;/th&gt;&lt;th&gt;Replacement&lt;/th&gt;&lt;/tr&gt;

  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertEquals(&lt;b&gt;true&lt;/b&gt;, x());&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(x());&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(y() != null);&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;assertNotNull(y());&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(z == z());&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;assertSame(z, z());&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(a.equals(a()));&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;assertEquals(a, a());&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;code&gt;assertTrue(&lt;b&gt;false&lt;/b&gt;);&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;code&gt;fail();&lt;/code&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MisorderedAssertEqualsArguments" defaultSeverity="WARNING" displayName="Misordered 'assertEquals()' arguments" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;assertEquals()&lt;/code&gt; that have the expected argument and the actual argument in the wrong order.
&lt;p&gt;
  For JUnit 3, 4, and 5 the correct order is &lt;code&gt;(expected, actual)&lt;/code&gt;.
  For TestNG the correct order is &lt;code&gt;(actual, expected)&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  Such calls will behave fine for assertions that pass, but may give confusing error reports on failure.
  Use the quick-fix to flip the order of the arguments.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example (JUnit):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertEquals(actual, expected)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertEquals(expected, actual)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantAssertArgument" defaultSeverity="WARNING" displayName="Constant assert argument" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports constant arguments in &lt;code&gt;assertTrue()&lt;/code&gt;, &lt;code&gt;assertFalse()&lt;/code&gt;,
&lt;code&gt;assertNull()&lt;/code&gt;, and &lt;code&gt;assertNotNull()&lt;/code&gt; calls.
&lt;p&gt;
  Calls to these methods with
  constant arguments will either always succeed or always fail.
  Such statements can easily be left over after refactoring and are probably not intended.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertNotNull("foo");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertBetweenInconvertibleTypes" defaultSeverity="WARNING" displayName="'assertEquals()' between objects of inconvertible types" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to assertion methods where the "expected" and "actual" arguments are of incompatible types.
&lt;p&gt;Such calls often indicate that there is a bug in the test.
  This inspection checks the relevant JUnit, TestNG, and AssertJ methods.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertEquals("1", 1);
  assertNotSame(new int[0], 0);

  // weak warning, may just test the equals() contract
  assertThat(foo).as("user type").isNotEqualTo(bar);
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MaskedAssertion" defaultSeverity="WARNING" displayName="Assertion is suppressed by 'catch'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;assert&lt;/code&gt; statements and test framework assertions that are suppressed by a surrounding catch block.
Such assertions will never fail, as the thrown &lt;code&gt;AssertionError&lt;/code&gt; will be caught and silently ignored.
&lt;p&gt;&lt;b&gt;Example 1:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void javaAssertion() {
    try {
      ...
      assert 1 == 2;
    } catch (AssertionError e) {
      // the assertion is silently ignored
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;Example 2:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  void testWithAssertJ() {
    try {
      ...
      assertThat(1).as("test").isEqualTo(2);
    } catch (AssertionError e) {
      // the assertion is silently ignored
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;Example 3:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  void testWithJunit() {
    try {
      ...
      assertEquals(1, 2);
    } catch (AssertionError e) {
      // the assertion is silently ignored
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2020.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertWithoutMessage" defaultSeverity="WARNING" displayName="Message missing on assertion" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;assertXXX()&lt;/code&gt; or &lt;code&gt;fail()&lt;/code&gt; without an error message string argument.
An error message on assertion failure may help clarify the test case's intent.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assertTrue(checkValid());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;assertTrue(checkValid(), "|");&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  The message argument is added before or after the existing arguments according to the assertions framework that you use.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Style issues" path="Kotlin"><inspection shortName="AddOperatorModifier" defaultSeverity="INFORMATION" displayName="Function should have 'operator' modifier" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a function that matches one of the operator conventions but lacks the &lt;code&gt;operator&lt;/code&gt; keyword.
&lt;p&gt;By adding the &lt;code&gt;operator&lt;/code&gt; modifier, you might allow function consumers to write idiomatic Kotlin code.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Complex(val real: Double, val imaginary: Double) {
      fun plus(other: Complex) =
          Complex(real + other.real, imaginary + other.imaginary)
  }

  fun usage(a: Complex, b: Complex) {
      a.plus(b)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix adds the &lt;code&gt;operator&lt;/code&gt; modifier keyword:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Complex(val real: Double, val imaginary: Double) {
      operator fun plus(other: Complex) =
          Complex(real + other.real, imaginary + other.imaginary)
  }

  fun usage(a: Complex, b: Complex) {
      a + b
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceSubstringWithSubstringBefore" defaultSeverity="INFORMATION" displayName="'substring' call should be replaced with 'substringBefore'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls like &lt;code&gt;s.substring(0, s.indexOf(x))&lt;/code&gt; that can be replaced with &lt;code&gt;s.substringBefore(x)&lt;/code&gt;.
&lt;p&gt;Using &lt;code&gt;substringBefore()&lt;/code&gt; makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the &lt;code&gt;substring&lt;/code&gt; call with &lt;code&gt;substringBefore&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substring(0, s.indexOf('x'))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substringBefore('x')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FunctionWithLambdaExpressionBody" defaultSeverity="WEAK WARNING" displayName="Function with '= { ... }' and inferred return type" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports functions with &lt;code&gt;= { ... }&lt;/code&gt; and inferred return type.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun sum(a: Int, b: Int) = { a + b } // The return type of this function is '() -&gt; Int'.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix removes braces:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun sum(a: Int, b: Int) = a + b
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnclearPrecedenceOfBinaryExpression" defaultSeverity="WARNING" displayName="Multiple operators with different precedence" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports binary expressions that consist of different operators without parentheses.
&lt;p&gt;Such expressions can be less readable due to different &lt;a href="https://kotlinlang.org/docs/reference/grammar.html#expressions"&gt;precedence rules&lt;/a&gt; of operators.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;
  fun foo(b: Boolean?, i: Int?) {
      val x = b ?: i == null // evaluated as `(b ?: i) == null`
      val y = i ?: 0 + 1 // evaluated as `i ?: (0 + 1)`
  }
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanLiteralArgument" defaultSeverity="INFO" displayName="Boolean literal argument without parameter name" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports call arguments with &lt;code&gt;Boolean&lt;/code&gt; type without explicit parameter names specified.
&lt;p&gt;
    When multiple boolean literals are passed sequentially, it's easy to forget parameter ordering that could lead to mistakes.
    Explicit parameter names allow for easier code reading and understanding.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}

  fun usage() {
      check(true, false, true) // What does this mean?
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix adds missing parameter names:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}

  fun usage() {
      check(checkName = true, checkAddress = false, checkPhone = true)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NestedLambdaShadowedImplicitParameter" defaultSeverity="WEAK WARNING" displayName="Nested lambda has shadowed implicit parameter" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports nested lambdas with shadowed implicit parameters.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(listOfLists: List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;) {
  listOfLists.forEach {
    it.forEach {
      println(it)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(listOfLists: List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;) {
  listOfLists.forEach {
    it.forEach { it1 -&amp;gt;
      println(it1)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LiftReturnOrAssignment" defaultSeverity="INFO" displayName="Return or assignment can be lifted out" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, and &lt;code&gt;try&lt;/code&gt; statements that can be converted to expressions
by lifting the &lt;code&gt;return&lt;/code&gt; statement or an assignment out.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(arg: Int): String {
      when (arg) {
          0 -&gt; return "Zero"
          1 -&gt; return "One"
          else -&gt; return "Multiple"
      }
  }
&lt;/code&gt;&lt;/pre&gt;
After the quick-fix is applied:
&lt;pre&gt;&lt;code&gt;
  fun foo(arg: Int): String {
      return when (arg) {
          0 -&gt; "Zero"
          1 -&gt; "One"
          else -&gt; "Multiple"
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JoinDeclarationAndAssignment" defaultSeverity="WEAK WARNING" displayName="Join declaration and assignment" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports property declarations that can be joined with the following assignment.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x: String
  x = System.getProperty("")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix joins the declaration with the assignment:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x = System.getProperty("")
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NullableBooleanElvis" defaultSeverity="INFO" displayName="Equality check can be used instead of elvis for nullable boolean check" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports cases when an equality check should be used instead of the elvis operator.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun check(a: Boolean? == null) {
    if (a ?: false) throw IllegalStateException()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun check(a: Boolean? == null) {
    if (a == true) throw IllegalStateException()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseWithIndex" defaultSeverity="INFO" displayName="Manually incremented index variable can be replaced with use of 'withIndex()'" enabled="true" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;for&lt;/code&gt; loops with a manually incremented index variable.
&lt;p&gt;&lt;code&gt;for&lt;/code&gt; loops with a manually incremented index variable can be simplified with the &lt;code&gt;withIndex()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Use withIndex() instead of manual index increment&lt;/b&gt; quick-fix can be used to amend the code automatically.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(list: List&amp;lt;String&amp;gt;): Int? {
      var index = 0
      for (s in list) { &amp;lt;== can be simplified
          val x = s.length * index
          index++
          if (x &gt; 0) return x
      }
      return null
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(list: List&amp;lt;String&amp;gt;): Int? {
      for ((index, s) in list.withIndex()) {
          val x = s.length * index
          if (x &gt; 0) return x
      }
      return null
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceRangeToWithUntil" defaultSeverity="WEAK WARNING" displayName="'rangeTo' or the '..' call should be replaced with 'until'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;rangeTo&lt;/code&gt; or the &lt;code&gt;..&lt;/code&gt; operator instead of calls to &lt;code&gt;until&lt;/code&gt;.
&lt;p&gt;Using corresponding functions makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces &lt;code&gt;rangeTo&lt;/code&gt; or the &lt;code&gt;..&lt;/code&gt; call with &lt;code&gt;until&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int) {
      for (i in 0..a - 1) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int) {
      for (i in 0 until a) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifiableCallChain" defaultSeverity="WEAK WARNING" displayName="Call chain on collection type can be simplified" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports two-call chains replaceable by a single call.
&lt;p&gt;It can help you to avoid redundant code execution.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the call chain with a single call.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      listOf(1, 2, 3).filter { it &amp;gt; 1 }.count()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      listOf(1, 2, 3).count { it &amp;gt; 1 }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ObjectLiteralToLambda" defaultSeverity="INFO" displayName="Object literal can be converted to lambda" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports anonymous object literals implementing a Java interface with a single abstract method that can be converted into a call with a lambda expression.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class SomeService {
  val threadPool = Executors.newCachedThreadPool()
    
  fun foo() {
    threadPool.submit(object : Runnable {
      override fun run() {
        println("hello")
      }
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
    threadPool.submit { println("hello") }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TrailingComma" defaultSeverity="INFO" displayName="Trailing comma recommendations" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports trailing commas that are not follow the recommended &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#trailing-commas"&gt;style guide&lt;/a&gt;.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedMainParameter" defaultSeverity="WEAK WARNING" displayName="Main parameter is not necessary" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;main&lt;/code&gt; function with an unused single parameter.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantAsSequence" defaultSeverity="WEAK WARNING" displayName="Redundant 'asSequence' call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports redundant &lt;code&gt;asSequence()&lt;/code&gt; call that can never have a positive performance effect.&lt;/p&gt;
&lt;p&gt;
    &lt;code&gt;asSequence()&lt;/code&gt; speeds up collection processing that includes multiple operations because it performs operations lazily
    and doesn't create intermediate collections.
&lt;/p&gt;
&lt;p&gt;
    However, if a terminal operation (such as &lt;code&gt;toList()&lt;/code&gt;) is used right after &lt;code&gt;asSequence()&lt;/code&gt;, this doesn't give
    you any positive performance effect.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;String&amp;gt;) {
      list.&lt;b&gt;asSequence()&lt;/b&gt;.last()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;String&amp;gt;) {
      list.last()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceSizeZeroCheckWithIsEmpty" defaultSeverity="WEAK WARNING" displayName="Size zero check can be replaced with 'isEmpty()'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;size == 0&lt;/code&gt; checks on &lt;code&gt;Collections/Array/String&lt;/code&gt; that should be replaced with &lt;code&gt;isEmpty()&lt;/code&gt;.
&lt;p&gt;Using &lt;code&gt;isEmpty()&lt;/code&gt; makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the size check with &lt;code&gt;isEmpty()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val arrayOf = arrayOf(1, 2, 3)
      arrayOf.size == 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val arrayOf = arrayOf(1, 2, 3)
      arrayOf.isEmpty()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifiableCall" defaultSeverity="WEAK WARNING" displayName="Library function call could be simplified" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports library function calls which could be replaced by simplified one.
&lt;p&gt;Using corresponding functions makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the function calls with another one.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Any&amp;gt;) {
      list.filter { it is String }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Any&amp;gt;) {
      list.filterIsInstance&amp;lt;String&amp;gt;()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyAssertNotNull" defaultSeverity="INFORMATION" displayName="'assert' call can be replaced with '!!' or '?:'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;assert&lt;/code&gt; calls that check a not null value of the declared variable.
&lt;p&gt;Using &lt;code&gt;!!&lt;/code&gt; or &lt;code&gt;?:&lt;/code&gt; makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces &lt;code&gt;assert&lt;/code&gt; with &lt;code&gt;!!&lt;/code&gt; or &lt;code&gt;?:&lt;/code&gt; operator in the variable initializer.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(p: Array&amp;lt;String?&amp;gt;) {
      val v = p[0]
      assert(v != null, { &amp;quot;Should be not null&amp;quot; })
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(p: Array&amp;lt;String?&amp;gt;) {
      val v = p[0] ?: error(&amp;quot;Should be not null&amp;quot;)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DirectUseOfResultType" defaultSeverity="WEAK WARNING" displayName="Function returning Result directly" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports functions that use &lt;code&gt;Result&lt;/code&gt; as a return type.
&lt;p&gt;
&lt;code&gt;Result&lt;/code&gt; should never be used as a return type.
Throw an exception, use a nullable type, or use a domain-specific result class to indicate failure.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() = Result.success(true)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceNotNullAssertionWithElvisReturn" defaultSeverity="WEAK WARNING" displayName="Not-null assertion can be replaced with 'return'" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports not-null assertion (&lt;code&gt;!!&lt;/code&gt;) calls that can be replaced with the elvis operator and return (&lt;code&gt;?: return&lt;/code&gt;).
&lt;p&gt;A not-null assertion can lead to NPE (NullPointerException) that is not expected. Avoiding the use of &lt;code&gt;!!&lt;/code&gt; is good practice.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the not-null assertion with &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;return null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(number: Int?) {
      val x = number!!
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(number: Int?) {
      val x = number ?: return
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertSecondaryConstructorToPrimary" defaultSeverity="WARNING" displayName="Convert to primary constructor" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a secondary constructor that can be replaced with a more concise primary constructor.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User {
      val name: String

      constructor(name: String) {
          this.name = name
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix converts code automatically:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User(val name: String) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DeferredIsResult" defaultSeverity="WEAK WARNING" displayName="Function returning Deferred directly" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports functions with the &lt;code&gt;kotlinx.coroutines.Deferred&lt;/code&gt; return type.
&lt;p&gt;
    Functions that use &lt;code&gt;Deferred&lt;/code&gt; as return type should have a name with the &lt;code&gt;Async&lt;/code&gt; suffix.
    Otherwise, it's recommended to mark a function as &lt;code&gt;suspend&lt;/code&gt; and unwrap &lt;code&gt;Deferred&lt;/code&gt; inside it.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun calcEverything(): Deferred&amp;lt;Int&amp;gt; {
      return CompletableDeferred(42)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix that adds the &lt;code&gt;Async&lt;/code&gt; suffix applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun calcEverythingAsync(): Deferred&amp;lt;Int&amp;gt; {
      return CompletableDeferred(42)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix that converts the function into a &lt;code&gt;suspend&lt;/code&gt; one applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  suspend fun calcEverything(): Int {
      return CompletableDeferred(42).await()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceManualRangeWithIndicesCalls" defaultSeverity="INFO" displayName="Range can be converted to indices or iteration" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;until&lt;/code&gt; and &lt;code&gt;rangeTo&lt;/code&gt; operators that can be replaced with &lt;code&gt;Collection.indices&lt;/code&gt; or iteration over collection inside &lt;code&gt;for&lt;/code&gt; loop.
&lt;p&gt;Using syntactic sugar makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the manual range with the corresponding construction.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main(args: Array&amp;lt;String&amp;gt;) {
      for (index in 0..args.size - 1) {
          println(args[index])
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main(args: Array&amp;lt;String&amp;gt;) {
      for (element in args) {
          println(element)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceStringFormatWithLiteral" defaultSeverity="INFORMATION" displayName="'String.format' call can be replaced with string templates" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;String.format&lt;/code&gt; calls that can be replaced with string templates.
&lt;p&gt;Using string templates makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the call with a string template.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val id = &amp;quot;abc&amp;quot;
      val date = &amp;quot;123&amp;quot;
      val s = String.format(&amp;quot;%s_%s_%s&amp;quot;, id, date, id)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val id = &amp;quot;abc&amp;quot;
      val date = &amp;quot;123&amp;quot;
      val s = &amp;quot;${id}_${date}_$id&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantObjectTypeCheck" defaultSeverity="INFORMATION" displayName="Non-idiomatic 'is' type check for an object" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports non-idiomatic &lt;code&gt;is&lt;/code&gt; type checks for an object.&lt;/p&gt;
&lt;p&gt;It's recommended to replace such checks with reference comparison.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object Foo

  fun foo(arg: Any) = when {
      arg &lt;b&gt;is&lt;/b&gt; Foo -&gt; ...
      arg &lt;b&gt;!is&lt;/b&gt; Foo -&gt; ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object Foo

  fun foo(arg: Any) = when {
      arg &lt;b&gt;===&lt;/b&gt; Foo -&gt; ...
      arg &lt;b&gt;!==&lt;/b&gt; Foo -&gt; ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceGetOrSet" defaultSeverity="INFO" displayName="Explicit 'get' or 'set' call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports explicit calls to &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; functions which can be replaced by an indexing operator &lt;code&gt;[]&lt;/code&gt;.
&lt;p&gt;
    Kotlin allows custom implementations for the predefined set of operators on types.
    To overload an operator, you can mark the corresponding function with the &lt;code&gt;operator&lt;/code&gt; modifier:
    &lt;pre&gt;&lt;code&gt;
  operator fun get(index: Int) {}
  operator fun set(index: Int, value: Int) {}
    &lt;/code&gt;&lt;/pre&gt;

The functions above correspond to the indexing operator.

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class Test {
      operator fun get(i: Int): Int = 0
  }

  fun test() {
      Test().get(0) // replaceable 'get()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class Test {
      operator fun get(i: Int): Int = 0
  }

  fun test() {
      Test()[0]
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceIsEmptyWithIfEmpty" defaultSeverity="WEAK WARNING" displayName="'if' condition can be replaced with lambda call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;isEmpty&lt;/code&gt;, &lt;code&gt;isBlank&lt;/code&gt;, &lt;code&gt;isNotEmpty&lt;/code&gt;, or &lt;code&gt;isNotBlank&lt;/code&gt; calls in an &lt;code&gt;if&lt;/code&gt; statement to assign a default value.
&lt;p&gt;The quick-fix replaces the &lt;code&gt;if&lt;/code&gt; condition with &lt;code&gt;ifEmpty&lt;/code&gt; or &lt;code&gt;ifBlank&lt;/code&gt; calls.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;): List&amp;lt;Int&amp;gt; {
      return if (list.isEmpty()) {
          println()
          foo()
      } else {
          list
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;): List&amp;lt;Int&amp;gt; {
      return list.ifEmpty {
          println()
          foo()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the Kotlin language version of the project or module is 1.3 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceCollectionCountWithSize" defaultSeverity="WEAK WARNING" displayName="Collection count can be converted to size" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Collection&amp;lt;T&amp;gt;.count()&lt;/code&gt;.
&lt;p&gt;
    This function call can be replaced with &lt;code&gt;.size&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
    &lt;code&gt;.size&lt;/code&gt; form ensures that the operation is O(1) and won't allocate extra objects, whereas
    &lt;code&gt;count()&lt;/code&gt; could be confused with &lt;code&gt;Iterable&amp;lt;T&amp;gt;.count()&lt;/code&gt;, which is O(n) and allocating.
    &lt;br&gt;
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun foo() {
      var list = listOf(1,2,3)
      list.count() // replaceable 'count()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun foo() {
      var list = listOf(1,2,3)
      list.size
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceSizeCheckWithIsNotEmpty" defaultSeverity="WEAK WARNING" displayName="Size check can be replaced with 'isNotEmpty()'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports size checks of &lt;code&gt;Collections/Array/String&lt;/code&gt; that should be replaced with &lt;code&gt;isNotEmpty()&lt;/code&gt;.
&lt;p&gt;Using &lt;code&gt;isNotEmpty()&lt;/code&gt; makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the size check with &lt;code&gt;isNotEmpty()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val arrayOf = arrayOf(1, 2, 3)
      arrayOf.size &amp;gt; 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val arrayOf = arrayOf(1, 2, 3)
      arrayOf.isNotEmpty()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfThenToSafeAccess" defaultSeverity="INFO" displayName="If-Then foldable to '?.'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if-then&lt;/code&gt; expressions that can be folded into safe-access (&lt;code&gt;?.&lt;/code&gt;) expressions.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun bar(x: String) = ""

  fun foo(a: String?) {
     if (a != null) bar(a) else null
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix converts the &lt;code&gt;if-then&lt;/code&gt; expression into a safe-access (&lt;code&gt;?.&lt;/code&gt;) expression:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun bar(x: String) = ""

  fun foo(a: String?) {
     a?.let { bar(it) }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnlabeledReturnInsideLambda" defaultSeverity="INFORMATION" displayName="Unlabeled return inside lambda" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unlabeled &lt;code&gt;return&lt;/code&gt; expressions inside inline lambda.
&lt;p&gt;Such expressions can be confusing because it might be unclear which scope belongs to &lt;code&gt;return&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Change to return@&lt;/b&gt; quick-fix can be used to amend the code automatically.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;) {
      list.forEach {
          // This return expression returns from the function test
          // One can change it to return@forEach to change the scope
          if (it == 10) return
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;) {
      list.forEach {
          if (it == 10) return@test
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConvertLambdaToReference" defaultSeverity="INFORMATION" displayName="Can be replaced with function reference" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports function literal expressions that can be replaced with function references.
&lt;p&gt;Replacing lambdas with function references often makes code look more concise and understandable.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Int.isEven() = this % 2 == 0

  fun example() {
      val numbers = listOf(1, 2, 4, 7, 9, 10)
      val evenNumbers = numbers.filter { it.isEven() }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Int.isEven() = this % 2 == 0

  fun example() {
      val numbers = listOf(1, 2, 4, 7, 9, 10)
      val evenNumbers = numbers.filter(Int::isEven)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MoveLambdaOutsideParentheses" defaultSeverity="WEAK WARNING" displayName="Lambda argument inside parentheses" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports lambda expressions in parentheses which can be moved outside.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun square(a: Int, b: (Int) -&amp;gt; Int) {
  b(a * a)
}

fun foo() {
  square(2, { it })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo() {
  square(2){ it }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CopyWithoutNamedArguments" defaultSeverity="WEAK WARNING" displayName="'copy' method of data class is called without named arguments" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to a data class' &lt;code&gt;copy()&lt;/code&gt; method without named arguments.
&lt;p&gt;
    As all arguments of the &lt;code&gt;copy()&lt;/code&gt; function are optional, it might be hard to understand what properties are modified.
    Providing parameter names explicitly makes code easy to understand without navigating to the &lt;code&gt;data class&lt;/code&gt; declaration.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class User(val name: String, val age: Int)

  fun copyUser(user: User): User {
      return user.copy("John")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix provides parameter names to all &lt;code&gt;copy()&lt;/code&gt; arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class User(val name: String, val age: Int)

  fun copyUser(user: User): User {
      return user.copy(name = "John")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceSubstringWithTake" defaultSeverity="INFORMATION" displayName="'substring' call should be replaced with 'take' call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls like &lt;code&gt;s.substring(0, x)&lt;/code&gt; that can be replaced with &lt;code&gt;s.take(x)&lt;/code&gt;.
&lt;p&gt;Using &lt;code&gt;take()&lt;/code&gt; makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the &lt;code&gt;substring&lt;/code&gt; call with &lt;code&gt;take()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substring(0, 10)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.take(10)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProtectedInFinal" defaultSeverity="WEAK WARNING" displayName="'protected' visibility is effectively 'private' in a final class" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;protected&lt;/code&gt; visibility used inside of a &lt;code&gt;final&lt;/code&gt; class.
In such cases &lt;code&gt;protected&lt;/code&gt; members are accessible only in the class itself, so they are effectively &lt;code&gt;private&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class FinalClass {
      &lt;b&gt;protected&lt;/b&gt; fun foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class FinalClass {
      &lt;b&gt;private&lt;/b&gt; fun foo() {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IntroduceWhenSubject" defaultSeverity="WEAK WARNING" displayName="'when' that can be simplified by introducing an argument" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a &lt;code&gt;when&lt;/code&gt; expression that can be simplified by introducing a subject argument.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(obj: Any): String {
      return when {
          obj is String -&gt; "string"
          obj is Int -&gt; "int"
          else -&gt; "unknown"
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix introduces a subject argument:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(obj: Any): String {
      return when (obj) {
          is String -&gt; "string"
          is Int -&gt; "int"
          else -&gt; "unknown"
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantAsync" defaultSeverity="WEAK WARNING" displayName="Redundant 'async' call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
    Reports &lt;code&gt;async&lt;/code&gt; calls that are immediately followed by &lt;code&gt;await&lt;/code&gt;.
    Such calls can be replaced with blocking calls.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  suspend fun test(ctx: CoroutineContext, scope: CoroutineScope) {
      scope.async(ctx) { doSomeJob() }.await()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  suspend fun test(ctx: CoroutineContext, scope: CoroutineScope) {
      withContext(scope.coroutineContext + ctx) { doSomeJob() }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="AddVarianceModifier" defaultSeverity="INFORMATION" displayName="Type parameter can have 'in' or 'out' variance" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports type parameters that can have &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; variance.
&lt;p&gt;Using &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; variance provides more precise type inference in Kotlin and clearer code semantics.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Box&amp;lt;T&amp;gt;(val obj: T)

  fun consumeString(box: Box&amp;lt;String&amp;gt;) {}
  fun consumeCharSequence(box: Box&amp;lt;CharSequence&amp;gt;) {}

  fun usage(box: Box&amp;lt;String&amp;gt;) {
      consumeString(box)
      consumeCharSequence(box) // Compilation error
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix adds the matching variance modifier:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Box&amp;lt;out T&amp;gt;(val obj: T)

  fun consumeString(box: Box&amp;lt;String&amp;gt;) {}
  fun consumeCharSequence(box: Box&amp;lt;CharSequence&amp;gt;) {}

  fun usage(box: Box&amp;lt;String&amp;gt;) ++{
      consumeString(box)
      consumeCharSequence(box) // OK
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceRangeStartEndInclusiveWithFirstLast" defaultSeverity="WEAK WARNING" displayName="Boxed properties should be replaced with unboxed" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;b&gt;boxed&lt;/b&gt; &lt;code&gt;Range.start&lt;/code&gt; and &lt;code&gt;Range.endInclusive&lt;/code&gt; properties.
&lt;p&gt;These properties can be replaced with &lt;b&gt;unboxed&lt;/b&gt; &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; properties to avoid redundant calls.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;endInclusive&lt;/code&gt; properties with the corresponding &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(range: CharRange) {
      val lastElement = range.endInclusive
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(range: CharRange) {
      val lastElement = range.last
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceGuardClauseWithFunctionCall" defaultSeverity="INFORMATION" displayName="Guard clause can be replaced with Kotlin's function call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports guard clauses that can be replaced with a function call.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test(foo: Int?) {
      if (foo == null) throw IllegalArgumentException("foo") // replaceable clause
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test(foo: Int?) {
      checkNotNull(foo)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveEmptyParenthesesFromAnnotationEntry" defaultSeverity="WEAK WARNING" displayName="Remove unnecessary parentheses" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant empty parentheses in annotation entries.
&lt;p&gt;Use the 'Remove unnecessary parentheses' quick-fix to clean up the code.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  annotation class MyAnnotationA
  annotation class MyAnnotationB(val x: Int)
  annotation class MyAnnotationC(val x: Int = 10) // default value is present

  @MyAnnotationA() // &amp;lt;== parentheses are redundant
  fun testA() {
  }

  @MyAnnotationB() // &amp;lt;== missing argument, parentheses are required
  fun testB() {
  }

  @MyAnnotationC() // &amp;lt;== parentheses are redundant
  fun testC() {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertCallChainIntoSequence" defaultSeverity="INFO" displayName="Call chain on collection could be converted into 'Sequence' to improve performance" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports call chain on a &lt;code&gt;Collection&lt;/code&gt; that should be converted into &lt;b&gt;Sequence&lt;/b&gt;.
&lt;p&gt;Each &lt;code&gt;Collection&lt;/code&gt; transforming function (such as &lt;code&gt;map()&lt;/code&gt; or &lt;code&gt;filter()&lt;/code&gt;) creates a new
    &lt;code&gt;Collection&lt;/code&gt; (typically &lt;code&gt;List&lt;/code&gt; or &lt;code&gt;Set&lt;/code&gt;) under the hood.
    In case of multiple consequent calls, and a huge number of items in &lt;code&gt;Collection&lt;/code&gt;, memory traffic might be significant.
    In such a case, using &lt;code&gt;Sequence&lt;/code&gt; is preferred.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Entity(val key: String, val value: String)

  fun getValues(lines: List&amp;lt;String&amp;gt;) = lines
      .filter { it.isNotEmpty() }
      .map { it.split(',', limit = 2) }
      .filter { it.size == 2 }
      .map { Entity(it[0], it[1]) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix wraps call chain into &lt;code&gt;asSequence()&lt;/code&gt; and &lt;code&gt;toList()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Entity(val key: String, val value: String)

  fun getValues(lines: List&amp;lt;String&amp;gt;) = lines
      .asSequence()
      .filter { it.isNotEmpty() }
      .map { it.split(',', limit = 2) }
      .filter { it.size == 2 }
      .map { Entity(it[0], it[1]) }
      .toList()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CascadeIf" defaultSeverity="INFO" displayName="Cascade if can be replaced with when" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; statements with three or more branches that can be replaced with the &lt;code&gt;when&lt;/code&gt; expression.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun checkIdentifier(id: String) {
      fun Char.isIdentifierStart() = this in 'A'..'z'
      fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'

      if (id.isEmpty()) {
          print("Identifier is empty")
      } else if (!id.first().isIdentifierStart()) {
          print("Identifier should start with a letter")
      } else if (!id.subSequence(1, id.length).all(Char::isIdentifierPart)) {
          print("Identifier should contain only letters and numbers")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix converts the &lt;code&gt;if&lt;/code&gt; expression to &lt;code&gt;when&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun checkIdentifier(id: String) {
      fun Char.isIdentifierStart() = this in 'A'..'z'
      fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'

      when {
          id.isEmpty() -&gt; {
              print("Identifier is empty")
          }
          !id.first().isIdentifierStart() -&gt; {
              print("Identifier should start with a letter")
          }
          !id.subSequence(1, id.length).all(Char::isIdentifierPart) -&gt; {
              print("Identifier should contain only letters and numbers")
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceCallWithBinaryOperator" defaultSeverity="WEAK WARNING" displayName="Can be replaced with binary operator" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports function calls that can be replaced with binary operators, in particular comparison-related ones.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test(): Boolean {
      return 2.compareTo(1) &gt; 0 // replaceable 'compareTo()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test(): Boolean {
      return 2 &gt; 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceAssociateFunction" defaultSeverity="WEAK WARNING" displayName="'associate' can be replaced with 'associateBy' or 'associateWith'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;associate()&lt;/code&gt; and &lt;code&gt;associateTo()&lt;/code&gt; that can be replaced with &lt;code&gt;associateBy()&lt;/code&gt; or &lt;code&gt;associateWith()&lt;/code&gt;.
&lt;p&gt;
    Both functions accept a transformer function applied to elements of a given sequence or collection (as a receiver).
    The pairs are then used to build the resulting &lt;code&gt;Map&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
    Given the transformer refers to &lt;code&gt;it&lt;/code&gt;, the &lt;code&gt;associate[To]()&lt;/code&gt; call can be replaced with more performant &lt;code&gt;associateBy()&lt;/code&gt;
    or &lt;code&gt;associateWith()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun getKey(i: Int) = 1L
  fun getValue(i: Int) = 1L

  fun test() {
      arrayOf(1).associate { getKey(it) to it }  // replaceable 'associate()'
      listOf(1).associate { it to getValue(it) } // replaceable 'associate()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun getKey(i: Int) = 1L
  fun getValue(i: Int) = 1L

  fun test() {
      arrayOf(1).associateBy { getKey(it) }
      listOf(1).associateWith { getValue(it) }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyBooleanWithConstants" defaultSeverity="WEAK WARNING" displayName="Boolean expression can be simplified" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports boolean expression parts that can be reduced to constants.
&lt;p&gt;The quick-fix simplifies the condition.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun use(arg: Boolean) {
      if (false == arg) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun use(arg: Boolean) {
      if (!arg) {

      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MapGetWithNotNullAssertionOperator" defaultSeverity="INFORMATION" displayName="'map.get()' with not-null assertion operator (!!)" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;map.get()!!&lt;/code&gt; that can be replaced with &lt;code&gt;map.getValue()&lt;/code&gt;, &lt;code&gt;map.getOrElse()&lt;/code&gt;, and so on.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun test(map: Map&amp;lt;Int, String&amp;gt;): String = map.get(0)!!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun test(map: Map&amp;lt;Int, String&amp;gt;): String = map.getValue(0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceWithOperatorAssignment" defaultSeverity="WEAK WARNING" displayName="Assignment can be replaced with operator assignment" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports modifications of variables with a simple assignment (such as &lt;code&gt;y = y + x&lt;/code&gt;) that can be replaced with an operator assignment.
&lt;p&gt;The quick-fix replaces the assignment with an assignment operator.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val list = mutableListOf(1, 2, 3)
      list = list + 4
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      val list = mutableListOf(1, 2, 3)
      list += 4
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MemberVisibilityCanBePrivate" defaultSeverity="INFO" displayName="Class member can have 'private' visibility" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports declarations that can be made &lt;code&gt;private&lt;/code&gt; to follow the encapsulation principle.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Service(val url: String) {
    fun connect(): URLConnection = URL(url).openConnection()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied (considering there are no usages of &lt;code&gt;url&lt;/code&gt; outside of &lt;code&gt;Service&lt;/code&gt; class):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Service(private val url: String) {
    fun connect(): URLConnection = URL(url).openConnection()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CanBeVal" defaultSeverity="WARNING" displayName="Local 'var' is never modified and can be declared as 'val'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local variables declared with the &lt;code&gt;var&lt;/code&gt; keyword that are never modified.
&lt;p&gt;Kotlin encourages to declare practically immutable variables using the &lt;code&gt;val&lt;/code&gt; keyword, ensuring that their value will never change.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      var primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)
      var fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)
      print("Same numbers: " + primeNumbers.intersect(fibonacciNumbers))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix replaces the &lt;code&gt;var&lt;/code&gt; keyword with &lt;code&gt;val&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      val primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)
      val fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)
      print("Same numbers: " + primeNumbers.intersect(fibonacciNumbers))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceMapIndexedWithListGenerator" defaultSeverity="WEAK WARNING" displayName="Replace 'mapIndexed' with List generator" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a &lt;code&gt;mapIndexed&lt;/code&gt; call that can be replaced by &lt;code&gt;List&lt;/code&gt; generator.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val a = listOf(1, 2, 3).mapIndexed { i, _ -&gt;
      i + 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val a = List(listOf(1, 2, 3).size) { i -&gt;
          i + 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifyNegatedBinaryExpression" defaultSeverity="WEAK WARNING" displayName="Negated boolean expression can be simplified" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports negated binary expressions that can be simplified.
&lt;p&gt;The quick-fix simplifies the binary expression.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(n: Int) {
      !(0 == 1)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(n: Int) {
      0 != 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceNegatedIsEmptyWithIsNotEmpty" defaultSeverity="WEAK WARNING" displayName="Negated call can be simplified" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports negation &lt;code&gt;isEmpty()&lt;/code&gt; and &lt;code&gt;isNotEmpty()&lt;/code&gt; for collections and &lt;code&gt;String&lt;/code&gt;, or &lt;code&gt;isBlank()&lt;/code&gt; and &lt;code&gt;isNotBlank()&lt;/code&gt; for &lt;code&gt;String&lt;/code&gt;.
&lt;p&gt;Using corresponding functions makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the negation call with the corresponding call from the Standard Library.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val list = listOf(1,2,3)
      if (!list.isEmpty()) {
          // do smth
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val list = listOf(1,2,3)
      if (list.isNotEmpty()) {
          // do smth
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceToWithInfixForm" defaultSeverity="WEAK WARNING" displayName="'to' call should be replaced with infix form" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;to&lt;/code&gt; function calls that can be replaced with the infix form.
&lt;p&gt;Using the infix form makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces &lt;code&gt;to&lt;/code&gt; with the infix form.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int, b: Int) {
      val pair = a.to(b)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(a: Int, b: Int) {
      val pair = a to b
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceSubstringWithSubstringAfter" defaultSeverity="INFORMATION" displayName="'substring' call should be replaced with 'substringAfter'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls like &lt;code&gt;s.substring(s.indexOf(x))&lt;/code&gt; that can be replaced with &lt;code&gt;s.substringAfter(x)&lt;/code&gt;.
&lt;p&gt;Using &lt;code&gt;s.substringAfter(x)&lt;/code&gt; makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the &lt;code&gt;substring&lt;/code&gt; call with &lt;code&gt;substringAfter&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substring(s.indexOf('x'))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substringAfter('x')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousAsDynamic" defaultSeverity="WEAK WARNING" displayName="Suspicious 'asDynamic' member invocation" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;asDynamic&lt;/code&gt; function on a receiver of dynamic type.
&lt;p&gt;&lt;code&gt;asDynamic&lt;/code&gt; function has no effect for expressions of dynamic type.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;asDynamic&lt;/code&gt; function on a receiver of dynamic type can lead to runtime problems because &lt;code&gt;asDynamic&lt;/code&gt;
    will be executed in JavaScript environment, and such function may not be present at runtime.
    The intended way is to use this function on usual Kotlin type.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Remove "asDynamic" invocation&lt;/b&gt; quick-fix can be used to amend the code automatically.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun wrongUsage(d: Dynamic) {
     d.asDynamic().foo() // &amp;lt;== redundant, quick-fix simplifies the call expression to "d.foo()"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertReferenceToLambda" defaultSeverity="INFORMATION" displayName="Can be replaced with lambda" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a function reference expression that can be replaced with a function literal (lambda).
&lt;p&gt;
    Sometimes, passing a lambda looks more straightforward and more consistent with the rest of the code.
    Also, the fix might be handy if you need to replace a simple call with something more complex.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Int.isEven() = this % 2 == 0

  fun example() {
      val numbers = listOf(1, 2, 4, 7, 9, 10)
      val evenNumbers = numbers.filter(Int::isEven)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun Int.isEven() = this % 2 == 0

  fun example() {
      val numbers = listOf(1, 2, 4, 7, 9, 10)
      val evenNumbers = numbers.filter { it.isEven() }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaCollectionsStaticMethod" defaultSeverity="WEAK WARNING" displayName="Java Collections static method call can be replaced with Kotlin stdlib" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a Java &lt;code&gt;Collections&lt;/code&gt; static method call that can be replaced with Kotlin stdlib.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.Collections

  fun test() {
      val mutableList = mutableListOf(1, 2)
      Collections.fill(mutableList, 3)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix replaces Java &lt;code&gt;Collections&lt;/code&gt; static method call with the corresponding Kotlin stdlib method call:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.Collections

  fun test() {
      val mutableList = mutableListOf(1, 2)
      mutableList.fill(3)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FoldInitializerAndIfToElvis" defaultSeverity="INFO" displayName="If-Null return/break/... foldable to '?:'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an &lt;code&gt;if&lt;/code&gt; expression that checks variable being null or not right after initializing it that can be converted into an elvis operator in the initializer.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(foo: Int?, bar: Int): Int {
      var i = foo
      if (i == null) {
          return bar
      }
      return i
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix converts the &lt;code&gt;if&lt;/code&gt; expression with an initializer into an elvis expression:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(foo: Int?, bar: Int): Int {
      var i = foo ?: return bar
      return i
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceWithImportAlias" defaultSeverity="INFORMATION" displayName="Fully qualified name can be replaced with existing import alias" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fully qualified names that can be replaced with an existing import alias.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import foo.Foo as Bar
fun main() {
    foo.Foo()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
import foo.Foo as Bar
fun main() {
    Bar()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConvertPairConstructorToToFunction" defaultSeverity="INFORMATION" displayName="Convert Pair constructor to 'to' function" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a &lt;code&gt;Pair&lt;/code&gt; constructor invocation that can be replaced with a &lt;code&gt;to()&lt;/code&gt; infix function call.
&lt;p&gt;
    Explicit constructor invocations may add verbosity, especially if they are used multiple times.
    Replacing constructor calls with &lt;code&gt;to()&lt;/code&gt; makes code easier to read and maintain.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val countries = mapOf(
      Pair("France", "Paris"),
      Pair("Spain", "Madrid"),
      Pair("Germany", "Berlin")
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val countries = mapOf(
      "France" to "Paris",
      "Spain" to "Madrid",
      "Germany" to "Berlin"
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MayBeConstant" defaultSeverity="WEAK WARNING" displayName="Might be 'const'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports top-level &lt;code&gt;val&lt;/code&gt; properties in objects that might be declared as &lt;code&gt;const&lt;/code&gt;
for better performance and Java interoperability.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object A {
      val foo = 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  object A {
      const val foo = 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceAssertBooleanWithAssertEquality" defaultSeverity="WEAK WARNING" displayName="Assert boolean could be replaced with assert equality" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;assertTrue()&lt;/code&gt; and &lt;code&gt;assertFalse()&lt;/code&gt; that can be replaced with assert equality functions.
&lt;p&gt;
    &lt;code&gt;assertEquals()&lt;/code&gt;, &lt;code&gt;assertSame()&lt;/code&gt;, and their negating counterparts (-Not-) provide more informative messages on
    failure.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  assertTrue(a == b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  assertEquals(a, b)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UsePropertyAccessSyntax" defaultSeverity="WEAK WARNING" displayName="Accessor call that can be replaced with property access syntax" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Java &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; method calls that can be replaced with the Kotlin synthetic properties.
&lt;p&gt;&lt;b&gt;Use property access syntax&lt;/b&gt; quick-fix can be used to amen the code automatically.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Java:
  public class JavaClassWithGetter {
      private final String expr = "result";

      // ...

      public String getExpr() {
          return expr;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
  // Kotlin:
  fun test(j: JavaClassWithGetter) {
      // ...
      j.getExpr() // &amp;lt;== A quick-fix simplifies the expression to 'j.expr'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SortModifiers" defaultSeverity="WEAK WARNING" displayName="Non-canonical modifier order" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports modifiers that do not follow the order recommended by the &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#modifiers-order"&gt;style guide&lt;/a&gt;.
&lt;p&gt;&lt;b&gt;Sort modifiers&lt;/b&gt; quick-fix can be used to amend the code automatically.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private inline fun correctOrder(f: () -&gt; Unit) {} // &amp;lt;== Ok

  infix private fun Int.wrongOrder(expr: Int) {} // &amp;lt;== wrong order, quick-fix amends the modifiers to "private infix"
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceJavaStaticMethodWithKotlinAnalog" defaultSeverity="WEAK WARNING" displayName="Java methods should be replaced with Kotlin analog" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a Java method call that can be replaced with a Kotlin function, for example, &lt;code&gt;System.out.println()&lt;/code&gt;.
&lt;p&gt;Replacing the code gets rid of the dependency to Java and makes the idiomatic Kotlin code.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the Java method calls on the same Kotlin call.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.util.Arrays

  fun main() {
      val a = Arrays.asList(1, 3, null)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val a = listOf(1, 3, null)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaMapForEach" defaultSeverity="WEAK WARNING" displayName="Java Map.forEach method call should be replaced with Kotlin's forEach" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a Java Map.&lt;code&gt;forEach&lt;/code&gt; method call that can be replaced with Kotlin's &lt;b&gt;forEach&lt;/b&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(map: HashMap&amp;lt;Int, String&gt;) {
      map.forEach { (key, value) -&gt;
          foo(key, value)
      }
  }

  fun foo(i: Int, s: String) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix removes parentheses:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(map: HashMap&amp;lt;Int, String&gt;) {
      map.forEach { key, value -&gt;
          foo(key, value)
      }
  }

  fun foo(i: Int, s: String) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScopeFunctionConversion" defaultSeverity="INFORMATION" displayName="Scope function can be converted to another one" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports scope functions (&lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;also&lt;/code&gt;) that can be converted between each other.
&lt;p&gt;Using corresponding functions makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the scope function to another one.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x = &amp;quot;&amp;quot;.let {
      it.length
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x = &amp;quot;&amp;quot;.run {
      length
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MoveVariableDeclarationIntoWhen" defaultSeverity="WEAK WARNING" displayName="Variable declaration could be moved inside 'when'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports variable declarations that can be moved inside a &lt;code&gt;when&lt;/code&gt; expression.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun someCalc(x: Int) = x * 42

fun foo(x: Int): Int {
  val a = someCalc(x)
  return when (a) {
    1 -&amp;gt; a
    2 -&amp;gt; 2 * a
    else -&amp;gt; 24
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(x: Int): Int {
  return when (val a = someCalc(x)) {
    1 -&amp;gt; a
    2 -&amp;gt; 2 * a
    else -&amp;gt; 24
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceSubstringWithIndexingOperation" defaultSeverity="INFORMATION" displayName="'substring' call should be replaced with indexing operator" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls like &lt;code&gt;"abc".substring(0, 1)&lt;/code&gt; that can be replaced with &lt;code&gt;"abc"[0]&lt;/code&gt;.
&lt;p&gt;Obtaining the element by index makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the &lt;code&gt;substring&lt;/code&gt; call with the indexing operator.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      &amp;quot;abc&amp;quot;.substring(0, 1)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      &amp;quot;abc&amp;quot;[0]
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalExpectation" defaultSeverity="INFORMATION" displayName="Optionally expected annotation has no actual annotation" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports optionally expected annotations without actual annotation in some platform modules.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// common code
@OptionalExpectation
expect annotation class JvmName(val name: String)

@JvmName(name = "JvmFoo")
fun foo() { }

// jvm code
actual annotation class JvmName(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The inspection also reports cases when &lt;code&gt;actual annotation class JvmName&lt;/code&gt; is omitted for non-JVM platforms (for example, Native).&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceToStringWithStringTemplate" defaultSeverity="INFORMATION" displayName="Call of 'toString' could be replaced with string template" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;toString&lt;/code&gt; function calls that can be replaced with a string template.
&lt;p&gt;Using string templates makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces &lt;code&gt;toString&lt;/code&gt; with a string template.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(): String {
      val x = 1
      return x.toString()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(): String {
      val x = 1
      return &amp;quot;$x&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertTryFinallyToUseCall" defaultSeverity="WEAK WARNING" displayName="Convert try / finally to use() call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a &lt;code&gt;try-finally&lt;/code&gt; block with &lt;code&gt;resource.close()&lt;/code&gt; in &lt;code&gt;finally&lt;/code&gt; which can be converted to a &lt;code&gt;resource.use()&lt;/code&gt; call.
&lt;p&gt;&lt;code&gt;use()&lt;/code&gt; is easier to read and less error-prone as there is no need in explicit &lt;code&gt;close()&lt;/code&gt; call.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      val reader = File("file.txt").bufferedReader()
      try {
          reader.lineSequence().forEach(::print)
      } finally {
          reader.close()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      File("file.txt").bufferedReader().use { reader -&gt;
          reader.lineSequence().forEach(::print)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Destructure" defaultSeverity="INFO" displayName="Use destructuring declaration" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports declarations that can be destructured.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class My(val first: String, val second: Int, val third: Boolean)

  fun foo(list: List&amp;lt;My&gt;) {
      list.forEach { my -&gt;
          println(my.second)
          println(my.third)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix destructures the declaration and introduces new variables with names from the corresponding class:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class My(val first: String, val second: Int, val third: Boolean)

  fun foo(list: List&amp;lt;My&gt;) {
      list.forEach { (_, second, third) -&gt;
          println(second)
          println(third)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ImplicitThis" defaultSeverity="INFORMATION" displayName="Implicit 'this'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of implicit &lt;b&gt;this&lt;/b&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      fun s() = ""

      fun test() {
          s()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix specifies &lt;b&gt;this&lt;/b&gt; explicitly:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      fun s() = ""

      fun test() {
          this.s()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SafeCastWithReturn" defaultSeverity="WEAK WARNING" displayName="Safe cast with 'return' should be replaced with 'if' type check" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports safe cast with &lt;code&gt;return&lt;/code&gt; that can be replaced with &lt;code&gt;if&lt;/code&gt; type check.
&lt;p&gt;Using corresponding functions makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the safe cast with &lt;code&gt;if&lt;/code&gt; type check.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(x: Any) {
      x as? String ?: return
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(x: Any) {
      if (x !is String) return
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceArrayOfWithLiteral" defaultSeverity="WEAK WARNING" displayName="'arrayOf' call can be replaced with array literal [...]" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;arrayOf&lt;/code&gt; calls that can be replaced with array literals &lt;code&gt;[...]&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  annotation class MyAnnotation(val strings: Array&amp;lt;String&amp;gt;)

  @MyAnnotation(arrayOf("alpha", "beta", "omega")) // replaceable 'arrayOf()'
  class MyClass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  annotation class MyAnnotation(val strings: Array&amp;lt;String&amp;gt;)

  @MyAnnotation(["alpha", "beta", "omega"])
  class MyClass
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConvertTwoComparisonsToRangeCheck" defaultSeverity="INFO" displayName="Two comparisons should be converted to a range check" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports two consecutive comparisons that can be converted to a range check.
&lt;p&gt;Checking against a range makes code simpler by removing test subject duplication.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun checkMonth(month: Int): Boolean {
      return month &gt;= 1 &amp;&amp; month &amp;lt;= 12
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix replaces the comparison-based check with a range one:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun checkMonth(month: Int): Boolean {
      return month in 1..12
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertToStringTemplate" defaultSeverity="INFO" displayName="String concatenation that can be converted to string template" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports string concatenation that can be converted to a string template.
&lt;p&gt;Using string templates is recommended as it makes code easier to read.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      val capitals = mapOf("France" to "Paris", "Spain" to "Madrid")
      for ((country, capital) in capitals) {
          print(capital + " is a capital of " + country)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      val capitals = mapOf("France" to "Paris", "Spain" to "Madrid")
      for ((country, capital) in capitals) {
          print("$capital is a capital of $country")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifyNestedEachInScopeFunction" defaultSeverity="WEAK WARNING" displayName="Scope function with nested forEach can be simplified" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;forEach&lt;/code&gt; functions in the scope functions such as &lt;code&gt;also&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt; that can be simplified.
&lt;p&gt;&lt;b&gt;Convert forEach call to onEach&lt;/b&gt; quick-fix can be used to amend the code automatically.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;) {
      val x = list.also { it.forEach { it + 4 } }.toString()
      val y = list.apply { forEach { println(it) } }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;Int&amp;gt;) {
      val x = list.onEach { it + 4 }.toString()
      val y = list.onEach { println(it) }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoopToCallChain" defaultSeverity="INFORMATION" displayName="Loop can be replaced with stdlib operations" enabled="true" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;for&lt;/code&gt; loops that can be replaced with a sequence of stdlib operations (like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, and so on).
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(list: List&amp;lt;String&amp;gt;): List&amp;lt;Int&amp;gt; {
  val result = ArrayList&amp;lt;Int&amp;gt;()
  for (s in list) {
     if (s.length &amp;gt; 0)
       result.add(s.hashCode())
     }
  return result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun foo(list: List&amp;lt;String&amp;gt;): List&amp;lt;Int&amp;gt; {
  val result = list
    .filter { it.length &amp;gt; 0 }
    .map { it.hashCode() }
  return result
}&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceSubstringWithDropLast" defaultSeverity="INFORMATION" displayName="'substring' call should be replaced with 'dropLast' call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls like &lt;code&gt;s.substring(0, s.length - x)&lt;/code&gt; that can be replaced with &lt;code&gt;s.dropLast(x)&lt;/code&gt;.
&lt;p&gt;Using corresponding functions makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the &lt;code&gt;substring&lt;/code&gt; call with &lt;code&gt;dropLast&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.substring(0, s.length - 5)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(s: String) {
      s.dropLast(5)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantRunCatching" defaultSeverity="WEAK WARNING" displayName="Redundant 'runCatching' call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;runCatching&lt;/code&gt; calls that are immediately followed by &lt;code&gt;getOrThrow&lt;/code&gt;.
Such calls can be replaced with just &lt;code&gt;run&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() = runCatching { doSomething() }.getOrThrow()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() = run { doSomething() }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UseExpressionBody" defaultSeverity="INFORMATION" displayName="Expression body syntax is preferable here" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;return&lt;/code&gt; expressions (one-liners or &lt;code&gt;when&lt;/code&gt;) that can be replaced with expression body syntax.
&lt;p&gt;Expression body syntax is recommended by the &lt;a href="https://kotlinlang.org/docs/coding-conventions.html#functions"&gt;style guide&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Convert to expression body&lt;/b&gt; quick-fix can be used to amend the code automatically.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun sign(x: Int): Int {
      return when { // &amp;lt;== can be simplified
          x &amp;lt; 0 -&gt; -1
          x &gt; 0 -&gt; 1
          else -&gt; 0
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun sign(x: Int): Int = when {
      x &amp;lt; 0 -&gt; -1
      x &gt; 0 -&gt; 1
      else -&gt; 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IfThenToElvis" defaultSeverity="INFO" displayName="If-Then foldable to '?:'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if-then&lt;/code&gt; expressions that can be folded into elvis (&lt;code&gt;?:&lt;/code&gt;) expressions.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun maybeFoo(): String? = "foo"

  var foo = maybeFoo()
  val bar = if (foo == null) "hello" else foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix converts the &lt;code&gt;if-then&lt;/code&gt; expression into an elvis (&lt;code&gt;?:&lt;/code&gt;) expression:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun maybeFoo(): String? = "foo"

  var foo = maybeFoo()
  val bar = foo ?: "hello"
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantElseInIf" defaultSeverity="INFORMATION" displayName="Redundant 'else' in 'if'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports redundant &lt;code&gt;else&lt;/code&gt; in &lt;code&gt;if&lt;/code&gt; with &lt;code&gt;return&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(arg: Boolean): Int {
      if (arg) return 0
      else { // This else is redundant, code in braces could be just shifted left
          someCode()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(arg: Boolean): Int {
      if (arg) return 0
      someCode()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplacePutWithAssignment" defaultSeverity="WEAK WARNING" displayName="'map.put()' can be converted to assignment" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;map.put&lt;/code&gt; function calls that can be replaced with indexing operator (&lt;code&gt;[]&lt;/code&gt;).
&lt;p&gt;Using syntactic sugar makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces &lt;code&gt;put&lt;/code&gt; call with the assignment.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(map: MutableMap&amp;lt;Int, String&amp;gt;) {
      map.put(42, &amp;quot;foo&amp;quot;)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(map: MutableMap&amp;lt;Int, String&amp;gt;) {
      map[42] = &amp;quot;foo&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Validity issues" path="Groovy"><inspection shortName="GroovyUnreachableStatement" defaultSeverity="WARNING" displayName="Unreachable statement" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports statements that are unreachable. This can occur if the statement is after an infinite loop,
  &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, or &lt;code&gt;continue&lt;/code&gt; statement.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; foo (int n) {
      if (n &lt; 1) {
          return
          &lt;b&gt;print('This statement is unreachable')&lt;/b&gt;
      }
      while (true){
          print ('Hello, world!')
      }
      &lt;b&gt;print('This statement is unreachable too')&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyDuplicateSwitchBranch" defaultSeverity="WARNING" displayName="Duplicate switch case" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports duplicated expressions in &lt;code&gt;case&lt;/code&gt; labels for &lt;code&gt;switch&lt;/code&gt;
statements.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
switch (n) {
  case 1: //duplicate
    break
  case 1: //duplicate
    System.out.println("2")
    break
  default:
    System.out.println("default");
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="HTML" path=""><inspection shortName="HtmlUnknownBooleanAttribute" defaultSeverity="WARNING" displayName="Incorrect boolean attribute" enabled="true" language="HTML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an HTML non-boolean attribute without a value. Suggests configuring attributes that should not be reported.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlExtraClosingTag" defaultSeverity="WARNING" displayName="Redundant closing tag" enabled="true" language="HTML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant closing tags on empty elements, for example, &lt;code&gt;img&lt;/code&gt; or &lt;code&gt;br&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;body&gt;
      &amp;lt;br&gt;&amp;lt;/br&gt;
    &amp;lt;/body&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;body&gt;
      &amp;lt;br&gt;
    &amp;lt;/body&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlUnknownAnchorTarget" defaultSeverity="WARNING" displayName="Unresolved fragment in a link" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unresolved last part of an URL after the &lt;code&gt;#&lt;/code&gt; sign.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckEmptyScriptTag" defaultSeverity="WARNING" displayName="Empty tag" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports empty tags that do not work in some browsers.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;script/&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;script&gt;&amp;lt;/script&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlUnknownTarget" defaultSeverity="WARNING" displayName="Unresolved file in a link" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unresolved file in a link.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckValidXmlInScriptTagBody" defaultSeverity="ERROR" displayName="Malformed content of 'script' tag" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports contents of &lt;code&gt;script&lt;/code&gt; tags that are invalid XML.&lt;br&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;script type="text/javascript"&gt;
    console.log('&amp;lt;');
  &amp;lt;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;script type="text/javascript"&gt;
    console.log('&amp;amp;lt;');
  &amp;lt;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlUnknownTag" defaultSeverity="WARNING" displayName="Unknown tag" enabled="true" language="HTML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unknown HTML tag. Suggests configuring tags that should not be reported.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlMissingClosingTag" defaultSeverity="INFORMATION" displayName="Missing closing tag" enabled="true" language="HTML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an HTML element without a closing tag.
Some coding styles require that HTML elements have closing tags even where this is optional.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;body&gt;
      &amp;lt;p&gt;Behold!
    &amp;lt;/body&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;html&gt;
    &amp;lt;body&gt;
      &amp;lt;p&gt;Behold!&amp;lt;/p&gt;
    &amp;lt;/body&gt;
  &amp;lt;/html&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HtmlUnknownAttribute" defaultSeverity="WARNING" displayName="Unknown attribute" enabled="true" language="HTML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unknown HTML attribute. Suggests configuring attributes that should not be reported.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RequiredAttributes" defaultSeverity="WARNING" displayName="Missing required attribute" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a missing mandatory attribute in an XML/HTML tag. Suggests configuring attributes that should not be reported.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android" path=""><inspection shortName="AndroidUnknownAttribute" defaultSeverity="WARNING" displayName="Unknown Android XML attribute" enabled="true" language="XML" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
This inspection highlights unknown XML attributes in Android resource files and AndroidManifest.xml
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlWrongFileType" defaultSeverity="WARNING" displayName="Android XML root tag validation" enabled="true" language="XML" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
This inspections checks whether XML resources are stored in resource folder
which type is recommended by documentation
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AndroidUnresolvableTag" defaultSeverity="ERROR" displayName="Unresolvable tag" enabled="true" language="XML" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;!--
  ~ Copyright (C) 2019 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
This inspection highlights unresolvable XML tag references in Android resource files
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AndroidNonConstantResIdsInSwitch" defaultSeverity="ERROR" displayName="Non-constant resource ID in a switch statement" enabled="true" language="JAVA" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
Validates using resource IDs in a switch statement in Android library module.&lt;br&gt;
Resource IDs are non final in the library projects since SDK tools r14,
means that the library code cannot treat these IDs as constants.
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidDomInspection" defaultSeverity="ERROR" displayName="Android Resources Validation" enabled="true" language="XML" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
  Validates resource references inside Android XML files.
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidMissingOnClickHandler" defaultSeverity="WARNING" displayName="onClick handler is missing in the related activity" enabled="true" language="XML" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Checks if the method specified in onClick XML attribute is declared in related activity
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AndroidElementNotAllowed" defaultSeverity="WARNING" displayName="Android XML element is not allowed" enabled="true" language="XML" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
This inspection highlights unallowed XML tags in Android resource files and AndroidManifest.xml
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Method metrics" path="Java"><inspection shortName="ParametersPerConstructor" defaultSeverity="WARNING" displayName="Constructor with too many parameters" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports constructors whose number of parameters exceeds the specified maximum.
Such objects are hard to instantiate, especially if some parameters are optional.
Constructors with too many parameters may indicate that refactoring is necessary.
Consider applying the builder pattern, for example.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public BankAccount(long accountNumber,
                     String owner,
                     double balance,
                     double interestRate) {
    // fields initialization
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Parameter limit&lt;/b&gt; field to specify the maximum allowed number of parameters in a constructor.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore constructors with visibility&lt;/b&gt; list to specify whether the inspection should ignore constructors with specific visibility.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CyclomaticComplexity" defaultSeverity="WARNING" displayName="Overly complex method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that have too many branch points.
&lt;p&gt;A branch point is one of the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;loop statement&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;if&lt;/code&gt; statement&lt;/li&gt;
  &lt;li&gt;ternary expression&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;catch&lt;/code&gt; section&lt;/li&gt;
  &lt;li&gt;expression with one or more &lt;code&gt;&amp;&amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; operators inside&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;switch&lt;/code&gt; block with non-default branches&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Methods with too high cyclomatic complexity may be confusing and hard to test.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Method complexity limit&lt;/b&gt; field to specify the maximum allowed cyclomatic complexity for a method.&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleReturnPointsPerMethod" defaultSeverity="WARNING" displayName="Method with multiple return points" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods whose number of &lt;code&gt;return&lt;/code&gt; points exceeds the specified maximum.
Methods with too many &lt;code&gt;return&lt;/code&gt; points may be confusing
and hard to refactor.
&lt;p&gt;A &lt;code&gt;return&lt;/code&gt; point is either a &lt;code&gt;return&lt;/code&gt; statement or a falling through the bottom of a
  &lt;code&gt;void&lt;/code&gt; method or constructor.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;The method below is reported if only two &lt;code&gt;return&lt;/code&gt; statements are allowed:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doSmth(User[] users) {
    for (User user : users) {
      if (cond1(user)) {
        user.setId(getId());
        return;
      } else if (cond2(user)) {
        if (cond3(user)) {
          user.setId(getId());
          return;
        }
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Consider rewriting the method so it becomes easier to understand:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doSmth(User[] users) {
    for (User user : users) {
      if (cond1(user) || cond2(user) &amp;&amp; cond3(user)) {
        user.setId(getId());
        return;
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Return point limit&lt;/b&gt; field to specify the maximum allowed number of &lt;code&gt;return&lt;/code&gt; points for a method.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore guard clauses&lt;/b&gt; option to ignore guard clauses.
    A guard clause is an &lt;code&gt;if&lt;/code&gt; statement that contains only a &lt;code&gt;return&lt;/code&gt; statement&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore for 'equals()' methods&lt;/b&gt; option to ignore &lt;code&gt;return&lt;/code&gt; points inside &lt;code&gt;equals()&lt;/code&gt; methods.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodWithMultipleLoops" defaultSeverity="WARNING" displayName="Method with multiple loops" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that contain more than one loop statement.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;The method below will be reported because it contains two loops:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void methodWithTwoLoops(int n1, int n2) {
    for (int i = 0; i &amp;lt; n1; i++) {
      System.out.println(i);
    }

    int j = 0;
    while (j &amp;lt; n2) {
      System.out.println(j);
      j++;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following method will also be reported because it contains a nested loop:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void methodWithNestedLoop(int n1, int n2) {
    for (int i = 0; i &amp;lt; n1; i++) {
      for (int j = 0; j &amp;lt; n2; j++) {
        System.out.println(i + j);
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreeNegationsPerMethod" defaultSeverity="WARNING" displayName="Method with more than three negations" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods with three or more negations.
Such methods may be confusing.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doSmth(int a, int b, boolean flag1, boolean flag2) {
    if (!flag &amp;&amp; !flag2) {
      if (a != b) {
        doOther();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Without negations, the method becomes easier to understand:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doSmth(int a, int b, boolean flag1, boolean flag2) {
    if (flag1 || flag2 || a == b) return;
    doOther();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore negations in 'equals()' methods&lt;/b&gt; option to disable the inspection within &lt;code&gt;equals()&lt;/code&gt; methods.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore negations in 'assert' statements&lt;/b&gt; to disable the inspection within &lt;code&gt;assert&lt;/code&gt; statements.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodCoupling" defaultSeverity="WARNING" displayName="Overly coupled method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that reference too many other classes.
Methods with too high coupling can be very fragile and should be probably split into smaller methods.
&lt;p&gt;Each referenced class is counted only once no matter how many times it is referenced.&lt;/p&gt;
  &lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Method coupling limit&lt;/b&gt; field to specify the maximum allowed coupling for a method.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Include couplings to java system classes&lt;/b&gt; option to count references to classes from &lt;code&gt;java&lt;/code&gt;or &lt;code&gt;javax&lt;/code&gt; packages.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Include couplings to library classes&lt;/b&gt; option to count references to third-party library classes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrownExceptionsPerMethod" defaultSeverity="WARNING" displayName="Method with too many exceptions declared" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that have too many types of exceptions in its &lt;code&gt;throws&lt;/code&gt; list.
&lt;p&gt;Methods with too many exceptions declared are a good sign that your error handling code is getting overly complex.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Exceptions thrown limit&lt;/b&gt; field to specify the maximum number of exception types a method is allowed to have in its &lt;code&gt;throws&lt;/code&gt; list.&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonCommentSourceStatements" defaultSeverity="WARNING" displayName="Overly long method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods whose number of statements exceeds the specified maximum.
&lt;p&gt;Methods with too many statements may be confusing and are a good sign that refactoring is necessary.&lt;/p&gt;
&lt;p&gt;The following statements are not counted:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;empty statements (semicolons)&lt;/li&gt;
  &lt;li&gt;block statements&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for&lt;/code&gt; loop initialization statements, that is, &lt;code&gt;int i = ...&lt;/code&gt; within a &lt;code&gt;for(int i = ...;...)&lt;/code&gt;
    statement&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for&lt;/code&gt; loop update statements, that is, &lt;code&gt;i += 2&lt;/code&gt; within a &lt;code&gt;for(int i = ...;...; i += 2)&lt;/code&gt;
    statement&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Maximum statements per method&lt;/b&gt; field to specify the maximum allowed number of statements in a method.&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyLongLambda" defaultSeverity="WARNING" displayName="Overly long lambda expression" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports lambda expressions whose number of statements exceeds the specified maximum.
&lt;p&gt;Lambda expressions that are too long may be confusing, and it is often better to extract the statements into a separate method.&lt;p&gt;
&lt;p&gt;The following statements are not counted:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;empty statements (semicolons)&lt;/li&gt;
  &lt;li&gt;block statements&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for&lt;/code&gt; loop initialization statements, that is, &lt;code&gt;int i = ...&lt;/code&gt; within a &lt;code&gt;for(int i = ...;...)&lt;/code&gt;
    statement&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for&lt;/code&gt; loop update statements, that is, &lt;code&gt;i += 2&lt;/code&gt; within a &lt;code&gt;for(int i = ...;...; i += 2)&lt;/code&gt;
    statement&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the  &lt;b&gt;Non-comment source statements limit&lt;/b&gt; field to specify the maximum allowed number of statements in a lambda expression.&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NestingDepth" defaultSeverity="WARNING" displayName="Overly nested method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods whose body contain too deeply nested statements.
&lt;p&gt;Methods with too deep statement
  nesting may be confusing and are a good sign that refactoring may be necessary.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Nesting depth limit&lt;/b&gt; field to specify the maximum allowed nesting depth for a method.&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParametersPerMethod" defaultSeverity="WARNING" displayName="Method with too many parameters" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods whose number of parameters exceeds the specified maximum.
Methods with too many parameters can be a good sign that a refactoring is necessary.
&lt;p&gt;Methods that have super methods are not reported.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Parameter limit&lt;/b&gt; field to specify the maximum allowed number of parameters for a method.&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Correctness" path="Android/Lint"><inspection shortName="AndroidLintUniqueConstants" defaultSeverity="ERROR" displayName="Overlapping Enumeration Constants" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Overlapping Enumeration Constants&lt;br&gt;&lt;br&gt;The &lt;code&gt;@IntDef&lt;/code&gt; annotation allows you to create a light-weight "enum" or type definition. However, it's possible to accidentally specify the same value for two or more of the values, which can lead to hard-to-detect bugs. This check looks for this scenario and flags any repeated constants.&lt;br/&gt;
&lt;br/&gt;
In some cases, the repeated constant is intentional (for example, renaming a constant to a more intuitive name, and leaving the old name in place for compatibility purposes).  In that case, simply suppress this check by adding a &lt;code&gt;@SuppressLint("UniqueConstants")&lt;/code&gt; annotation.&lt;br&gt;&lt;br&gt;Issue id: UniqueConstants&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSourceLockedOrientationActivity" defaultSeverity="WARNING" displayName="Incompatible setRequestedOrientation value" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incompatible setRequestedOrientation value&lt;br&gt;&lt;br&gt;The &lt;code&gt;Activity&lt;/code&gt; should not be locked to a portrait orientation so that users can take advantage of the multi-window environments and larger landscape-first screens that Android runs on such as Chrome OS. To fix the issue, consider calling &lt;code&gt;setRequestedOrientation&lt;/code&gt; with the &lt;code&gt;ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR&lt;/code&gt; or &lt;code&gt;ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED&lt;/code&gt; options or removing the call all together.&lt;br&gt;&lt;br&gt;Issue id: SourceLockedOrientationActivity&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintXmlEscapeNeeded" defaultSeverity="ERROR" displayName="Missing XML Escape" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing XML Escape&lt;br&gt;&lt;br&gt;When a string contains characters that have special usage in XML, you must escape the characters.&lt;br&gt;&lt;br&gt;Issue id: XmlEscapeNeeded&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintKotlinNullnessAnnotation" defaultSeverity="ERROR" displayName="Kotlin nullability annotation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Kotlin nullability annotation&lt;br&gt;&lt;br&gt;In Kotlin, nullness is part of the type system; &lt;code&gt;s: String&lt;/code&gt; is &lt;b&gt;never&lt;/b&gt; null and &lt;code&gt;s: String?&lt;/code&gt; is sometimes null, whether or not you add in additional annotations stating &lt;code&gt;@NonNull&lt;/code&gt; or &lt;code&gt;@Nullable&lt;/code&gt;. These are likely copy/paste mistakes, and are misleading.&lt;br&gt;&lt;br&gt;Issue id: KotlinNullnessAnnotation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintParcelCreator" defaultSeverity="ERROR" displayName="Missing Parcelable CREATOR field" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Parcelable &lt;code&gt;CREATOR&lt;/code&gt; field&lt;br&gt;&lt;br&gt;According to the &lt;code&gt;Parcelable&lt;/code&gt; interface documentation, "Classes implementing the Parcelable interface must also have a static field called &lt;code&gt;CREATOR&lt;/code&gt;, which is an object implementing the &lt;code&gt;Parcelable.Creator&lt;/code&gt; interface."&lt;br&gt;&lt;br&gt;Issue id: ParcelCreator&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/os/Parcelable.html"&gt;https://developer.android.com/reference/android/os/Parcelable.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDiscouragedPrivateApi" defaultSeverity="WARNING" displayName="Using Discouraged Private API" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Discouraged Private API&lt;br&gt;&lt;br&gt;Usage of restricted non-SDK interface may throw an exception at runtime. Accessing non-SDK methods or fields through reflection has a high likelihood to break your app between versions, and is being restricted to facilitate future app compatibility.&lt;br&gt;&lt;br&gt;Issue id: DiscouragedPrivateApi&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces"&gt;https://developer.android.com/preview/restrictions-non-sdk-interfaces&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradlePluginVersion" defaultSeverity="ERROR" displayName="Incompatible Android Gradle Plugin" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incompatible Android Gradle Plugin&lt;br&gt;&lt;br&gt;Not all versions of the Android Gradle plugin are compatible with all versions of the SDK. If you update your tools, or if you are trying to open a project that was built with an old version of the tools, you may need to update your plugin version number.&lt;br&gt;&lt;br&gt;Issue id: GradlePluginVersion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingInflatedId" defaultSeverity="ERROR" displayName="ID not found in inflated resource" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;ID not found in inflated resource&lt;br&gt;&lt;br&gt;Checks calls to layout inflation and makes sure that the referenced ids are found in the corresponding layout (or at least one of them, if the layout has multiple configurations.)&lt;br&gt;&lt;br&gt;Issue id: MissingInflatedId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateIds" defaultSeverity="ERROR" displayName="Duplicate ids within a single layout" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate ids within a single layout&lt;br&gt;&lt;br&gt;Within a layout, id's should be unique since otherwise &lt;code&gt;findViewById()&lt;/code&gt; can return an unexpected view.&lt;br&gt;&lt;br&gt;Issue id: DuplicateIds&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLongLogTag" defaultSeverity="ERROR" displayName="Too Long Log Tags" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Too Long Log Tags&lt;br&gt;&lt;br&gt;Log tags are only allowed to be at most 23 tag characters long.&lt;br&gt;&lt;br&gt;Issue id: LongLogTag&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicatePlatformClasses" defaultSeverity="ERROR" displayName="Duplicate Platform Classes" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate Platform Classes&lt;br&gt;&lt;br&gt;There are a number of libraries that duplicate not just functionality of the Android platform but using the exact same class names as the ones provided in Android -- for example the apache http classes. This can lead to unexpected crashes.&lt;br/&gt;
&lt;br/&gt;
To solve this, you need to either find a newer version of the library which no longer has this problem, or to repackage the library (and all of its dependencies) using something like the &lt;code&gt;jarjar&lt;/code&gt; tool, or finally, rewriting the code to use different APIs (for example, for http code, consider using &lt;code&gt;HttpUrlConnection&lt;/code&gt; or a library like &lt;code&gt;okhttp&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: DuplicatePlatformClasses&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleIdeError" defaultSeverity="ERROR" displayName="Gradle IDE Support Issues" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Gradle IDE Support Issues&lt;br&gt;&lt;br&gt;Gradle is highly flexible, and there are things you can do in Gradle files which can make it hard or impossible for IDEs to properly handle the project. This lint check looks for constructs that potentially break IDE support.&lt;br&gt;&lt;br&gt;Issue id: GradleIdeError&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLogTagMismatch" defaultSeverity="ERROR" displayName="Mismatched Log Tags" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mismatched Log Tags&lt;br&gt;&lt;br&gt;When guarding a &lt;code&gt;Log.v(tag, ...)&lt;/code&gt; call with &lt;code&gt;Log.isLoggable(tag)&lt;/code&gt;, the tag passed to both calls should be the same. Similarly, the level passed in to &lt;code&gt;Log.isLoggable&lt;/code&gt; should typically match the type of &lt;code&gt;Log&lt;/code&gt; call, e.g. if checking level &lt;code&gt;Log.DEBUG&lt;/code&gt;, the corresponding &lt;code&gt;Log&lt;/code&gt; call should be &lt;code&gt;Log.d&lt;/code&gt;, not &lt;code&gt;Log.i&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: LogTagMismatch&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateIncludedIds" defaultSeverity="WARNING" displayName="Duplicate ids across layouts combined with include tags" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate ids across layouts combined with include tags&lt;br&gt;&lt;br&gt;It's okay for two independent layouts to use the same ids. However, if layouts are combined with include tags, then the id's need to be unique within any chain of included layouts, or &lt;code&gt;Activity#findViewById()&lt;/code&gt; can return an unexpected view.&lt;br&gt;&lt;br&gt;Issue id: DuplicateIncludedIds&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIncludeLayoutParam" defaultSeverity="ERROR" displayName="Ignored layout params on include" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Ignored layout params on include&lt;br&gt;&lt;br&gt;Layout parameters specified on an &lt;code&gt;&amp;lt;include&gt;&lt;/code&gt; tag will only be used if you also override &lt;code&gt;layout_width&lt;/code&gt; and &lt;code&gt;layout_height&lt;/code&gt; on the &lt;code&gt;&amp;lt;include&gt;&lt;/code&gt; tag; otherwise they will be ignored.&lt;br&gt;&lt;br&gt;Issue id: IncludeLayoutParam&lt;br&gt;&lt;br&gt;&lt;a href="https://stackoverflow.com/questions/2631614/does-android-xml-layouts-include-tag-really-work"&gt;https://stackoverflow.com/questions/2631614/does-android-xml-layouts-include-tag-really-work&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWatchFaceForAndroidX" defaultSeverity="WARNING" displayName="AndroidX watch faces must use action WATCH_FACE_EDITOR" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;AndroidX watch faces must use action &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt;&lt;br&gt;&lt;br&gt;If the package depends on &lt;code&gt;androidx.wear:wear-watchface&lt;/code&gt;, and an AndroidX watch face declares the &lt;code&gt;wearableConfigurationAction&lt;/code&gt; metadata, its value should be &lt;code&gt;androidx.wear.watchface.editor.action.WATCH_FACE_EDITOR&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: WatchFaceForAndroidX&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/watch-faces/configuration"&gt;https://developer.android.com/training/wearables/watch-faces/configuration&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWebViewApiAvailability" defaultSeverity="WARNING" displayName="WebView API Availability" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WebView API Availability&lt;br&gt;&lt;br&gt;The &lt;code&gt;androidx.webkit&lt;/code&gt; library is a static library you can add to your Android application allowing you to use new APIs on older platform versions, targeting more devices.&lt;br&gt;&lt;br&gt;Issue id: WebViewApiAvailability&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/androidx/webkit/package-summary"&gt;https://developer.android.com/reference/androidx/webkit/package-summary&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCheckResult" defaultSeverity="WARNING" displayName="Ignoring results" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Ignoring results&lt;br&gt;&lt;br&gt;Some methods have no side effects, and calling them without doing something without the result is suspicious.&lt;br&gt;&lt;br&gt;Issue id: CheckResult&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidWearFeatureAttribute" defaultSeverity="ERROR" displayName="Invalid attribute for Wear uses-feature" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid attribute for Wear uses-feature&lt;br&gt;&lt;br&gt;For the &lt;code&gt;android.hardware.type.watch&lt;/code&gt; uses-feature, android:required="false" is disallowed. A single APK for Wear and non-Wear devices is not supported.&lt;br&gt;&lt;br&gt;Issue id: InvalidWearFeatureAttribute&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/apps/packaging.html"&gt;https://developer.android.com/training/wearables/apps/packaging.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTestAppLink" defaultSeverity="ERROR" displayName="Unmatched URLs" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unmatched URLs&lt;br&gt;&lt;br&gt;Using one or more &lt;code&gt;tools:validation testUrl="some url"/&gt;&lt;/code&gt; elements in your manifest allows the link attributes in your intent filter to be checked for matches.&lt;br&gt;&lt;br&gt;Issue id: TestAppLink&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInstantApps" defaultSeverity="WARNING" displayName="Instant App Issues" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Instant App Issues&lt;br&gt;&lt;br&gt;This issue flags code that will not work correctly in Instant Apps&lt;br&gt;&lt;br&gt;Issue id: InstantApps&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnknownId" defaultSeverity="ERROR" displayName="Reference to an unknown id" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Reference to an unknown id&lt;br&gt;&lt;br&gt;The &lt;code&gt;@+id/&lt;/code&gt; syntax refers to an existing id, or creates a new one if it has not already been defined elsewhere. However, this means that if you have a typo in your reference, or if the referred view no longer exists, you do not get a warning since the id will be created on demand. This check catches errors where you have renamed an id without updating all of the references to it.&lt;br&gt;&lt;br&gt;Issue id: UnknownId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAndroidGradlePluginVersion" defaultSeverity="WARNING" displayName="Obsolete Android Gradle Plugin Version" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete Android Gradle Plugin Version&lt;br&gt;&lt;br&gt;This detector looks for usage of the Android Gradle Plugin where the version you are using is not the current stable release. Using older versions is fine, and there are cases where you deliberately want to stick with an older version. However, you may simply not be aware that a more recent version is available, and that is what this lint check helps find.&lt;br&gt;&lt;br&gt;Issue id: AndroidGradlePluginVersion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSimpleDateFormat" defaultSeverity="WARNING" displayName="Implied locale in date format" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implied locale in date format&lt;br&gt;&lt;br&gt;Almost all callers should use &lt;code&gt;getDateInstance()&lt;/code&gt;, &lt;code&gt;getDateTimeInstance()&lt;/code&gt;, or &lt;code&gt;getTimeInstance()&lt;/code&gt; to get a ready-made instance of SimpleDateFormat suitable for the user's locale. The main reason you'd create an instance this class directly is because you need to format/parse a specific machine-readable format, in which case you almost certainly want to explicitly ask for US to ensure that you get ASCII digits (rather than, say, Arabic digits).&lt;br/&gt;
&lt;br/&gt;
Therefore, you should either use the form of the SimpleDateFormat constructor where you pass in an explicit locale, such as Locale.US, or use one of the get instance methods, or suppress this error if really know what you are doing.&lt;br&gt;&lt;br&gt;Issue id: SimpleDateFormat&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/text/SimpleDateFormat.html"&gt;https://developer.android.com/reference/java/text/SimpleDateFormat.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateActivity" defaultSeverity="ERROR" displayName="Activity registered more than once" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Activity registered more than once&lt;br&gt;&lt;br&gt;An activity should only be registered once in the manifest. If it is accidentally registered more than once, then subtle errors can occur, since attribute declarations from the two elements are not merged, so you may accidentally remove previous declarations.&lt;br&gt;&lt;br&gt;Issue id: DuplicateActivity&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCutPasteId" defaultSeverity="WARNING" displayName="Likely cut &amp; paste mistakes" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Likely cut &amp;amp; paste mistakes&lt;br&gt;&lt;br&gt;This lint check looks for cases where you have cut &amp;amp; pasted calls to &lt;code&gt;findViewById&lt;/code&gt; but have forgotten to update the R.id field. It's possible that your code is simply (redundantly) looking up the field repeatedly, but lint cannot distinguish that from a case where you for example want to initialize fields &lt;code&gt;prev&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; and you cut &amp;amp; pasted &lt;code&gt;findViewById(R.id.prev)&lt;/code&gt; and forgot to update the second initialization to &lt;code&gt;R.id.next&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: CutPasteId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintServiceCast" defaultSeverity="ERROR" displayName="Wrong system service casts" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong system service casts&lt;br&gt;&lt;br&gt;When you call &lt;code&gt;Context#getSystemService()&lt;/code&gt;, the result is typically cast to a specific interface. This lint check ensures that the cast is compatible with the expected type of the return value.&lt;br&gt;&lt;br&gt;Issue id: ServiceCast&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearableActionDuplicate" defaultSeverity="WARNING" displayName="Duplicate watch face configuration activities found" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate watch face configuration activities found&lt;br&gt;&lt;br&gt;If and only if a watch face service defines &lt;code&gt;wearableConfigurationAction&lt;/code&gt; metadata, with the value &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt;, there should be an activity in the same package, which has an intent filter for &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt; (with com.google.android.wearable.watchface.category.WEARABLE_CONFIGURATION if minSdkVersion is less than 30).&lt;br&gt;&lt;br&gt;Issue id: WearableActionDuplicate&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/watch-faces/configuration"&gt;https://developer.android.com/training/wearables/watch-faces/configuration&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFileEndsWithExt" defaultSeverity="WARNING" displayName="File endsWith on file extensions" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;File endsWith on file extensions&lt;br&gt;&lt;br&gt;The Kotlin extension method &lt;code&gt;File.endsWith(suffix)&lt;/code&gt; checks whole path components, not just string suffixes. This means that &lt;code&gt;File("foo.txt").endsWith(".txt")&lt;/code&gt; will return false. Instead you might have intended &lt;code&gt;file.path.endsWith&lt;/code&gt; or &lt;code&gt;file.extension.equals&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: FileEndsWithExt&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNfcTechWhitespace" defaultSeverity="ERROR" displayName="Whitespace in NFC tech lists" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Whitespace in NFC tech lists&lt;br&gt;&lt;br&gt;In a &lt;code&gt;&amp;lt;tech-list&gt;&lt;/code&gt;, there can be whitespace around the &lt;code&gt;&amp;lt;tech&gt;&lt;/code&gt; elements,but not inside them. This is because the code which reads in the tech list is currently very strict and will include the whitespace as part of the name.&lt;br/&gt;
&lt;br/&gt;
In other words, use &lt;code&gt;&amp;lt;tech&gt;name&amp;lt;/tech&gt;&lt;/code&gt;, not &lt;code&gt;&amp;lt;tech&gt; name &amp;lt;/tech&gt;&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: NfcTechWhitespace&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/36988969"&gt;https://issuetracker.google.com/36988969&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppBundleLocaleChanges" defaultSeverity="WARNING" displayName="App Bundle handling of runtime locale changes" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;App Bundle handling of runtime locale changes&lt;br&gt;&lt;br&gt;When changing locales at runtime (e.g. to provide an in-app language switcher), the Android App Bundle must be configured to not split by locale or the Play Core library must be used to download additional locales at runtime.&lt;br&gt;&lt;br&gt;Issue id: AppBundleLocaleChanges&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/app-bundle/configure-base#handling_language_changes"&gt;https://developer.android.com/guide/app-bundle/configure-base#handling_language_changes&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidNavigation" defaultSeverity="WARNING" displayName="No start destination specified" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;No start destination specified&lt;br&gt;&lt;br&gt;All &lt;code&gt;&amp;lt;navigation&gt;&lt;/code&gt; elements must have a start destination specified, and it must be a direct child of that &lt;code&gt;&amp;lt;navigation&gt;&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidNavigation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInstantiatable" defaultSeverity="ERROR" displayName="Registered class is not instantiatable" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Registered class is not instantiatable&lt;br&gt;&lt;br&gt;Activities, services, broadcast receivers etc. registered in the manifest file (or for custom views, in a layout file) must be "instantiatable" by the system, which means that the class must be public, it must have an empty public constructor, and if it's an inner class, it must be a static inner class.&lt;br&gt;&lt;br&gt;Issue id: Instantiatable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeviceAdmin" defaultSeverity="WARNING" displayName="Malformed Device Admin" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Malformed Device Admin&lt;br&gt;&lt;br&gt;If you register a broadcast receiver which acts as a device admin, you must also register an &lt;code&gt;&amp;lt;intent-filter&gt;&lt;/code&gt; for the action &lt;code&gt;android.app.action.DEVICE_ADMIN_ENABLED&lt;/code&gt;, without any &lt;code&gt;&amp;lt;data&gt;&lt;/code&gt;, such that the device admin can be activated/deactivated.&lt;br/&gt;
&lt;br/&gt;
To do this, add
&lt;pre&gt;
`&amp;lt;intent-filter&gt;`
    `&amp;lt;action android:name="android.app.action.DEVICE_ADMIN_ENABLED" /&gt;`
`&amp;lt;/intent-filter&gt;`
&lt;/pre&gt;
to your &lt;code&gt;&amp;lt;receiver&gt;&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: DeviceAdmin&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppCompatResource" defaultSeverity="ERROR" displayName="Menu namespace" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Menu namespace&lt;br&gt;&lt;br&gt;When using the appcompat library, menu resources should refer to the &lt;code&gt;showAsAction&lt;/code&gt; (or &lt;code&gt;actionViewClass&lt;/code&gt;, or &lt;code&gt;actionProviderClass&lt;/code&gt;) in the &lt;code&gt;app:&lt;/code&gt; namespace, not the &lt;code&gt;android:&lt;/code&gt; namespace.&lt;br/&gt;
&lt;br/&gt;
Similarly, when &lt;b&gt;not&lt;/b&gt; using the appcompat library, you should be using the &lt;code&gt;android:showAsAction&lt;/code&gt; (or &lt;code&gt;actionViewClass&lt;/code&gt;, or &lt;code&gt;actionProviderClass&lt;/code&gt;) attribute.&lt;br&gt;&lt;br&gt;Issue id: AppCompatResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintScrollViewSize" defaultSeverity="WARNING" displayName="ScrollView size validation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;ScrollView size validation&lt;br&gt;&lt;br&gt;ScrollView children must set their &lt;code&gt;layout_width&lt;/code&gt; or &lt;code&gt;layout_height&lt;/code&gt; attributes to &lt;code&gt;wrap_content&lt;/code&gt; rather than &lt;code&gt;fill_parent&lt;/code&gt; or &lt;code&gt;match_parent&lt;/code&gt; in the scrolling dimension&lt;br&gt;&lt;br&gt;Issue id: ScrollViewSize&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFontValidation" defaultSeverity="ERROR" displayName="Validation of font files" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Validation of font files&lt;br&gt;&lt;br&gt;Look for problems in various font files.&lt;br&gt;&lt;br&gt;Issue id: FontValidation&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/text/downloadable-fonts.html"&gt;https://developer.android.com/guide/topics/text/downloadable-fonts.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOverrideAbstract" defaultSeverity="ERROR" displayName="Not overriding abstract methods on older platforms" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Not overriding abstract methods on older platforms&lt;br&gt;&lt;br&gt;To improve the usability of some APIs, some methods that used to be &lt;code&gt;abstract&lt;/code&gt; have been made concrete by adding default implementations. This means that when compiling with new versions of the SDK, your code does not have to override these methods.&lt;br/&gt;
&lt;br/&gt;
However, if your code is also targeting older versions of the platform where these methods were still &lt;code&gt;abstract&lt;/code&gt;, the code will crash. You must override all methods that used to be abstract in any versions targeted by your application's &lt;code&gt;minSdkVersion&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: OverrideAbstract&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintImpliedTouchscreenHardware" defaultSeverity="ERROR" displayName="Touchscreen not optional" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Touchscreen not optional&lt;br&gt;&lt;br&gt;Apps require the &lt;code&gt;android.hardware.touchscreen&lt;/code&gt; feature by default. If you want your app to be available on TV, you must also explicitly declare that a touchscreen is not required as follows:&lt;br/&gt;
&lt;code&gt;&amp;lt;uses-feature android:name="android.hardware.touchscreen" android:required="false"/&gt;&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: ImpliedTouchscreenHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/uses-feature-element.html"&gt;https://developer.android.com/guide/topics/manifest/uses-feature-element.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintVisibleForTests" defaultSeverity="WARNING" displayName="Visible Only For Tests" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Visible Only For Tests&lt;br&gt;&lt;br&gt;With the &lt;code&gt;@VisibleForTesting&lt;/code&gt; annotation you can specify an &lt;code&gt;otherwise=&lt;/code&gt; attribute which specifies the intended visibility if the method had not been made more widely visible for the tests.&lt;br/&gt;
&lt;br/&gt;
This check looks for accesses from production code (e.g. not tests) where the access would not have been allowed with the intended production visibility.&lt;br&gt;&lt;br&gt;Issue id: VisibleForTests&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEnqueueWork" defaultSeverity="WARNING" displayName="WorkManager Enqueue" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WorkManager Enqueue&lt;br&gt;&lt;br&gt;&lt;code&gt;WorkContinuations&lt;/code&gt; cannot be enqueued automatically.  You must call &lt;code&gt;enqueue()&lt;/code&gt; on a &lt;code&gt;WorkContinuation&lt;/code&gt; to have it and its parent continuations enqueued inside &lt;code&gt;WorkManager&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: EnqueueWork&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMergeMarker" defaultSeverity="ERROR" displayName="Code contains merge marker" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Code contains merge marker&lt;br&gt;&lt;br&gt;Many version control systems leave unmerged files with markers such as &amp;lt;&amp;lt;&amp;lt; in the source code. This check looks for these markers, which are sometimes accidentally left in, particularly in resource files where they don't break compilation.&lt;br&gt;&lt;br&gt;Issue id: MergeMarker&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInternalInsetResource" defaultSeverity="WARNING" displayName="Using internal inset dimension resource" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using internal inset dimension resource&lt;br&gt;&lt;br&gt;The internal inset dimension resources are not a supported way to retrieve the relevant insets for your application. The insets are dynamic values that can change while your app is visible, and your app's window may not intersect with the system UI. To get the relevant value for your app and listen to updates, use &lt;code&gt;androidx.core.view.WindowInsetsCompat&lt;/code&gt; and related APIs.&lt;br&gt;&lt;br&gt;Issue id: InternalInsetResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOnClick" defaultSeverity="ERROR" displayName="onClick method does not exist" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;onClick&lt;/code&gt; method does not exist&lt;br&gt;&lt;br&gt;The &lt;code&gt;onClick&lt;/code&gt; attribute value should be the name of a method in this View's context to invoke when the view is clicked. This name must correspond to a public method that takes exactly one parameter of type &lt;code&gt;View&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Must be a string value, using '\;' to escape characters such as '\n' or '\uxxxx' for a unicode character.&lt;br&gt;&lt;br&gt;Issue id: OnClick&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOldTargetApi" defaultSeverity="WARNING" displayName="Target SDK attribute is not targeting latest version" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Target SDK attribute is not targeting latest version&lt;br&gt;&lt;br&gt;When your application runs on a version of Android that is more recent than your &lt;code&gt;targetSdkVersion&lt;/code&gt; specifies that it has been tested with, various compatibility modes kick in. This ensures that your application continues to work, but it may look out of place. For example, if the &lt;code&gt;targetSdkVersion&lt;/code&gt; is less than 14, your app may get an option button in the UI.&lt;br/&gt;
&lt;br/&gt;
To fix this issue, set the &lt;code&gt;targetSdkVersion&lt;/code&gt; to the highest available value. Then test your app to make sure everything works correctly. You may want to consult the compatibility notes to see what changes apply to each version you are adding support for: &lt;a href="https://developer.android.com/reference/android/os/Build.VERSION_CODES.html"&gt;https://developer.android.com/reference/android/os/Build.VERSION_CODES.html&lt;/a&gt; as well as follow this guide:&lt;br/&gt;
&lt;a href="https://developer.android.com/distribute/best-practices/develop/target-sdk.html"&gt;https://developer.android.com/distribute/best-practices/develop/target-sdk.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: OldTargetApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleDeprecated" defaultSeverity="WARNING" displayName="Deprecated Gradle Construct" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Deprecated Gradle Construct&lt;br&gt;&lt;br&gt;This detector looks for deprecated Gradle constructs which currently work but will likely stop working in a future update.&lt;br&gt;&lt;br&gt;Issue id: GradleDeprecated&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWebViewLayout" defaultSeverity="ERROR" displayName="WebViews in wrap_content parents" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WebViews in wrap_content parents&lt;br&gt;&lt;br&gt;The WebView implementation has certain performance optimizations which will not work correctly if the parent view is using &lt;code&gt;wrap_content&lt;/code&gt; rather than &lt;code&gt;match_parent&lt;/code&gt;. This can lead to subtle UI bugs.&lt;br&gt;&lt;br&gt;Issue id: WebViewLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEmptySuperCall" defaultSeverity="WARNING" displayName="Calling an empty super method" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Calling an empty super method&lt;br&gt;&lt;br&gt;For methods annotated with &lt;code&gt;@EmptySuper&lt;/code&gt;, overriding methods should not also call the super implementation, either because it is empty, or perhaps it contains code not intended to be run when the method is overridden.&lt;br&gt;&lt;br&gt;Issue id: EmptySuperCall&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRemoteViewLayout" defaultSeverity="ERROR" displayName="Unsupported View in RemoteView" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsupported View in RemoteView&lt;br&gt;&lt;br&gt;In a &lt;code&gt;RemoteView&lt;/code&gt;, only some layouts and views are allowed.&lt;br&gt;&lt;br&gt;Issue id: RemoteViewLayout&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/widget/RemoteViews"&gt;https://developer.android.com/reference/android/widget/RemoteViews&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUniquePermission" defaultSeverity="ERROR" displayName="Permission names are not unique" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission names are not unique&lt;br&gt;&lt;br&gt;The unqualified names or your permissions must be unique. The reason for this is that at build time, the &lt;code&gt;aapt&lt;/code&gt; tool will generate a class named &lt;code&gt;Manifest&lt;/code&gt; which contains a field for each of your permissions. These fields are named using your permission unqualified names (i.e. the name portion after the last dot).&lt;br/&gt;
&lt;br/&gt;
If more than one permission maps to the same field name, that field will arbitrarily name just one of them.&lt;br&gt;&lt;br&gt;Issue id: UniquePermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRedundantLabel" defaultSeverity="WARNING" displayName="Redundant label on activity" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Redundant label on activity&lt;br&gt;&lt;br&gt;When an activity does not have a label attribute, it will use the one from the application tag. Since the application has already specified the same label, the label on this activity can be omitted.&lt;br&gt;&lt;br&gt;Issue id: RedundantLabel&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintEllipsizeMaxLines" defaultSeverity="ERROR" displayName="Combining Ellipsize and Maxlines" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Combining Ellipsize and Maxlines&lt;br&gt;&lt;br&gt;Combining &lt;code&gt;ellipsize&lt;/code&gt; and &lt;code&gt;maxLines=1&lt;/code&gt; can lead to crashes on some devices. Earlier versions of lint recommended replacing &lt;code&gt;singleLine=true&lt;/code&gt; with &lt;code&gt;maxLines=1&lt;/code&gt; but that should not be done when using &lt;code&gt;ellipsize&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: EllipsizeMaxLines&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/issues/36950033"&gt;https://issuetracker.google.com/issues/36950033&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStopShip" defaultSeverity="ERROR" displayName="Code contains STOPSHIP marker" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Code contains &lt;code&gt;STOPSHIP&lt;/code&gt; marker&lt;br&gt;&lt;br&gt;Using the comment &lt;code&gt;// STOPSHIP&lt;/code&gt; can be used to flag code that is incomplete but checked in. This comment marker can be used to indicate that the code should not be shipped until the issue is addressed, and lint will look for these. In Gradle projects, this is only checked for non-debug (release) builds.&lt;br/&gt;
&lt;br/&gt;
In Kotlin, the &lt;code&gt;TODO()&lt;/code&gt; method is also treated as a stop ship marker; you can use it to make incomplete code compile, but it will throw an exception at runtime and therefore should be fixed before shipping releases.&lt;br&gt;&lt;br&gt;Issue id: StopShip&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintProguardSplit" defaultSeverity="WARNING" displayName="Proguard.cfg file contains generic Android rules" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Proguard.cfg file contains generic Android rules&lt;br&gt;&lt;br&gt;Earlier versions of the Android tools bundled a single &lt;code&gt;proguard.cfg&lt;/code&gt; file containing a ProGuard configuration file suitable for Android shrinking and obfuscation. However, that version was copied into new projects, which means that it does not continue to get updated as we improve the default ProGuard rules for Android.&lt;br/&gt;
&lt;br/&gt;
In the new version of the tools, we have split the ProGuard configuration into two halves:&lt;br/&gt;
* A simple configuration file containing only project-specific flags, in your project&lt;br/&gt;
* A generic configuration file containing the recommended set of ProGuard options for Android projects. This generic file lives in the SDK install directory which means that it gets updated along with the tools.&lt;br/&gt;
&lt;br/&gt;
In order for this to work, the proguard.config property in the &lt;code&gt;project.properties&lt;/code&gt; file now refers to a path, so you can reference both the generic file as well as your own (and any additional files too).&lt;br/&gt;
&lt;br/&gt;
To migrate your project to the new setup, create a new &lt;code&gt;proguard-project.txt&lt;/code&gt; file in your project containing any project specific ProGuard flags as well as any customizations you have made, then update your project.properties file to contain:&lt;br/&gt;
&lt;code&gt;proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: ProguardSplit&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintScrollViewCount" defaultSeverity="WARNING" displayName="ScrollView can have only one child" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;ScrollView&lt;/code&gt; can have only one child&lt;br&gt;&lt;br&gt;A &lt;code&gt;ScrollView&lt;/code&gt; can only have one child widget. If you want more children, wrap them in a container layout.&lt;br&gt;&lt;br&gt;Issue id: ScrollViewCount&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingClass" defaultSeverity="ERROR" displayName="Missing registered class" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing registered class&lt;br&gt;&lt;br&gt;If a class is referenced in the manifest or in a layout file, it must also exist in the project (or in one of the libraries included by the project. This check helps uncover typos in registration names, or attempts to rename or move classes without updating the XML references properly.&lt;br&gt;&lt;br&gt;Issue id: MissingClass&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/manifest-intro.html"&gt;https://developer.android.com/guide/topics/manifest/manifest-intro.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotificationId0" defaultSeverity="ERROR" displayName="Notification Id is 0" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notification Id is 0&lt;br&gt;&lt;br&gt;The notification id &lt;b&gt;cannot&lt;/b&gt; be 0; using 0 here can make the service not run in the foreground.&lt;br&gt;&lt;br&gt;Issue id: NotificationId0&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResourceCycle" defaultSeverity="ERROR" displayName="Cycle in resource definitions" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Cycle in resource definitions&lt;br&gt;&lt;br&gt;There should be no cycles in resource definitions as this can lead to runtime exceptions.&lt;br&gt;&lt;br&gt;Issue id: ResourceCycle&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInflateParams" defaultSeverity="WARNING" displayName="Layout Inflation without a Parent" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Layout Inflation without a Parent&lt;br&gt;&lt;br&gt;When inflating a layout, avoid passing in null as the parent view, since otherwise any layout parameters on the root of the inflated layout will be ignored.&lt;br&gt;&lt;br&gt;Issue id: InflateParams&lt;br&gt;&lt;br&gt;&lt;a href="https://www.bignerdranch.com/blog/understanding-androids-layoutinflater-inflate/"&gt;https://www.bignerdranch.com/blog/understanding-androids-layoutinflater-inflate/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRange" defaultSeverity="ERROR" displayName="Outside Range" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Outside Range&lt;br&gt;&lt;br&gt;Some parameters are required to in a particular numerical range; this check makes sure that arguments passed fall within the range. For arrays, Strings and collections this refers to the size or length.&lt;br&gt;&lt;br&gt;Issue id: Range&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingSuperCall" defaultSeverity="ERROR" displayName="Missing Super Call" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Super Call&lt;br&gt;&lt;br&gt;Some methods, such as &lt;code&gt;View#onDetachedFromWindow&lt;/code&gt;, require that you also call the super implementation as part of your method.&lt;br&gt;&lt;br&gt;Issue id: MissingSuperCall&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCommitPrefEdits" defaultSeverity="WARNING" displayName="Missing commit() on SharedPreference editor" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;commit()&lt;/code&gt; on &lt;code&gt;SharedPreference&lt;/code&gt; editor&lt;br&gt;&lt;br&gt;After calling &lt;code&gt;edit()&lt;/code&gt; on a &lt;code&gt;SharedPreference&lt;/code&gt;, you must call &lt;code&gt;commit()&lt;/code&gt; or &lt;code&gt;apply()&lt;/code&gt; on the editor to save the results.&lt;br&gt;&lt;br&gt;Issue id: CommitPrefEdits&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleDependency" defaultSeverity="WARNING" displayName="Obsolete Gradle Dependency" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete Gradle Dependency&lt;br&gt;&lt;br&gt;This detector looks for usages of libraries where the version you are using is not the current stable release. Using older versions is fine, and there are cases where you deliberately want to stick with an older version. However, you may simply not be aware that a more recent version is available, and that is what this lint check helps find.&lt;br&gt;&lt;br&gt;Issue id: GradleDependency&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotConstructor" defaultSeverity="WARNING" displayName="Not a Constructor" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Not a Constructor&lt;br&gt;&lt;br&gt;This check catches methods that look like they were intended to be constructors, but aren't.&lt;br&gt;&lt;br&gt;Issue id: NotConstructor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingVersion" defaultSeverity="WARNING" displayName="Missing application name/version" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing application name/version&lt;br&gt;&lt;br&gt;You should define the version information for your application.&lt;br/&gt;
&lt;br/&gt;
&lt;code&gt;android:versionCode&lt;/code&gt;: An integer value that represents the version of the application code, relative to other versions.&lt;br/&gt;
&lt;br/&gt;
&lt;code&gt;android:versionName&lt;/code&gt;: A string value that represents the release version of the application code, as it should be shown to users.&lt;br&gt;&lt;br&gt;Issue id: MissingVersion&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/studio/publish/versioning#appversioning"&gt;https://developer.android.com/studio/publish/versioning#appversioning&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMotionLayoutInvalidSceneFileReference" defaultSeverity="ERROR" displayName="layoutDescription must specify a scene file" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;layoutDescription must specify a scene file&lt;br&gt;&lt;br&gt;A motion scene file specifies the animations used in a &lt;code&gt;MotionLayout&lt;/code&gt;. The &lt;code&gt;layoutDescription&lt;/code&gt; is required to specify a valid motion scene file.&lt;br&gt;&lt;br&gt;Issue id: MotionLayoutInvalidSceneFileReference&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintReturnThis" defaultSeverity="ERROR" displayName="Method must return this" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Method must return &lt;code&gt;this&lt;/code&gt;&lt;br&gt;&lt;br&gt;Methods annotated with &lt;code&gt;@ReturnThis&lt;/code&gt; (usually in the super method that this method is overriding) should also &lt;code&gt;return this&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: ReturnThis&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInconsistentLayout" defaultSeverity="WARNING" displayName="Inconsistent Layouts" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Inconsistent Layouts&lt;br&gt;&lt;br&gt;This check ensures that a layout resource which is defined in multiple resource folders, specifies the same set of widgets.&lt;br/&gt;
&lt;br/&gt;
This finds cases where you have accidentally forgotten to add a widget to all variations of the layout, which could result in a runtime crash for some resource configurations when a &lt;code&gt;findViewById()&lt;/code&gt; fails.&lt;br/&gt;
&lt;br/&gt;
There &lt;b&gt;are&lt;/b&gt; cases where this is intentional. For example, you may have a dedicated large tablet layout which adds some extra widgets that are not present in the phone version of the layout. As long as the code accessing the layout resource is careful to handle this properly, it is valid. In that case, you can suppress this lint check for the given extra or missing views, or the whole layout&lt;br&gt;&lt;br&gt;Issue id: InconsistentLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStateListReachable" defaultSeverity="WARNING" displayName="Unreachable state in a &lt;selector&gt;" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unreachable state in a &lt;code&gt;&amp;lt;selector&gt;&lt;/code&gt;&lt;br&gt;&lt;br&gt;In a selector, only the last child in the state list should omit a state qualifier. If not, all subsequent items in the list will be ignored since the given item will match all.&lt;br&gt;&lt;br&gt;Issue id: StateListReachable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPxUsage" defaultSeverity="WARNING" displayName="Using 'px' dimension" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using 'px' dimension&lt;br&gt;&lt;br&gt;For performance reasons and to keep the code simpler, the Android system uses pixels as the standard unit for expressing dimension or coordinate values. That means that the dimensions of a view are always expressed in the code using pixels, but always based on the current screen density. For instance, if &lt;code&gt;myView.getWidth()&lt;/code&gt; returns 10, the view is 10 pixels wide on the current screen, but on a device with a higher density screen, the value returned might be 15. If you use pixel values in your application code to work with bitmaps that are not pre-scaled for the current screen density, you might need to scale the pixel values that you use in your code to match the un-scaled bitmap source.&lt;br&gt;&lt;br&gt;Issue id: PxUsage&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/practices/screens_support.html#screen-independence"&gt;https://developer.android.com/guide/practices/screens_support.html#screen-independence&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintImplicitSamInstance" defaultSeverity="WARNING" displayName="Implicit SAM Instances" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implicit SAM Instances&lt;br&gt;&lt;br&gt;Kotlin's support for SAM (single accessor method) interfaces lets you pass a lambda to the interface. This will create a new instance on the fly even though there is no explicit constructor call. If you pass one of these lambdas or method references into a method which (for example) stores or compares the object identity, unexpected results may happen.&lt;br&gt;&lt;br&gt;Issue id: ImplicitSamInstance&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIncompatibleMediaBrowserServiceCompatVersion" defaultSeverity="WARNING" displayName="Obsolete version of MediaBrowserServiceCompat" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete version of MediaBrowserServiceCompat&lt;br&gt;&lt;br&gt;&lt;code&gt;MediaBrowserServiceCompat&lt;/code&gt; from version 23.2.0 to 23.4.0 of the Support v4 Library used private APIs and will not be compatible with future versions of Android beyond Android N. Please upgrade to version 24.0.0 or higher of the Support Library.&lt;br&gt;&lt;br&gt;Issue id: IncompatibleMediaBrowserServiceCompatVersion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDiffUtilEquals" defaultSeverity="ERROR" displayName="Suspicious DiffUtil Equality" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious DiffUtil Equality&lt;br&gt;&lt;br&gt;&lt;code&gt;areContentsTheSame&lt;/code&gt; is used by &lt;code&gt;DiffUtil&lt;/code&gt; to produce diffs. If the method is implemented incorrectly, such as using identity equals instead of equals, or calling equals on a class that has not implemented it, weird visual artifacts can occur.&lt;br&gt;&lt;br&gt;Issue id: DiffUtilEquals&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/116789824"&gt;https://issuetracker.google.com/116789824&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingTvBanner" defaultSeverity="ERROR" displayName="TV Missing Banner" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TV Missing Banner&lt;br&gt;&lt;br&gt;A TV application must provide a home screen banner for each localization if it includes a Leanback launcher intent filter. The banner is the app launch point that appears on the home screen in the apps and games rows.&lt;br&gt;&lt;br&gt;Issue id: MissingTvBanner&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/tv/start/start.html#banner"&gt;https://developer.android.com/training/tv/start/start.html#banner&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFullBackupContent" defaultSeverity="ERROR" displayName="Valid Full Backup Content File" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Valid Full Backup Content File&lt;br&gt;&lt;br&gt;Ensures that &lt;code&gt;&amp;lt;data-extraction-rules&lt;/code&gt;&gt; and &lt;code&gt;&amp;lt;full-backup-content&gt;&lt;/code&gt; files, which configure backup options, are valid.&lt;br&gt;&lt;br&gt;Issue id: FullBackupContent&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2015/07/auto-backup-for-apps-made-simple.html"&gt;https://android-developers.googleblog.com/2015/07/auto-backup-for-apps-made-simple.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongThread" defaultSeverity="ERROR" displayName="Wrong Thread" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Thread&lt;br&gt;&lt;br&gt;Ensures that a method which expects to be called on a specific thread, is actually called from that thread. For example, calls on methods in widgets should always be made on the UI thread.&lt;br&gt;&lt;br&gt;Issue id: WrongThread&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/processes-and-threads.html#Threads"&gt;https://developer.android.com/guide/components/processes-and-threads.html#Threads&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAnnotateVersionCheck" defaultSeverity="WARNING" displayName="Annotate SDK_INT checks" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Annotate SDK_INT checks&lt;br&gt;&lt;br&gt;Methods which perform &lt;code&gt;SDK_INT&lt;/code&gt; version checks (or field constants which reflect the result of a version check) in libraries should be annotated with &lt;code&gt;@ChecksSdkIntAtLeast&lt;/code&gt;. This makes it possible for lint to correctly check calls into the library later to correctly understand that problematic code which is wrapped within a call into this library is safe after all.&lt;br&gt;&lt;br&gt;Issue id: AnnotateVersionCheck&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSoonBlockedPrivateApi" defaultSeverity="ERROR" displayName="Using Soon-to-Be Blocked Private API" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Soon-to-Be Blocked Private API&lt;br&gt;&lt;br&gt;Usage of restricted non-SDK interface will throw an exception at runtime. Accessing non-SDK methods or fields through reflection has a high likelihood to break your app between versions, and is being restricted to facilitate future app compatibility.&lt;br&gt;&lt;br&gt;Issue id: SoonBlockedPrivateApi&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces"&gt;https://developer.android.com/preview/restrictions-non-sdk-interfaces&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidResourceFolder" defaultSeverity="ERROR" displayName="Invalid Resource Folder" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Resource Folder&lt;br&gt;&lt;br&gt;This lint check looks for a folder name that is not a valid resource folder name; these will be ignored and not packaged by the Android Gradle build plugin.&lt;br/&gt;
&lt;br/&gt;
Note that the order of resources is very important; for example, you can't specify a language before a network code.&lt;br/&gt;
&lt;br/&gt;
Similarly, note that to use 3 letter region codes, you have to use a special BCP 47 syntax: the prefix b+ followed by the BCP 47 language tag but with &lt;code&gt;+&lt;/code&gt; as the individual separators instead of &lt;code&gt;-&lt;/code&gt;. Therefore, for the BCP 47 language tag &lt;code&gt;nl-ABW&lt;/code&gt; you have to use &lt;code&gt;b+nl+ABW&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidResourceFolder&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/providing-resources.html"&gt;https://developer.android.com/guide/topics/resources/providing-resources.html&lt;/a&gt;&lt;br&gt;&lt;a href="https://tools.ietf.org/html/bcp47"&gt;https://tools.ietf.org/html/bcp47&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeprecated" defaultSeverity="WARNING" displayName="Using deprecated resources" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using deprecated resources&lt;br&gt;&lt;br&gt;Deprecated views, attributes and so on are deprecated because there is a better way to do something. Do it that new way. You've been warned.&lt;br&gt;&lt;br&gt;Issue id: Deprecated&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNewApi" defaultSeverity="ERROR" displayName="Calling new methods on older versions" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Calling new methods on older versions&lt;br&gt;&lt;br&gt;This check scans through all the Android API calls in the application and warns about any calls that are not available on &lt;b&gt;all&lt;/b&gt; versions targeted by this application (according to its minimum SDK attribute in the manifest).&lt;br/&gt;
&lt;br/&gt;
If you really want to use this API and don't need to support older devices just set the &lt;code&gt;minSdkVersion&lt;/code&gt; in your &lt;code&gt;build.gradle&lt;/code&gt; or &lt;code&gt;AndroidManifest.xml&lt;/code&gt; files.&lt;br/&gt;
&lt;br/&gt;
If your code is &lt;b&gt;deliberately&lt;/b&gt; accessing newer APIs, and you have ensured (e.g. with conditional execution) that this code will only ever be called on a supported platform, then you can annotate your class or method with the &lt;code&gt;@TargetApi&lt;/code&gt; annotation specifying the local minimum SDK to apply, such as &lt;code&gt;@TargetApi(11)&lt;/code&gt;, such that this check considers 11 rather than your manifest file's minimum SDK as the required API level.&lt;br/&gt;
&lt;br/&gt;
If you are deliberately setting &lt;code&gt;android:&lt;/code&gt; attributes in style definitions, make sure you place this in a &lt;code&gt;values-v&lt;/code&gt;&lt;i&gt;NN&lt;/i&gt; folder in order to avoid running into runtime conflicts on certain devices where manufacturers have added custom attributes whose ids conflict with the new ones on later platforms.&lt;br/&gt;
&lt;br/&gt;
Similarly, you can use tools:targetApi="11" in an XML file to indicate that the element will only be inflated in an adequate context.&lt;br&gt;&lt;br&gt;Issue id: NewApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintFindViewByIdCast" defaultSeverity="WARNING" displayName="Add Explicit Cast" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Add Explicit Cast&lt;br&gt;&lt;br&gt;In Android O, the &lt;code&gt;findViewById&lt;/code&gt; signature switched to using generics, which means that most of the time you can leave out explicit casts and just assign the result of the &lt;code&gt;findViewById&lt;/code&gt; call to variables of specific view classes.&lt;br/&gt;
&lt;br/&gt;
However, due to language changes between Java 7 and 8, this change may cause code to not compile without explicit casts. This lint check looks for these scenarios and suggests casts to be added now such that the code will continue to compile if the language level is updated to 1.8.&lt;br&gt;&lt;br&gt;Issue id: FindViewByIdCast&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPrivateResource" defaultSeverity="WARNING" displayName="Using private resources" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using private resources&lt;br&gt;&lt;br&gt;Private resources should not be referenced; the may not be present everywhere, and even where they are they may disappear without notice.&lt;br/&gt;
&lt;br/&gt;
To fix this, copy the resource into your own project instead.&lt;br&gt;&lt;br&gt;Issue id: PrivateResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotSibling" defaultSeverity="ERROR" displayName="Invalid Constraints" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Constraints&lt;br&gt;&lt;br&gt;Layout constraints in a given &lt;code&gt;ConstraintLayout&lt;/code&gt; or &lt;code&gt;RelativeLayout&lt;/code&gt; should reference other views within the same relative layout (but not itself!)&lt;br&gt;&lt;br&gt;Issue id: NotSibling&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingDefaultResource" defaultSeverity="ERROR" displayName="Missing Default" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Default&lt;br&gt;&lt;br&gt;If a resource is only defined in folders with qualifiers like &lt;code&gt;-land&lt;/code&gt; or &lt;code&gt;-en&lt;/code&gt;, and there is no default declaration in the base folder (&lt;code&gt;layout&lt;/code&gt; or &lt;code&gt;values&lt;/code&gt; etc), then the app will crash if that resource is accessed on a device where the device is in a configuration missing the given qualifier.&lt;br/&gt;
&lt;br/&gt;
As a special case, drawables do not have to be specified in the base folder; if there is a match in a density folder (such as &lt;code&gt;drawable-mdpi&lt;/code&gt;) that image will be used and scaled. Note however that if you  only specify a drawable in a folder like &lt;code&gt;drawable-en-hdpi&lt;/code&gt;, the app will crash in non-English locales.&lt;br/&gt;
&lt;br/&gt;
There may be scenarios where you have a resource, such as a &lt;code&gt;-fr&lt;/code&gt; drawable, which is only referenced from some other resource with the same qualifiers (such as a &lt;code&gt;-fr&lt;/code&gt; style), which itself has safe fallbacks. However, this still makes it possible for somebody to accidentally reference the drawable and crash, so it is safer to create a default fallback in the base folder. Alternatively, you can suppress the issue by adding &lt;code&gt;tools:ignore="MissingDefaultResource"&lt;/code&gt; on the element.&lt;br/&gt;
&lt;br/&gt;
(This scenario frequently happens with string translations, where you might delete code and the corresponding resources, but forget to delete a translation. There is a dedicated issue id for that scenario, with the id &lt;code&gt;ExtraTranslation&lt;/code&gt;.)&lt;br&gt;&lt;br&gt;Issue id: MissingDefaultResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMotionLayoutMissingId" defaultSeverity="ERROR" displayName="Views inside MotionLayout require an id" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Views inside &lt;code&gt;MotionLayout&lt;/code&gt; require an &lt;code&gt;android:id&lt;/code&gt;&lt;br&gt;&lt;br&gt;Views inside &lt;code&gt;MotionLayout&lt;/code&gt; require an &lt;code&gt;android:id&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: MotionLayoutMissingId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNonResizeableActivity" defaultSeverity="WARNING" displayName="Activity is set to be non resizeable" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Activity is set to be non resizeable&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;activity&gt;&lt;/code&gt; element should be allowed to be resized to allow users to take advantage of the multi-window environments available on larger screen Android devices.&lt;br/&gt;
&lt;br/&gt;
To fix the issue, consider declaring the corresponding activity element with &lt;code&gt;resizableActivity="true"&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: NonResizeableActivity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/arc/window-management"&gt;https://developer.android.com/topic/arc/window-management&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMockLocation" defaultSeverity="ERROR" displayName="Using mock location provider in production" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using mock location provider in production&lt;br&gt;&lt;br&gt;Using a mock location provider (by requiring the permission &lt;code&gt;android.permission.ACCESS_MOCK_LOCATION&lt;/code&gt;) should &lt;b&gt;only&lt;/b&gt; be done in debug builds (or from tests). In Gradle projects, that means you should only request this permission in a test or debug source set specific manifest file.&lt;br/&gt;
&lt;br/&gt;
To fix this, create a new manifest file in the debug folder and move the &lt;code&gt;&amp;lt;uses-permission&gt;&lt;/code&gt; element there. A typical path to a debug manifest override file in a Gradle project is src/debug/AndroidManifest.xml.&lt;br&gt;&lt;br&gt;Issue id: MockLocation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUsesMinSdkAttributes" defaultSeverity="WARNING" displayName="Minimum SDK and target SDK attributes not defined" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Minimum SDK and target SDK attributes not defined&lt;br&gt;&lt;br&gt;The manifest should contain a &lt;code&gt;&amp;lt;uses-sdk&gt;&lt;/code&gt; element which defines the minimum API Level required for the application to run, as well as the target version (the highest API level you have tested the version for).&lt;br&gt;&lt;br&gt;Issue id: UsesMinSdkAttributes&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html"&gt;https://developer.android.com/guide/topics/manifest/uses-sdk-element.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidWakeLockTag" defaultSeverity="ERROR" displayName="Invalid Wake Lock Tag" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Wake Lock Tag&lt;br&gt;&lt;br&gt;Wake Lock tags must follow the naming conventions defined in the`PowerManager` documentation.&lt;br&gt;&lt;br&gt;Issue id: InvalidWakeLockTag&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/os/PowerManager.html"&gt;https://developer.android.com/reference/android/os/PowerManager.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleDeprecatedConfiguration" defaultSeverity="WARNING" displayName="Deprecated Gradle Configuration" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Deprecated Gradle Configuration&lt;br&gt;&lt;br&gt;Some Gradle configurations have been deprecated since Android Gradle Plugin 3.0.0 and will be removed in a future version of the Android Gradle Plugin.&lt;br&gt;&lt;br&gt;Issue id: GradleDeprecatedConfiguration&lt;br&gt;&lt;br&gt;&lt;a href="https://d.android.com/r/tools/update-dependency-configurations"&gt;https://d.android.com/r/tools/update-dependency-configurations&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintVectorDrawableCompat" defaultSeverity="ERROR" displayName="Using VectorDrawableCompat" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using VectorDrawableCompat&lt;br&gt;&lt;br&gt;To use VectorDrawableCompat, you need to make two modifications to your project. First, set &lt;code&gt;android.defaultConfig.vectorDrawables.useSupportLibrary = true&lt;/code&gt; in your &lt;code&gt;build.gradle&lt;/code&gt; file, and second, use &lt;code&gt;app:srcCompat&lt;/code&gt; instead of &lt;code&gt;android:src&lt;/code&gt; to refer to vector drawables.&lt;br&gt;&lt;br&gt;Issue id: VectorDrawableCompat&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/graphics/vector-drawable-resources"&gt;https://developer.android.com/guide/topics/graphics/vector-drawable-resources&lt;/a&gt;&lt;br&gt;&lt;a href="https://medium.com/androiddevelopers/using-vector-assets-in-android-apps-4318fd662eb9"&gt;https://medium.com/androiddevelopers/using-vector-assets-in-android-apps-4318fd662eb9&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHighSamplingRate" defaultSeverity="WARNING" displayName="High sensor sampling rate" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;High sensor sampling rate&lt;br&gt;&lt;br&gt;Most apps don't need access to high sensor sampling rate. Double check your use case to ensure your app absolutely needs access to sensor sampling rate &gt; 200Hz. Be prepared for your app to be rejected from listing on Play Store until your use case for high sensor sampling rate has been reviewed and validated by the policy team.&lt;br&gt;&lt;br&gt;Issue id: HighSamplingRate&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRecyclerView" defaultSeverity="ERROR" displayName="RecyclerView Problems" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;RecyclerView Problems&lt;br&gt;&lt;br&gt;&lt;code&gt;RecyclerView&lt;/code&gt; will &lt;b&gt;not&lt;/b&gt; call &lt;code&gt;onBindViewHolder&lt;/code&gt; again when the position of the item changes in the data set unless the item itself is invalidated or the new position cannot be determined.&lt;br/&gt;
&lt;br/&gt;
For this reason, you should &lt;b&gt;only&lt;/b&gt; use the position parameter while acquiring the related data item inside this method, and should &lt;b&gt;not&lt;/b&gt; keep a copy of it.&lt;br/&gt;
&lt;br/&gt;
If you need the position of an item later on (e.g. in a click listener), use &lt;code&gt;getAdapterPosition()&lt;/code&gt; which will have the updated adapter position.&lt;br&gt;&lt;br&gt;Issue id: RecyclerView&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSlices" defaultSeverity="WARNING" displayName="Slices" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Slices&lt;br&gt;&lt;br&gt;This check analyzes usages of the Slices API and offers suggestions based on best practices.&lt;br&gt;&lt;br&gt;Issue id: Slices&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOrientation" defaultSeverity="ERROR" displayName="Missing explicit orientation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing explicit orientation&lt;br&gt;&lt;br&gt;The default orientation of a &lt;code&gt;LinearLayout&lt;/code&gt; is horizontal. It's pretty easy to believe that the layout is vertical, add multiple children to it, and wonder why only the first child is visible (when the subsequent children are off screen to the right). This lint rule helps pinpoint this issue by warning whenever a &lt;code&gt;LinearLayout&lt;/code&gt; is used with an implicit orientation and multiple children.&lt;br/&gt;
&lt;br/&gt;
It also checks for empty LinearLayouts without an &lt;code&gt;orientation&lt;/code&gt; attribute that also defines an &lt;code&gt;id&lt;/code&gt; attribute. This catches the scenarios where children will be added to the &lt;code&gt;LinearLayout&lt;/code&gt; dynamically. &lt;br&gt;&lt;br&gt;Issue id: Orientation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSQLiteString" defaultSeverity="WARNING" displayName="Using STRING instead of TEXT" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using STRING instead of TEXT&lt;br&gt;&lt;br&gt;In SQLite, any column can store any data type; the declared type for a column is more of a hint as to what the data should be cast to when stored.&lt;br/&gt;
&lt;br/&gt;
There are many ways to store a string. &lt;code&gt;TEXT&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;, &lt;code&gt;CHARACTER&lt;/code&gt; and &lt;code&gt;CLOB&lt;/code&gt; are string types, &lt;b&gt;but `STRING` is not&lt;/b&gt;. Columns defined as STRING are actually numeric.&lt;br/&gt;
&lt;br/&gt;
If you try to store a value in a numeric column, SQLite will try to cast it to a float or an integer before storing. If it can't, it will just store it as a string.&lt;br/&gt;
&lt;br/&gt;
This can lead to some subtle bugs. For example, when SQLite encounters a string like &lt;code&gt;1234567e1234&lt;/code&gt;, it will parse it as a float, but the result will be out of range for floating point numbers, so &lt;code&gt;Inf&lt;/code&gt; will be stored! Similarly, strings that look like integers will lose leading zeroes.&lt;br/&gt;
&lt;br/&gt;
To fix this, you can change your schema to use a &lt;code&gt;TEXT&lt;/code&gt; type instead.&lt;br&gt;&lt;br&gt;Issue id: SQLiteString&lt;br&gt;&lt;br&gt;&lt;a href="https://www.sqlite.org/datatype3.html"&gt;https://www.sqlite.org/datatype3.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResourceAsColor" defaultSeverity="ERROR" displayName="Should pass resolved color instead of resource id" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Should pass resolved color instead of resource id&lt;br&gt;&lt;br&gt;Methods that take a color in the form of an integer should be passed an RGB triple, not the actual color resource id. You must call &lt;code&gt;getResources().getColor(resource)&lt;/code&gt; to resolve the actual color value first.&lt;br/&gt;
&lt;br/&gt;
Similarly, methods that take a dimension integer should be passed an actual dimension (call &lt;code&gt;getResources().getDimension(resource)&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: ResourceAsColor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNamespaceTypo" defaultSeverity="ERROR" displayName="Misspelled namespace declaration" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Misspelled namespace declaration&lt;br&gt;&lt;br&gt;Accidental misspellings in namespace declarations can lead to some very obscure error messages. This check looks for potential misspellings to help track these down.&lt;br&gt;&lt;br&gt;Issue id: NamespaceTypo&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRequiredSize" defaultSeverity="ERROR" displayName="Missing layout_width or layout_height attributes" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;layout_width&lt;/code&gt; or &lt;code&gt;layout_height&lt;/code&gt; attributes&lt;br&gt;&lt;br&gt;All views must specify an explicit &lt;code&gt;layout_width&lt;/code&gt; and &lt;code&gt;layout_height&lt;/code&gt; attribute. There is a runtime check for this, so if you fail to specify a size, an exception is thrown at runtime.&lt;br/&gt;
&lt;br/&gt;
It's possible to specify these widths via styles as well. GridLayout, as a special case, does not require you to specify a size.&lt;br&gt;&lt;br&gt;Issue id: RequiredSize&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppIndexingService" defaultSeverity="WARNING" displayName="App Indexing Background Services" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;App Indexing Background Services&lt;br&gt;&lt;br&gt;Apps targeting Android 8.0 or higher can no longer rely on background services while listening for updates to the on-device index. Use a &lt;code&gt;BroadcastReceiver&lt;/code&gt; for the &lt;code&gt;UPDATE_INDEX&lt;/code&gt; intent to continue supporting indexing in your app.&lt;br&gt;&lt;br&gt;Issue id: AppIndexingService&lt;br&gt;&lt;br&gt;&lt;a href="https://firebase.google.com/docs/app-indexing/android/personal-content#add-a-broadcast-receiver-to-your-app"&gt;https://firebase.google.com/docs/app-indexing/android/personal-content#add-a-broadcast-receiver-to-your-app&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBrokenIterator" defaultSeverity="WARNING" displayName="Broken Iterator" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Broken Iterator&lt;br&gt;&lt;br&gt;&lt;b&gt;For LinkedHashMap:&lt;/b&gt;&lt;br/&gt;
&lt;br/&gt;
The spliterators returned by &lt;code&gt;LinkedHashMap&lt;/code&gt; in Android Nougat (API levels 24 and 25) use the wrong order (inconsistent with the iterators, which use the correct order), despite reporting &lt;code&gt;Spliterator.ORDERED&lt;/code&gt;. You may use the following code fragments to obtain a correctly ordered &lt;code&gt;Spliterator&lt;/code&gt; on API level 24 and 25:&lt;br/&gt;
&lt;br/&gt;
For a Collection view &lt;code&gt;c = lhm.entrySet()&lt;/code&gt;, &lt;code&gt;c = lhm.keySet()&lt;/code&gt; or &lt;code&gt;c = lhm.values()&lt;/code&gt;, use &lt;code&gt;java.util.Spliterators.spliterator(c, c.spliterator().characteristics())&lt;/code&gt; instead of &lt;code&gt;c.spliterator()&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Instead of &lt;code&gt;c.stream()&lt;/code&gt; or &lt;code&gt;c.parallelStream()&lt;/code&gt;, use &lt;code&gt;java.util.stream.StreamSupport.stream(spliterator, false)&lt;/code&gt; to construct a (nonparallel) Stream from such a &lt;code&gt;Spliterator&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;For Vector:&lt;/b&gt;&lt;br/&gt;
&lt;br/&gt;
The &lt;code&gt;listIterator()&lt;/code&gt; returned for a &lt;code&gt;Vector&lt;/code&gt; has a broken &lt;code&gt;add()&lt;/code&gt; implementation on Android N (API level 24). Consider switching to &lt;code&gt;ArrayList&lt;/code&gt; and if necessary adding synchronization.&lt;br&gt;&lt;br&gt;Issue id: BrokenIterator&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/util/LinkedHashMap"&gt;https://developer.android.com/reference/java/util/LinkedHashMap&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidVectorPath" defaultSeverity="ERROR" displayName="Invalid vector paths" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid vector paths&lt;br&gt;&lt;br&gt;This check ensures that vector paths are valid. For example, it makes sure that the numbers are not using scientific notation (such as 1.0e3) which can lead to runtime crashes on older devices. As another example, it flags numbers like &lt;code&gt;.5&lt;/code&gt; which should be written as &lt;code&gt;0.5&lt;/code&gt; instead to avoid crashes on some pre-Marshmallow devices.&lt;br&gt;&lt;br&gt;Issue id: InvalidVectorPath&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/37008268"&gt;https://issuetracker.google.com/37008268&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCustomSplashScreen" defaultSeverity="WARNING" displayName="Application-defined Launch Screen" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Application-defined Launch Screen&lt;br&gt;&lt;br&gt;Starting in Android 12 (API 31+), the application's Launch Screen is provided by the system and the application should not create its own, otherwise the user will see two splashscreens. Please check the &lt;code&gt;SplashScreen&lt;/code&gt; class to check how the Splash Screen can be controlled and customized.&lt;br&gt;&lt;br&gt;Issue id: CustomSplashScreen&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/splash-screen"&gt;https://developer.android.com/guide/topics/ui/splash-screen&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMinSdkTooLow" defaultSeverity="WARNING" displayName="API Version Too Low" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;API Version Too Low&lt;br&gt;&lt;br&gt;The value of the &lt;code&gt;minSdkVersion&lt;/code&gt; property is too low and can be incremented without noticeably reducing the number of supported devices.&lt;br&gt;&lt;br&gt;Issue id: MinSdkTooLow&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotificationPermission" defaultSeverity="ERROR" displayName="Notifications Without Permission" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notifications Without Permission&lt;br&gt;&lt;br&gt;When targeting Android 13 and higher, posting permissions requires holding the runtime permission &lt;code&gt;android.permission.POST_NOTIFICATIONS&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: NotificationPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSupportAnnotationUsage" defaultSeverity="ERROR" displayName="Incorrect support annotation usage" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect support annotation usage&lt;br&gt;&lt;br&gt;This lint check makes sure that the support annotations (such as &lt;code&gt;@IntDef&lt;/code&gt; and &lt;code&gt;@ColorInt&lt;/code&gt;) are used correctly. For example, it's an error to specify an &lt;code&gt;@IntRange&lt;/code&gt; where the &lt;code&gt;from&lt;/code&gt; value is higher than the &lt;code&gt;to&lt;/code&gt; value.&lt;br&gt;&lt;br&gt;Issue id: SupportAnnotationUsage&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongConstant" defaultSeverity="ERROR" displayName="Incorrect constant" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect constant&lt;br&gt;&lt;br&gt;Ensures that when parameter in a method only allows a specific set of constants, calls obey those rules.&lt;br&gt;&lt;br&gt;Issue id: WrongConstant&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintValidRestrictions" defaultSeverity="ERROR" displayName="Invalid Restrictions Descriptor" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Restrictions Descriptor&lt;br&gt;&lt;br&gt;Ensures that an applications restrictions XML file is properly formed&lt;br&gt;&lt;br&gt;Issue id: ValidRestrictions&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/content/RestrictionsManager.html"&gt;https://developer.android.com/reference/android/content/RestrictionsManager.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingFirebaseInstanceTokenRefresh" defaultSeverity="WARNING" displayName="Missing Firebase Messaging Callback" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Firebase Messaging Callback&lt;br&gt;&lt;br&gt;Apps that use Firebase Cloud Messaging should implement the &lt;code&gt;FirebaseMessagingService#onNewToken()&lt;/code&gt; callback in order to observe token changes.&lt;br&gt;&lt;br&gt;Issue id: MissingFirebaseInstanceTokenRefresh&lt;br&gt;&lt;br&gt;&lt;a href="https://firebase.google.com/docs/cloud-messaging/android/client#monitor-token-generation"&gt;https://firebase.google.com/docs/cloud-messaging/android/client#monitor-token-generation&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGestureBackNavigation" defaultSeverity="WARNING" displayName="Usage of KeyEvent.KEYCODE_BACK" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Usage of KeyEvent.KEYCODE_BACK&lt;br&gt;&lt;br&gt;Starting in Android 13 (API 33+), the handling of back events is moving to an ahead-of-time callback model. Use &lt;code&gt;OnBackInvokedDispatcher.registerOnBackInvokedCallback(...)&lt;/code&gt; and &lt;code&gt;onBackInvokedCallback&lt;/code&gt; or AndroidX's &lt;code&gt;OnBackPressedDispatcher&lt;/code&gt; with an implemented &lt;code&gt;onBackPressedCallback&lt;/code&gt; to handle back gestures and key presses.&lt;br&gt;&lt;br&gt;Issue id: GestureBackNavigation&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/about/versions/13/features/predictive-back-gesture"&gt;https://developer.android.com/about/versions/13/features/predictive-back-gesture&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleGetter" defaultSeverity="ERROR" displayName="Gradle Implicit Getter Call" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Gradle Implicit Getter Call&lt;br&gt;&lt;br&gt;Gradle will let you replace specific constants in your build scripts with method calls, so you can for example dynamically compute a version string based on your current version control revision number, rather than hardcoding a number.&lt;br/&gt;
&lt;br/&gt;
When computing a version name, it's tempting to for example call the method to do that &lt;code&gt;getVersionName&lt;/code&gt;. However, when you put that method call inside the &lt;code&gt;defaultConfig&lt;/code&gt; block, you will actually be calling the Groovy getter for the &lt;code&gt;versionName&lt;/code&gt; property instead. Therefore, you need to name your method something which does not conflict with the existing implicit getters. Consider using &lt;code&gt;compute&lt;/code&gt; as a prefix instead of &lt;code&gt;get&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: GradleGetter&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintReferenceType" defaultSeverity="ERROR" displayName="Incorrect reference types" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect reference types&lt;br&gt;&lt;br&gt;When you generate a resource alias, the resource you are pointing to must be of the same type as the alias&lt;br&gt;&lt;br&gt;Issue id: ReferenceType&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidAnalyticsName" defaultSeverity="ERROR" displayName="Invalid Analytics Name" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Analytics Name&lt;br&gt;&lt;br&gt;Event names and parameters must follow the naming conventions defined in the`FirebaseAnalytics#logEvent()` documentation.&lt;br&gt;&lt;br&gt;Issue id: InvalidAnalyticsName&lt;br&gt;&lt;br&gt;&lt;a href="https://firebase.google.com/docs/reference/android/com/google/firebase/analytics/FirebaseAnalytics#logEvent(java.lang.String,%20android.os.Bundle)"&gt;https://firebase.google.com/docs/reference/android/com/google/firebase/analytics/FirebaseAnalytics#logEvent(java.lang.String,%20android.os.Bundle)&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIllegalResourceRef" defaultSeverity="WARNING" displayName="Name and version must be integer or string, not resource" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Name and version must be integer or string, not resource&lt;br&gt;&lt;br&gt;For the &lt;code&gt;versionCode&lt;/code&gt; attribute, you have to specify an actual integer literal; you cannot use an indirection with a &lt;code&gt;@dimen/name&lt;/code&gt; resource. Similarly, the &lt;code&gt;versionName&lt;/code&gt; attribute should be an actual string, not a string resource url.&lt;br&gt;&lt;br&gt;Issue id: IllegalResourceRef&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOverride" defaultSeverity="ERROR" displayName="Method conflicts with new inherited method" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Method conflicts with new inherited method&lt;br&gt;&lt;br&gt;Suppose you are building against Android API 8, and you've subclassed Activity. In your subclass you add a new method called &lt;code&gt;isDestroyed&lt;/code&gt;(). At some later point, a method of the same name and signature is added to Android. Your method will now override the Android method, and possibly break its contract. Your method is not calling &lt;code&gt;super.isDestroyed()&lt;/code&gt;, since your compilation target doesn't know about the method.&lt;br/&gt;
&lt;br/&gt;
The above scenario is what this lint detector looks for. The above example is real, since &lt;code&gt;isDestroyed()&lt;/code&gt; was added in API 17, but it will be true for &lt;b&gt;any&lt;/b&gt; method you have added to a subclass of an Android class where your build target is lower than the version the method was introduced in.&lt;br/&gt;
&lt;br/&gt;
To fix this, either rename your method, or if you are really trying to augment the builtin method if available, switch to a higher build target where you can deliberately add &lt;code&gt;@Override&lt;/code&gt; on your overriding method, and call &lt;code&gt;super&lt;/code&gt; if appropriate etc.&lt;br&gt;&lt;br&gt;Issue id: Override&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNestedScrolling" defaultSeverity="WARNING" displayName="Nested scrolling widgets" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Nested scrolling widgets&lt;br&gt;&lt;br&gt;A scrolling widget such as a &lt;code&gt;ScrollView&lt;/code&gt; should not contain any nested scrolling widgets since this has various usability issues&lt;br&gt;&lt;br&gt;Issue id: NestedScrolling&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMutatingSharedPrefs" defaultSeverity="WARNING" displayName="Mutating an Immutable SharedPrefs Set" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mutating an Immutable SharedPrefs Set&lt;br&gt;&lt;br&gt;As stated in the docs for &lt;code&gt;SharedPreferences.getStringSet&lt;/code&gt;, you must not modify the set returned by &lt;code&gt;getStringSet&lt;/code&gt;:&lt;br/&gt;
&lt;br/&gt;
  "Note that you &amp;lt;em&gt;must not&amp;lt;/em&gt; modify the set instance returned    by this call.  The consistency of the stored data is not guaranteed    if you do, nor is your ability to modify the instance at all."&lt;br&gt;&lt;br&gt;Issue id: MutatingSharedPrefs&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintValidActionsXml" defaultSeverity="ERROR" displayName="Invalid Action Descriptor" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid Action Descriptor&lt;br&gt;&lt;br&gt;Ensures that an actions XML file is properly formed&lt;br&gt;&lt;br&gt;Issue id: ValidActionsXml&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSuspicious0dp" defaultSeverity="ERROR" displayName="Suspicious 0dp dimension" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious 0dp dimension&lt;br&gt;&lt;br&gt;Using 0dp as the width in a horizontal &lt;code&gt;LinearLayout&lt;/code&gt; with weights is a useful trick to ensure that only the weights (and not the intrinsic sizes) are used when sizing the children.&lt;br/&gt;
&lt;br/&gt;
However, if you use 0dp for the opposite dimension, the view will be invisible. This can happen if you change the orientation of a layout without also flipping the &lt;code&gt;0dp&lt;/code&gt; dimension in all the children.&lt;br&gt;&lt;br&gt;Issue id: Suspicious0dp&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingMediaBrowserServiceIntentFilter" defaultSeverity="ERROR" displayName="Missing MediaBrowserService intent-filter" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing MediaBrowserService intent-filter&lt;br&gt;&lt;br&gt;An Automotive Media App requires an exported service that extends &lt;code&gt;android.service.media.MediaBrowserService&lt;/code&gt; with an &lt;code&gt;intent-filter&lt;/code&gt; for the action &lt;code&gt;android.media.browse.MediaBrowserService&lt;/code&gt; to be able to browse and play media.&lt;br/&gt;
&lt;br/&gt;
To do this, add
&lt;pre&gt;
`&amp;lt;intent-filter&gt;`
    `&amp;lt;action android:name="android.media.browse.MediaBrowserService" /&gt;`
`&amp;lt;/intent-filter&gt;`
&lt;/pre&gt;
to the service that extends &lt;code&gt;android.service.media.MediaBrowserService&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: MissingMediaBrowserServiceIntentFilter&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/auto/audio/index.html#config_manifest"&gt;https://developer.android.com/training/auto/audio/index.html#config_manifest&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHalfFloat" defaultSeverity="ERROR" displayName="Incorrect Half Float" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect Half Float&lt;br&gt;&lt;br&gt;Half-precision floating point are stored in a short data type, and should be manipulated using the &lt;code&gt;android.util.Half&lt;/code&gt; class. This check flags usages where it appears that these values are used incorrectly.&lt;br&gt;&lt;br&gt;Issue id: HalfFloat&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintApplySharedPref" defaultSeverity="WARNING" displayName="Use apply() on SharedPreferences" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use &lt;code&gt;apply()&lt;/code&gt; on &lt;code&gt;SharedPreferences&lt;/code&gt;&lt;br&gt;&lt;br&gt;Consider using &lt;code&gt;apply()&lt;/code&gt; instead of &lt;code&gt;commit&lt;/code&gt; on shared preferences. Whereas &lt;code&gt;commit&lt;/code&gt; blocks and writes its data to persistent storage immediately, &lt;code&gt;apply&lt;/code&gt; will handle it in the background.&lt;br&gt;&lt;br&gt;Issue id: ApplySharedPref&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppCompatCustomView" defaultSeverity="ERROR" displayName="Appcompat Custom Widgets" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Appcompat Custom Widgets&lt;br&gt;&lt;br&gt;In order to support features such as tinting, the appcompat library will automatically load special appcompat replacements for the builtin widgets. However, this does not work for your own custom views.&lt;br/&gt;
&lt;br/&gt;
Instead of extending the &lt;code&gt;android.widget&lt;/code&gt; classes directly, you should instead extend one of the delegate classes in &lt;code&gt;androidx.appcompat.widget.AppCompatTextView&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AppCompatCustomView&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingConstraints" defaultSeverity="ERROR" displayName="Missing Constraints in ConstraintLayout" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Constraints in ConstraintLayout&lt;br&gt;&lt;br&gt;The layout editor allows you to place widgets anywhere on the canvas, and it records the current position with designtime attributes (such as &lt;code&gt;layout_editor_absoluteX&lt;/code&gt;). These attributes are &lt;b&gt;not&lt;/b&gt; applied at runtime, so if you push your layout on a device, the widgets may appear in a different location than shown in the editor. To fix this, make sure a widget has both horizontal and vertical constraints by dragging from the edge connections.&lt;br&gt;&lt;br&gt;Issue id: MissingConstraints&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsupportedChromeOsCameraSystemFeature" defaultSeverity="WARNING" displayName="Looking for Rear Camera only feature" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Looking for Rear Camera only feature&lt;br&gt;&lt;br&gt;You should look for the &lt;code&gt;FEATURE_CAMERA_ANY&lt;/code&gt; features to include all possible cameras that may be on the device. Looking for &lt;code&gt;FEATURE_CAMERA&lt;/code&gt; only looks for a rear facing camera, which certain tablets or Chrome OS devices don't have, as well as newer device configurations and modes may place the device in a state where the rear camera is not available. To fix the issue, look for &lt;code&gt;FEATURE_CAMERA_ANY&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: UnsupportedChromeOsCameraSystemFeature&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResourceName" defaultSeverity="ERROR" displayName="Resource with Wrong Prefix" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Resource with Wrong Prefix&lt;br&gt;&lt;br&gt;In Gradle projects you can specify a resource prefix that all resources in the project must conform to. This makes it easier to ensure that you don't accidentally combine resources from different libraries, since they all end up in the same shared app namespace.&lt;br&gt;&lt;br&gt;Issue id: ResourceName&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringShouldBeInt" defaultSeverity="ERROR" displayName="String should be int" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;String should be int&lt;br&gt;&lt;br&gt;The properties &lt;code&gt;compileSdkVersion&lt;/code&gt;, &lt;code&gt;minSdkVersion&lt;/code&gt; and &lt;code&gt;targetSdkVersion&lt;/code&gt; are usually numbers, but can be strings when you are using an add-on (in the case of &lt;code&gt;compileSdkVersion&lt;/code&gt;) or a preview platform (for the other two properties).&lt;br/&gt;
&lt;br/&gt;
However, you can not use a number as a string (e.g. "19" instead of 19); that will result in a platform not found error message at build/sync time.&lt;br&gt;&lt;br&gt;Issue id: StringShouldBeInt&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInconsistentArrays" defaultSeverity="WARNING" displayName="Inconsistencies in array element counts" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Inconsistencies in array element counts&lt;br&gt;&lt;br&gt;When an array is translated in a different locale, it should normally have the same number of elements as the original array. When adding or removing elements to an array, it is easy to forget to update all the locales, and this lint warning finds inconsistencies like these.&lt;br/&gt;
&lt;br/&gt;
Note however that there may be cases where you really want to declare a different number of array items in each configuration (for example where the array represents available options, and those options differ for different layout orientations and so on), so use your own judgment to decide if this is really an error.&lt;br/&gt;
&lt;br/&gt;
You can suppress this error type if it finds false errors in your project.&lt;br&gt;&lt;br&gt;Issue id: InconsistentArrays&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintShortAlarm" defaultSeverity="WARNING" displayName="Short or Frequent Alarm" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Short or Frequent Alarm&lt;br&gt;&lt;br&gt;Frequent alarms are bad for battery life. As of API 22, the &lt;code&gt;AlarmManager&lt;/code&gt; will override near-future and high-frequency alarm requests, delaying the alarm at least 5 seconds into the future and ensuring that the repeat interval is at least 60 seconds.&lt;br/&gt;
&lt;br/&gt;
If you really need to do work sooner than 5 seconds, post a delayed message or runnable to a Handler.&lt;br&gt;&lt;br&gt;Issue id: ShortAlarm&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearStandaloneAppFlag" defaultSeverity="WARNING" displayName="Invalid or missing Wear standalone app flag" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid or missing Wear standalone app flag&lt;br&gt;&lt;br&gt;Wearable apps should specify whether they can work standalone, without a phone app. Add a valid meta-data entry for &lt;code&gt;com.google.android.wearable.standalone&lt;/code&gt; to your application element and set the value to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.
&lt;pre&gt;
&amp;lt;meta-data android:name="com.google.android.wearable.standalone"
           android:value="true"/&gt;`
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;Issue id: WearStandaloneAppFlag&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/apps/packaging.html"&gt;https://developer.android.com/training/wearables/apps/packaging.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCanvasSize" defaultSeverity="WARNING" displayName="Wrong Canvas Size" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Canvas Size&lt;br&gt;&lt;br&gt;In a custom view's draw implementation, you should normally call &lt;code&gt;getWidth&lt;/code&gt; and &lt;code&gt;getHeight&lt;/code&gt; on the custom view itself, not on the &lt;code&gt;canvas&lt;/code&gt; instance.&lt;br/&gt;
&lt;br/&gt;
Canvas width and height are the width and height of the &lt;code&gt;Canvas&lt;/code&gt;, which is not always the same as size of the view.&lt;br/&gt;
&lt;br/&gt;
In the hardware accelerated path the width and height of the canvas typically always match that of the &lt;code&gt;View&lt;/code&gt; because every view goes to its own recorded &lt;code&gt;DisplayList&lt;/code&gt;. But in software rendering there's just one canvas that is clipped and transformed as it makes its way through the &lt;code&gt;View&lt;/code&gt; tree, and otherwise remains the same &lt;code&gt;Canvas&lt;/code&gt; object for every View's draw method.&lt;br/&gt;
&lt;br/&gt;
You should only use Canvas state to adjust how much you draw, such as a quick-reject for early work avoidance if it's going to be clipped away, but not what you draw.&lt;br&gt;&lt;br&gt;Issue id: CanvasSize&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPropertyEscape" defaultSeverity="ERROR" displayName="Incorrect property escapes" enabled="true" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect property escapes&lt;br&gt;&lt;br&gt;All backslashes and colons in .property files must be escaped with a backslash (). This means that when writing a Windows path, you must escape the file separators, so the path MyFiles should be written as &lt;code&gt;key=\\My\\Files.&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: PropertyEscape&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintJcenterRepositoryObsolete" defaultSeverity="WARNING" displayName="JCenter Repository Obsolete" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;JCenter Maven repository is read-only&lt;br&gt;&lt;br&gt;The JCenter Maven repository is no longer accepting submissions of Maven artifacts since 31st March 2021.  Ensure that the project is configured to search in repositories with the latest versions of its dependencies.&lt;br&gt;&lt;br&gt;Issue id: JcenterRepositoryObsolete&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/r/tools/jcenter-end-of-service"&gt;https://developer.android.com/r/tools/jcenter-end-of-service&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnlocalizedSms" defaultSeverity="WARNING" displayName="SMS phone number missing country code" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;SMS phone number missing country code&lt;br&gt;&lt;br&gt;SMS destination numbers must start with a country code or the application code must ensure that the SMS is only sent when the user is in the same country as the receiver.&lt;br&gt;&lt;br&gt;Issue id: UnlocalizedSms&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintValidFragment" defaultSeverity="ERROR" displayName="Fragment not instantiatable" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Fragment not instantiatable&lt;br&gt;&lt;br&gt;From the Fragment documentation:&lt;br/&gt;
&lt;b&gt;Every&lt;/b&gt; fragment must have an empty constructor, so it can be instantiated when restoring its activity's state. It is strongly recommended that subclasses do not have other constructors with parameters, since these constructors will not be called when the fragment is re-instantiated; instead, arguments can be supplied by the caller with &lt;code&gt;setArguments(Bundle)&lt;/code&gt; and later retrieved by the Fragment with &lt;code&gt;getArguments()&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Note that this is no longer true when you are using &lt;code&gt;androidx.fragment.app.Fragment&lt;/code&gt;; with the &lt;code&gt;FragmentFactory&lt;/code&gt; you can supply any arguments you want (as of version androidx version 1.1).&lt;br&gt;&lt;br&gt;Issue id: ValidFragment&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/app/Fragment.html#Fragment()"&gt;https://developer.android.com/reference/android/app/Fragment.html#Fragment()&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidUsesTagAttribute" defaultSeverity="ERROR" displayName="Invalid name attribute for uses element" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid &lt;code&gt;name&lt;/code&gt; attribute for &lt;code&gt;uses&lt;/code&gt; element&lt;br&gt;&lt;br&gt;The &amp;lt;uses&gt; element in &lt;code&gt;&amp;lt;automotiveApp&gt;&lt;/code&gt; should contain a valid value for the &lt;code&gt;name&lt;/code&gt; attribute. Valid values are &lt;code&gt;media&lt;/code&gt;, &lt;code&gt;notification&lt;/code&gt;, or &lt;code&gt;sms&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidUsesTagAttribute&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/auto/start/index.html#auto-metadata"&gt;https://developer.android.com/training/auto/start/index.html#auto-metadata&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintManifestResource" defaultSeverity="ERROR" displayName="Manifest Resource References" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Manifest Resource References&lt;br&gt;&lt;br&gt;Elements in the manifest can reference resources, but those resources cannot vary across configurations (except as a special case, by version, and except for a few specific package attributes such as the application title and icon).&lt;br&gt;&lt;br&gt;Issue id: ManifestResource&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRegistered" defaultSeverity="WARNING" displayName="Class is not registered in the manifest" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Class is not registered in the manifest&lt;br&gt;&lt;br&gt;Activities, services and content providers should be registered in the &lt;code&gt;AndroidManifest.xml&lt;/code&gt; file using &lt;code&gt;&amp;lt;activity&gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;service&gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;provider&gt;&lt;/code&gt; tags.&lt;br/&gt;
&lt;br/&gt;
If your activity is simply a parent class intended to be subclassed by other "real" activities, make it an abstract class.&lt;br&gt;&lt;br&gt;Issue id: Registered&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/manifest-intro.html"&gt;https://developer.android.com/guide/topics/manifest/manifest-intro.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMultipleUsesSdk" defaultSeverity="ERROR" displayName="Multiple &lt;uses-sdk&gt; elements in the manifest" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Multiple &lt;code&gt;&amp;lt;uses-sdk&gt;&lt;/code&gt; elements in the manifest&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-sdk&gt;&lt;/code&gt; element should appear just once; the tools will &lt;b&gt;not&lt;/b&gt; merge the contents of all the elements so if you split up the attributes across multiple elements, only one of them will take effect. To fix this, just merge all the attributes from the various elements into a single &amp;lt;uses-sdk&gt; element.&lt;br&gt;&lt;br&gt;Issue id: MultipleUsesSdk&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html"&gt;https://developer.android.com/guide/topics/manifest/uses-sdk-element.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateUsesFeature" defaultSeverity="WARNING" displayName="Feature declared more than once" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Feature declared more than once&lt;br&gt;&lt;br&gt;A given feature should only be declared once in the manifest.&lt;br&gt;&lt;br&gt;Issue id: DuplicateUsesFeature&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExtraText" defaultSeverity="ERROR" displayName="Extraneous text in resource files" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Extraneous text in resource files&lt;br&gt;&lt;br&gt;Non-value resource files should only contain elements and attributes. Any XML text content found in the file is likely accidental (and potentially dangerous if the text resembles XML and the developer believes the text to be functional).&lt;br&gt;&lt;br&gt;Issue id: ExtraText&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMangledCRLF" defaultSeverity="ERROR" displayName="Mangled file line endings" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mangled file line endings&lt;br&gt;&lt;br&gt;On Windows, line endings are typically recorded as carriage return plus newline: \r\n.&lt;br/&gt;
&lt;br/&gt;
This detector looks for invalid line endings with repeated carriage return characters (without newlines). Previous versions of the ADT plugin could accidentally introduce these into the file, and when editing the file, the editor could produce confusing visual artifacts.&lt;br&gt;&lt;br&gt;Issue id: MangledCRLF&lt;br&gt;&lt;br&gt;&lt;a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=375421"&gt;https://bugs.eclipse.org/bugs/show_bug.cgi?id=375421&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongCase" defaultSeverity="ERROR" displayName="Wrong case for view tag" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong case for view tag&lt;br&gt;&lt;br&gt;Most layout tags, such as &lt;code&gt;&amp;lt;Button&gt;&lt;/code&gt;, refer to actual view classes and are therefore capitalized. However, there are exceptions such as &lt;code&gt;&amp;lt;fragment&gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;include&gt;&lt;/code&gt;. This lint check looks for incorrect capitalizations.&lt;br&gt;&lt;br&gt;Issue id: WrongCase&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/fragments.html"&gt;https://developer.android.com/guide/components/fragments.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongThreadInterprocedural" defaultSeverity="ERROR" displayName="Wrong Thread (Interprocedural)" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Thread (Interprocedural)&lt;br&gt;&lt;br&gt;Searches for interprocedural call paths that violate thread annotations in the program. Tracks the flow of instantiated types and lambda expressions to increase accuracy across method boundaries.&lt;br&gt;&lt;br&gt;Issue id: WrongThreadInterprocedural&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/processes-and-threads.html#Threads"&gt;https://developer.android.com/guide/components/processes-and-threads.html#Threads&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingLeanbackSupport" defaultSeverity="ERROR" displayName="Missing Leanback Support" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Leanback Support&lt;br&gt;&lt;br&gt;The manifest should declare the use of the Leanback user interface required by Android TV.&lt;br/&gt;
&lt;br/&gt;
To fix this, add
&lt;pre&gt;
`&amp;lt;uses-feature android:name="android.software.leanback"
               android:required="false" /&gt;`
&lt;/pre&gt;
to your manifest.&lt;br&gt;&lt;br&gt;Issue id: MissingLeanbackSupport&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/tv/start/start.html#leanback-req"&gt;https://developer.android.com/training/tv/start/start.html#leanback-req&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLeanbackUsesWifi" defaultSeverity="WARNING" displayName="android.hardware.wifi on TV device" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using android.hardware.wifi on TV&lt;br&gt;&lt;br&gt;WiFi is not required for Android TV and many devices connect to the internet via alternative methods e.g. Ethernet.&lt;br/&gt;
&lt;br/&gt;
If your app is not focused specifically on WiFi functionality and only wishes to connect to the internet, please modify your Manifest to contain: &lt;code&gt;&amp;lt;uses-feature android:name="android.hardware.wifi" android:required="false" /&gt;&lt;/code&gt;&lt;br/&gt;
&lt;br/&gt;
Un-metered or non-roaming connections can be detected in software using &lt;code&gt;NetworkCapabilities#NET_CAPABILITY_NOT_METERED&lt;/code&gt; and &lt;code&gt;NetworkCapabilities#NET_CAPABILITY_NOT_ROAMING.&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: LeanbackUsesWifi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDataBindingWithoutKapt" defaultSeverity="WARNING" displayName="Data Binding without Annotation Processing" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Data Binding without Annotation Processing&lt;br&gt;&lt;br&gt;Apps that use Kotlin and data binding should also apply the kotlin-kapt plugin.&lt;br&gt;&lt;br&gt;Issue id: DataBindingWithoutKapt&lt;br&gt;&lt;br&gt;&lt;a href="https://kotlinlang.org/docs/reference/kapt.html"&gt;https://kotlinlang.org/docs/reference/kapt.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLibraryCustomView" defaultSeverity="ERROR" displayName="Custom views in libraries should use res-auto-namespace" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Custom views in libraries should use res-auto-namespace&lt;br&gt;&lt;br&gt;When using a custom view with custom attributes in a library project, the layout must use the special namespace &lt;a href="http://schemas.android.com/apk/res-auto"&gt;http://schemas.android.com/apk/res-auto&lt;/a&gt; instead of a URI which includes the library project's own package. This will be used to automatically adjust the namespace of the attributes when the library resources are merged into the application project.&lt;br&gt;&lt;br&gt;Issue id: LibraryCustomView&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTextViewEdits" defaultSeverity="WARNING" displayName="TextView should probably be an EditText instead" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TextView should probably be an EditText instead&lt;br&gt;&lt;br&gt;Using a &lt;code&gt;&amp;lt;TextView&gt;&lt;/code&gt; to input text is generally an error, you should be using &lt;code&gt;&amp;lt;EditText&gt;&lt;/code&gt; instead.  &lt;code&gt;EditText&lt;/code&gt; is a subclass of &lt;code&gt;TextView&lt;/code&gt;, and some of the editing support is provided by &lt;code&gt;TextView&lt;/code&gt;, so it's possible to set some input-related properties on a &lt;code&gt;TextView&lt;/code&gt;. However, using a &lt;code&gt;TextView&lt;/code&gt; along with input attributes is usually a cut &amp;amp; paste error. To input text you should be using &lt;code&gt;&amp;lt;EditText&gt;&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
This check also checks subclasses of &lt;code&gt;TextView&lt;/code&gt;, such as &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;CheckBox&lt;/code&gt;, since these have the same issue: they should not be used with editable attributes.&lt;br&gt;&lt;br&gt;Issue id: TextViewEdits&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGetLocales" defaultSeverity="ERROR" displayName="Locale crash" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Locale crash&lt;br&gt;&lt;br&gt;This check looks for usage of Lollipop-style locale folders (e.g. 3 letter language codes, or BCP 47 qualifiers) combined with an &lt;code&gt;AssetManager#getLocales()&lt;/code&gt; call. This leads to crashes&lt;br&gt;&lt;br&gt;Issue id: GetLocales&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintProguard" defaultSeverity="ERROR" displayName="Using obsolete ProGuard configuration" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using obsolete ProGuard configuration&lt;br&gt;&lt;br&gt;Using &lt;code&gt;-keepclasseswithmembernames&lt;/code&gt; in a proguard config file is not correct; it can cause some symbols to be renamed which should not be.&lt;br/&gt;
&lt;br/&gt;
Earlier versions of ADT used to create proguard.cfg files with the wrong format. Instead of &lt;code&gt;-keepclasseswithmembernames&lt;/code&gt; use &lt;code&gt;-keepclasseswithmembers&lt;/code&gt;, since the old flags also implies "allow shrinking" which means symbols only referred to from XML and not Java (such as possibly CustomViews) can get deleted.&lt;br&gt;&lt;br&gt;Issue id: Proguard&lt;br&gt;&lt;br&gt;&lt;a href="https://issuetracker.google.com/36928077"&gt;https://issuetracker.google.com/36928077&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongFolder" defaultSeverity="ERROR" displayName="Resource file in the wrong res folder" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Resource file in the wrong &lt;code&gt;res&lt;/code&gt; folder&lt;br&gt;&lt;br&gt;Resource files are sometimes placed in the wrong folder, and it can lead to subtle bugs that are hard to understand. This check looks for problems in this area, such as attempting to place a layout "alias" file in a &lt;code&gt;layout/&lt;/code&gt; folder rather than the &lt;code&gt;values/&lt;/code&gt; folder where it belongs.&lt;br&gt;&lt;br&gt;Issue id: WrongFolder&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSpUsage" defaultSeverity="WARNING" displayName="Using dp instead of sp for text sizes" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;dp&lt;/code&gt; instead of &lt;code&gt;sp&lt;/code&gt; for text sizes&lt;br&gt;&lt;br&gt;When setting text sizes, you should normally use &lt;code&gt;sp&lt;/code&gt;, or "scale-independent pixels". This is like the &lt;code&gt;dp&lt;/code&gt; unit, but it is also scaled by the user's font size preference. It is recommend you use this unit when specifying font sizes, so they will be adjusted for both the screen density and the user's preference.&lt;br/&gt;
&lt;br/&gt;
There &lt;b&gt;are&lt;/b&gt; cases where you might need to use &lt;code&gt;dp&lt;/code&gt;; typically this happens when the text is in a container with a specific dp-size. This will prevent the text from spilling outside the container. Note however that this means that the user's font size settings are not respected, so consider adjusting the layout itself to be more flexible.&lt;br&gt;&lt;br&gt;Issue id: SpUsage&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/multiscreen/screendensities.html"&gt;https://developer.android.com/training/multiscreen/screendensities.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleOverrides" defaultSeverity="WARNING" displayName="Value overridden by Gradle build script" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Value overridden by Gradle build script&lt;br&gt;&lt;br&gt;The value of (for example) &lt;code&gt;minSdkVersion&lt;/code&gt; is only used if it is not specified in the &lt;code&gt;build.gradle&lt;/code&gt; build scripts. When specified in the Gradle build scripts, the manifest value is ignored and can be misleading, so should be removed to avoid ambiguity.&lt;br&gt;&lt;br&gt;Issue id: GradleOverrides&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPendingBindings" defaultSeverity="ERROR" displayName="Missing Pending Bindings" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Pending Bindings&lt;br&gt;&lt;br&gt;When using a &lt;code&gt;ViewDataBinding&lt;/code&gt; in a &lt;code&gt;onBindViewHolder&lt;/code&gt; method, you &lt;b&gt;must&lt;/b&gt; call &lt;code&gt;executePendingBindings()&lt;/code&gt; before the method exits; otherwise the data binding runtime will update the UI in the next animation frame causing a delayed update and potential jumps if the item resizes.&lt;br&gt;&lt;br&gt;Issue id: PendingBindings&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongCall" defaultSeverity="ERROR" displayName="Using wrong draw/layout method" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using wrong draw/layout method&lt;br&gt;&lt;br&gt;Custom views typically need to call &lt;code&gt;measure()&lt;/code&gt; on their children, not &lt;code&gt;onMeasure&lt;/code&gt;. Ditto for onDraw, onLayout, etc.&lt;br&gt;&lt;br&gt;Issue id: WrongCall&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResourceType" defaultSeverity="ERROR" displayName="Wrong Resource Type" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong Resource Type&lt;br&gt;&lt;br&gt;Ensures that resource id's passed to APIs are of the right type; for example, calling &lt;code&gt;Resources.getColor(R.string.name)&lt;/code&gt; is wrong.&lt;br&gt;&lt;br&gt;Issue id: ResourceType&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBottomAppBar" defaultSeverity="ERROR" displayName="BottomAppBar Problems" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;BottomAppBar Problems&lt;br&gt;&lt;br&gt;The &lt;code&gt;BottomAppBar&lt;/code&gt; widget must be placed within a &lt;code&gt;CoordinatorLayout&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: BottomAppBar&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHighAppVersionCode" defaultSeverity="ERROR" displayName="VersionCode too high" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;VersionCode too high&lt;br&gt;&lt;br&gt;The declared &lt;code&gt;versionCode&lt;/code&gt; is an Integer. Ensure that the version number is not close to the limit. It is recommended to monotonically increase this number each minor or major release of the app. Note that updating an app with a versionCode over &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; is not possible.&lt;br&gt;&lt;br&gt;Issue id: HighAppVersionCode&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/studio/publish/versioning.html"&gt;https://developer.android.com/studio/publish/versioning.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintManifestOrder" defaultSeverity="WARNING" displayName="Incorrect order of elements in manifest" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect order of elements in manifest&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;application&gt;&lt;/code&gt; tag should appear after the elements which declare which version you need, which features you need, which libraries you need, and so on. In the past there have been subtle bugs (such as themes not getting applied correctly) when the &lt;code&gt;&amp;lt;application&gt;&lt;/code&gt; tag appears before some of these other elements, so it's best to order your manifest in the logical dependency order.&lt;br&gt;&lt;br&gt;Issue id: ManifestOrder&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNetworkSecurityConfig" defaultSeverity="ERROR" displayName="Valid Network Security Config File" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Valid Network Security Config File&lt;br&gt;&lt;br&gt;Ensures that a &lt;code&gt;&amp;lt;network-security-config&gt;&lt;/code&gt; file, which is pointed to by an &lt;code&gt;android:networkSecurityConfig&lt;/code&gt; attribute in the manifest file, is valid&lt;br&gt;&lt;br&gt;Issue id: NetworkSecurityConfig&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/features/security-config.html"&gt;https://developer.android.com/preview/features/security-config.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRequiresFeature" defaultSeverity="WARNING" displayName="Requires Feature" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Requires Feature&lt;br&gt;&lt;br&gt;Some APIs require optional features to be present. This check makes sure that calls to these APIs are surrounded by a check which enforces this.&lt;br&gt;&lt;br&gt;Issue id: RequiresFeature&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAdapterViewChildren" defaultSeverity="WARNING" displayName="AdapterView cannot have children in XML" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;AdapterView&lt;/code&gt; cannot have children in XML&lt;br&gt;&lt;br&gt;An &lt;code&gt;AdapterView&lt;/code&gt; such as a `ListView`s must be configured with data from Java code, such as a &lt;code&gt;ListAdapter&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AdapterViewChildren&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/widget/AdapterView.html"&gt;https://developer.android.com/reference/android/widget/AdapterView.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRestrictedApi" defaultSeverity="ERROR" displayName="Restricted API" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Restricted API&lt;br&gt;&lt;br&gt;This API has been flagged with a restriction that has not been met.&lt;br/&gt;
&lt;br/&gt;
Examples of API restrictions:&lt;br/&gt;
* Method can only be invoked by a subclass&lt;br/&gt;
* Method can only be accessed from within the same library (defined by the Gradle library group id)&lt;br/&gt;
* Method can only be accessed from tests.&lt;br/&gt;
&lt;br/&gt;
You can add your own API restrictions with the &lt;code&gt;@RestrictTo&lt;/code&gt; annotation.&lt;br&gt;&lt;br&gt;Issue id: RestrictedApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingOnPlayFromSearch" defaultSeverity="ERROR" displayName="Missing onPlayFromSearch." enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;onPlayFromSearch&lt;/code&gt;&lt;br&gt;&lt;br&gt;To support voice searches on Android Auto, in addition to adding an &lt;code&gt;intent-filter&lt;/code&gt; for the action &lt;code&gt;onPlayFromSearch&lt;/code&gt;, you also need to override and implement &lt;code&gt;onPlayFromSearch(String query, Bundle bundle)&lt;/code&gt;&lt;br&gt;&lt;br&gt;Issue id: MissingOnPlayFromSearch&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/auto/audio/index.html#support_voice"&gt;https://developer.android.com/training/auto/audio/index.html#support_voice&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleDynamicVersion" defaultSeverity="WARNING" displayName="Gradle Dynamic Version" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Gradle Dynamic Version&lt;br&gt;&lt;br&gt;Using &lt;code&gt;+&lt;/code&gt; in dependencies lets you automatically pick up the latest available version rather than a specific, named version. However, this is not recommended; your builds are not repeatable; you may have tested with a slightly different version than what the build server used. (Using a dynamic version as the major version number is more problematic than using it in the minor version position.)&lt;br&gt;&lt;br&gt;Issue id: GradleDynamicVersion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBatteryLife" defaultSeverity="WARNING" displayName="Battery Life Issues" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Battery Life Issues&lt;br&gt;&lt;br&gt;This issue flags code that either&lt;br/&gt;
* negatively affects battery life, or&lt;br/&gt;
* uses APIs that have recently changed behavior to prevent background tasks from consuming memory and battery excessively.&lt;br/&gt;
&lt;br/&gt;
Generally, you should be using &lt;code&gt;WorkManager&lt;/code&gt; instead.&lt;br/&gt;
&lt;br/&gt;
For more details on how to update your code, please see &lt;a href="https://developer.android.com/topic/performance/background-optimization"&gt;https://developer.android.com/topic/performance/background-optimization&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: BatteryLife&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseAlpha2" defaultSeverity="WARNING" displayName="Using 3-letter Codes" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using 3-letter Codes&lt;br&gt;&lt;br&gt;For compatibility with earlier devices, you should only use 3-letter language and region codes when there is no corresponding 2 letter code.&lt;br&gt;&lt;br&gt;Issue id: UseAlpha2&lt;br&gt;&lt;br&gt;&lt;a href="https://tools.ietf.org/html/bcp47"&gt;https://tools.ietf.org/html/bcp47&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDiscouragedApi" defaultSeverity="WARNING" displayName="Using discouraged APIs" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using discouraged APIs&lt;br&gt;&lt;br&gt;Discouraged APIs are allowed and are not deprecated, but they may be unfit for common use (e.g. due to slow performance or subtle behavior).&lt;br&gt;&lt;br&gt;Issue id: DiscouragedApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintResAuto" defaultSeverity="ERROR" displayName="Hardcoded Package in Namespace" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardcoded Package in Namespace&lt;br&gt;&lt;br&gt;In Gradle projects, the actual package used in the final APK can vary; for example,you can add a &lt;code&gt;.debug&lt;/code&gt; package suffix in one version and not the other. Therefore, you should &lt;b&gt;not&lt;/b&gt; hardcode the application package in the resource; instead, use the special namespace &lt;code&gt;http://schemas.android.com/apk/res-auto&lt;/code&gt; which will cause the tools to figure out the right namespace for the resource regardless of the actual package used during the build.&lt;br&gt;&lt;br&gt;Issue id: ResAuto&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintObjectAnimatorBinding" defaultSeverity="ERROR" displayName="Incorrect ObjectAnimator Property" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect ObjectAnimator Property&lt;br&gt;&lt;br&gt;This check cross references properties referenced by String from &lt;code&gt;ObjectAnimator&lt;/code&gt; and &lt;code&gt;PropertyValuesHolder&lt;/code&gt; method calls and ensures that the corresponding setter methods exist and have the right signatures.&lt;br&gt;&lt;br&gt;Issue id: ObjectAnimatorBinding&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidId" defaultSeverity="ERROR" displayName="Invalid ID declaration" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid ID declaration&lt;br&gt;&lt;br&gt;An id definition &lt;b&gt;must&lt;/b&gt; be of the form &lt;code&gt;@+id/yourname&lt;/code&gt;. The tools have not rejected strings of the form &lt;code&gt;@+foo/bar&lt;/code&gt; in the past, but that was an error, and could lead to tricky errors because of the way the id integers are assigned.&lt;br/&gt;
&lt;br/&gt;
If you really want to have different "scopes" for your id's, use prefixes instead, such as &lt;code&gt;login_button1&lt;/code&gt; and &lt;code&gt;login_button2&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotInterpolated" defaultSeverity="ERROR" displayName="Incorrect Interpolation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incorrect Interpolation&lt;br&gt;&lt;br&gt;To insert the value of a variable, you can use &lt;code&gt;${variable}&lt;/code&gt; inside a string literal, but &lt;b&gt;only&lt;/b&gt; if you are using double quotes!&lt;br&gt;&lt;br&gt;Issue id: NotInterpolated&lt;br&gt;&lt;br&gt;&lt;a href="https://www.groovy-lang.org/syntax.html#_string_interpolation"&gt;https://www.groovy-lang.org/syntax.html#_string_interpolation&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingPrefix" defaultSeverity="ERROR" displayName="Missing Android XML namespace" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Android XML namespace&lt;br&gt;&lt;br&gt;Most Android views have attributes in the Android namespace. When referencing these attributes you &lt;b&gt;must&lt;/b&gt; include the namespace prefix, or your attribute will be interpreted by &lt;code&gt;aapt&lt;/code&gt; as just a custom attribute.&lt;br/&gt;
&lt;br/&gt;
Similarly, in manifest files, nearly all attributes should be in the &lt;code&gt;android:&lt;/code&gt; namespace.&lt;br&gt;&lt;br&gt;Issue id: MissingPrefix&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingPermission" defaultSeverity="ERROR" displayName="Missing Permissions" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Permissions&lt;br&gt;&lt;br&gt;This check scans through your code and libraries and looks at the APIs being used, and checks this against the set of permissions required to access those APIs. If the code using those APIs is called at runtime, then the program will crash.&lt;br/&gt;
&lt;br/&gt;
Furthermore, for permissions that are revocable (with &lt;code&gt;targetSdkVersion&lt;/code&gt; 23), client code must also be prepared to handle the calls throwing an exception if the user rejects the request for permission at runtime.&lt;br&gt;&lt;br&gt;Issue id: MissingPermission&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInlinedApi" defaultSeverity="WARNING" displayName="Using inlined constants on older versions" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using inlined constants on older versions&lt;br&gt;&lt;br&gt;This check scans through all the Android API field references in the application and flags certain constants, such as static final integers and Strings, which were introduced in later versions. These will actually be copied into the class files rather than being referenced, which means that the value is available even when running on older devices. In some cases that's fine, and in other cases it can result in a runtime crash or incorrect behavior. It depends on the context, so consider the code carefully and decide whether it's safe and can be suppressed or whether the code needs to be guarded.&lt;br/&gt;
&lt;br/&gt;
If you really want to use this API and don't need to support older devices just set the &lt;code&gt;minSdkVersion&lt;/code&gt; in your &lt;code&gt;build.gradle&lt;/code&gt; or &lt;code&gt;AndroidManifest.xml&lt;/code&gt; files.&lt;br/&gt;
&lt;br/&gt;
If your code is &lt;b&gt;deliberately&lt;/b&gt; accessing newer APIs, and you have ensured (e.g. with conditional execution) that this code will only ever be called on a supported platform, then you can annotate your class or method with the &lt;code&gt;@TargetApi&lt;/code&gt; annotation specifying the local minimum SDK to apply, such as &lt;code&gt;@TargetApi(11)&lt;/code&gt;, such that this check considers 11 rather than your manifest file's minimum SDK as the required API level.&lt;br&gt;&lt;br&gt;Issue id: InlinedApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradleCompatible" defaultSeverity="ERROR" displayName="Incompatible Gradle Versions" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incompatible Gradle Versions&lt;br&gt;&lt;br&gt;There are some combinations of libraries, or tools and libraries, that are incompatible, or can lead to bugs. One such incompatibility is compiling with a version of the Android support libraries that is not the latest version (or in particular, a version lower than your &lt;code&gt;targetSdkVersion&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: GradleCompatible&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnsupportedTvHardware" defaultSeverity="ERROR" displayName="Unsupported TV Hardware Feature" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unsupported TV Hardware Feature&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-feature&gt;&lt;/code&gt; element should not require this unsupported TV hardware feature. Any uses-feature not explicitly marked with &lt;code&gt;required="false"&lt;/code&gt; is necessary on the device to be installed on. Ensure that any features that might prevent it from being installed on a TV device are reviewed and marked as not required in the manifest.&lt;br&gt;&lt;br&gt;Issue id: UnsupportedTvHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/tv/start/hardware.html#unsupported-features"&gt;https://developer.android.com/training/tv/start/hardware.html#unsupported-features&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintShiftFlags" defaultSeverity="WARNING" displayName="Dangerous Flag Constant Declaration" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Dangerous Flag Constant Declaration&lt;br&gt;&lt;br&gt;When defining multiple constants for use in flags, the recommended style is to use the form &lt;code&gt;1 &amp;lt;&amp;lt; 2&lt;/code&gt;, &lt;code&gt;1 &amp;lt;&amp;lt; 3&lt;/code&gt;, &lt;code&gt;1 &amp;lt;&amp;lt; 4&lt;/code&gt; and so on to ensure that the constants are unique and non-overlapping.&lt;br&gt;&lt;br&gt;Issue id: ShiftFlags&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAccidentalOctal" defaultSeverity="ERROR" displayName="Accidental Octal" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Accidental Octal&lt;br&gt;&lt;br&gt;In Groovy, an integer literal that starts with a leading 0 will be interpreted as an octal number. That is usually (always?) an accident and can lead to subtle bugs, for example when used in the &lt;code&gt;versionCode&lt;/code&gt; of an app.&lt;br&gt;&lt;br&gt;Issue id: AccidentalOctal&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOpenForTesting" defaultSeverity="ERROR" displayName="Extending API only allowed from tests" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Extending API only allowed from tests&lt;br&gt;&lt;br&gt;Classes or methods annotated with &lt;code&gt;@OpenForTesting&lt;/code&gt; are only allowed to be subclassed or overridden from unit tests.&lt;br&gt;&lt;br&gt;Issue id: OpenForTesting&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintJobSchedulerService" defaultSeverity="WARNING" displayName="JobScheduler problems" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;JobScheduler problems&lt;br&gt;&lt;br&gt;This check looks for various common mistakes in using the JobScheduler API: the service class must extend &lt;code&gt;JobService&lt;/code&gt;, the service must be registered in the manifest and the registration must require the permission &lt;code&gt;android.permission.BIND_JOB_SERVICE&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: JobSchedulerService&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/performance/scheduling.html"&gt;https://developer.android.com/topic/performance/scheduling.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPinSetExpiry" defaultSeverity="WARNING" displayName="Validate &lt;pin-set&gt; expiration attribute" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Validate &lt;code&gt;&amp;lt;pin-set&gt;&lt;/code&gt; expiration attribute&lt;br&gt;&lt;br&gt;Ensures that the &lt;code&gt;expiration&lt;/code&gt; attribute of the &lt;code&gt;&amp;lt;pin-set&gt;&lt;/code&gt; element is valid and has not already expired or is expiring soon&lt;br&gt;&lt;br&gt;Issue id: PinSetExpiry&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/features/security-config.html"&gt;https://developer.android.com/preview/features/security-config.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongRegion" defaultSeverity="WARNING" displayName="Suspicious Language/Region Combination" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious Language/Region Combination&lt;br&gt;&lt;br&gt;Android uses the letter codes ISO 639-1 for languages, and the letter codes ISO 3166-1 for the region codes. In many cases, the language code and the country where the language is spoken is the same, but it is also often not the case. For example, while 'se' refers to Sweden, where Swedish is spoken, the language code for Swedish is &lt;b&gt;not&lt;/b&gt; &lt;code&gt;se&lt;/code&gt; (which refers to the Northern Sami language), the language code is &lt;code&gt;sv&lt;/code&gt;. And similarly the region code for &lt;code&gt;sv&lt;/code&gt; is El Salvador.&lt;br/&gt;
&lt;br/&gt;
This lint check looks for suspicious language and region combinations, to help catch cases where you've accidentally used the wrong language or region code. Lint knows about the most common regions where a language is spoken, and if a folder combination is not one of these, it is flagged as suspicious.&lt;br/&gt;
&lt;br/&gt;
Note however that it may not be an error: you can theoretically have speakers of any language in any region and want to target that with your resources, so this check is aimed at tracking down likely mistakes, not to enforce a specific set of region and language combinations.&lt;br&gt;&lt;br&gt;Issue id: WrongRegion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInvalidImeActionId" defaultSeverity="ERROR" displayName="Invalid imeActionId declaration" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalid imeActionId declaration&lt;br&gt;&lt;br&gt;&lt;code&gt;android:imeActionId&lt;/code&gt; should not be a resource ID such as &lt;code&gt;@+id/resName&lt;/code&gt;. It must be an integer constant, or an integer resource reference, as defined in &lt;code&gt;EditorInfo&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: InvalidImeActionId&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/view/inputmethod/EditorInfo.html"&gt;https://developer.android.com/reference/android/view/inputmethod/EditorInfo.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAaptCrash" defaultSeverity="ERROR" displayName="Potential AAPT crash" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Potential AAPT crash&lt;br&gt;&lt;br&gt;Defining a style which sets &lt;code&gt;android:id&lt;/code&gt; to a dynamically generated id can cause many versions of &lt;code&gt;aapt&lt;/code&gt;, the resource packaging tool, to crash. To work around this, declare the id explicitly with &lt;code&gt;&amp;lt;item type="id" name="..." /&gt;&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: AaptCrash&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPrivateApi" defaultSeverity="WARNING" displayName="Using Private APIs" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Private APIs&lt;br&gt;&lt;br&gt;Using reflection to access hidden/private Android APIs is not safe; it will often not work on devices from other vendors, and it may suddenly stop working (if the API is removed) or crash spectacularly (if the API behavior changes, since there are no guarantees for compatibility).&lt;br&gt;&lt;br&gt;Issue id: PrivateApi&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces"&gt;https://developer.android.com/preview/restrictions-non-sdk-interfaces&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLocaleFolder" defaultSeverity="WARNING" displayName="Wrong locale name" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wrong locale name&lt;br&gt;&lt;br&gt;From the &lt;code&gt;java.util.Locale&lt;/code&gt; documentation:&lt;br/&gt;
"Note that Java uses several deprecated two-letter codes. The Hebrew ("he") language code is rewritten as "iw", Indonesian ("id") as "in", and Yiddish ("yi") as "ji". This rewriting happens even if you construct your own Locale object, not just for instances returned by the various lookup methods.&lt;br/&gt;
&lt;br/&gt;
Because of this, if you add your localized resources in for example &lt;code&gt;values-he&lt;/code&gt; they will not be used, since the system will look for &lt;code&gt;values-iw&lt;/code&gt; instead.&lt;br/&gt;
&lt;br/&gt;
To work around this, place your resources in a &lt;code&gt;values&lt;/code&gt; folder using the deprecated language code instead.&lt;br&gt;&lt;br&gt;Issue id: LocaleFolder&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/util/Locale.html"&gt;https://developer.android.com/reference/java/util/Locale.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingIntentFilterForMediaSearch" defaultSeverity="ERROR" displayName="Missing MEDIA_PLAY_FROM_SEARCH intent-filter" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing MEDIA_PLAY_FROM_SEARCH intent-filter&lt;br&gt;&lt;br&gt;To support voice searches on Android Auto, you should also register an &lt;code&gt;intent-filter&lt;/code&gt; for the action &lt;code&gt;android.media.action.MEDIA_PLAY_FROM_SEARCH&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
To do this, add
&lt;pre&gt;
`&amp;lt;intent-filter&gt;`
    `&amp;lt;action android:name="android.media.action.MEDIA_PLAY_FROM_SEARCH" /&gt;`
`&amp;lt;/intent-filter&gt;`
&lt;/pre&gt;
to your &lt;code&gt;&amp;lt;activity&gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;service&gt;&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: MissingIntentFilterForMediaSearch&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/auto/audio/index.html#support_voice"&gt;https://developer.android.com/training/auto/audio/index.html#support_voice&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingBackupPin" defaultSeverity="WARNING" displayName="Missing Backup Pin" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Backup Pin&lt;br&gt;&lt;br&gt;It is highly recommended to declare a backup &lt;code&gt;&amp;lt;pin&gt;&lt;/code&gt; element. Not having a second pin defined can cause connection failures when the particular site certificate is rotated and the app has not yet been updated.&lt;br&gt;&lt;br&gt;Issue id: MissingBackupPin&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/features/security-config.html"&gt;https://developer.android.com/preview/features/security-config.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMotionSceneFileValidationError" defaultSeverity="ERROR" displayName="Validation errors in MotionScene files" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Validation errors in &lt;code&gt;MotionScene&lt;/code&gt; files&lt;br&gt;&lt;br&gt;A motion scene file specifies the animations used in a &lt;code&gt;MotionLayout&lt;/code&gt;. This check performs various serious correctness checks in a motion scene file.&lt;br&gt;&lt;br&gt;Issue id: MotionSceneFileValidationError&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnknownIdInLayout" defaultSeverity="WARNING" displayName="Reference to an id that is not in the current layout" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Reference to an id that is not in the current layout&lt;br&gt;&lt;br&gt;The &lt;code&gt;@+id/&lt;/code&gt; syntax refers to an existing id, or creates a new one if it has not already been defined elsewhere. However, this means that if you have a typo in your reference, or if the referred view no longer exists, you do not get a warning since the id will be created on demand.&lt;br/&gt;
&lt;br/&gt;
This is sometimes intentional, for example where you are referring to a view which is provided in a different layout via an include. However, it is usually an accident where you have a typo or you have renamed a view without updating all the references to it.&lt;br&gt;&lt;br&gt;Issue id: UnknownIdInLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSdCardPath" defaultSeverity="WARNING" displayName="Hardcoded reference to /sdcard" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardcoded reference to &lt;code&gt;/sdcard&lt;/code&gt;&lt;br&gt;&lt;br&gt;Your code should not reference the &lt;code&gt;/sdcard&lt;/code&gt; path directly; instead use &lt;code&gt;Environment.getExternalStorageDirectory().getPath()&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Similarly, do not reference the &lt;code&gt;/data/data/&lt;/code&gt; path directly; it can vary in multi-user scenarios. Instead, use &lt;code&gt;Context.getFilesDir().getPath()&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: SdCardPath&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/data-storage#filesExternal"&gt;https://developer.android.com/training/data-storage#filesExternal&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTranslucentOrientation" defaultSeverity="WARNING" displayName="Mixing screenOrientation and translucency" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mixing screenOrientation and translucency&lt;br&gt;&lt;br&gt;Specifying a fixed screen orientation with a translucent theme isn't supported on apps with &lt;code&gt;targetSdkVersion&lt;/code&gt; O or greater since there can be an another activity visible behind your activity with a conflicting request.&lt;br/&gt;
&lt;br/&gt;
For example, your activity requests landscape and the visible activity behind your translucent activity request portrait. In this case the system can only honor one of the requests and currently prefers to honor the request from non-translucent activities since there is nothing visible behind them.&lt;br/&gt;
&lt;br/&gt;
Devices running platform version O or greater will throw an exception in your app if this state is detected.&lt;br&gt;&lt;br&gt;Issue id: TranslucentOrientation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInOrMmUsage" defaultSeverity="WARNING" displayName="Using mm or in dimensions" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;mm&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; dimensions&lt;br&gt;&lt;br&gt;Avoid using &lt;code&gt;mm&lt;/code&gt; (millimeters) or &lt;code&gt;in&lt;/code&gt; (inches) as the unit for dimensions.&lt;br/&gt;
&lt;br/&gt;
While it should work in principle, unfortunately many devices do not report the correct true physical density, which means that the dimension calculations won't work correctly. You are better off using &lt;code&gt;dp&lt;/code&gt; (and for font sizes, &lt;code&gt;sp&lt;/code&gt;).&lt;br&gt;&lt;br&gt;Issue id: InOrMmUsage&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIntentFilterUniqueDataAttributes" defaultSeverity="WARNING" displayName="Data tags should only declare unique attributes" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Data tags should only declare unique attributes&lt;br&gt;&lt;br&gt;&lt;code&gt;&amp;lt;intent-filter&gt;&lt;/code&gt; &lt;code&gt;&amp;lt;data&gt;&lt;/code&gt; tags should only declare a single unique attribute (i.e. scheme OR host, but not both). This better matches the runtime behavior of intent filters, as they combine all of the declared data attributes into a single matcher which is allowed to handle any combination across attribute types.&lt;br/&gt;
&lt;br/&gt;
For example, the following two &lt;code&gt;&amp;lt;intent-filter&gt;&lt;/code&gt; declarations are the same:
&lt;pre&gt;
&amp;lt;intent-filter&gt;
    &amp;lt;data android:scheme="http" android:host="example.com" /&gt;
    &amp;lt;data android:scheme="https" android:host="example.org" /&gt;
&amp;lt;/intent-filter&gt;
&lt;/pre&gt;

&lt;pre&gt;
&amp;lt;intent-filter&gt;
    &amp;lt;data android:scheme="http"/&gt;
    &amp;lt;data android:scheme="https"/&gt;
    &amp;lt;data android:host="example.com" /&gt;
    &amp;lt;data android:host="example.org" /&gt;
&amp;lt;/intent-filter&gt;
&lt;/pre&gt;
&lt;br/&gt;
They both handle all of the following:&lt;br/&gt;
* &lt;a href="http://example.com"&gt;http://example.com&lt;/a&gt;&lt;br/&gt;
* &lt;a href="https://example.com"&gt;https://example.com&lt;/a&gt;&lt;br/&gt;
* &lt;a href="http://example.org"&gt;http://example.org&lt;/a&gt;&lt;br/&gt;
* &lt;a href="https://example.org"&gt;https://example.org&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
The second one better communicates the combining behavior and is clearer to an external reader that one should not rely on the scheme/host being self contained. It is not obvious in the first that &lt;a href="http://example.org"&gt;http://example.org&lt;/a&gt; is also matched, which can lead to confusion (or incorrect behavior) with a more complex set of schemes/hosts.&lt;br/&gt;
&lt;br/&gt;
Note that this does not apply to host + port, as those must be declared in the same &lt;code&gt;&amp;lt;data&gt;&lt;/code&gt; tag and are only associated with each other.&lt;br&gt;&lt;br&gt;Issue id: IntentFilterUniqueDataAttributes&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/intents-filters"&gt;https://developer.android.com/guide/components/intents-filters&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWrongViewCast" defaultSeverity="ERROR" displayName="Mismatched view type" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mismatched view type&lt;br&gt;&lt;br&gt;Keeps track of the view types associated with ids and if it finds a usage of the id in the Java code it ensures that it is treated as the same type.&lt;br&gt;&lt;br&gt;Issue id: WrongViewCast&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLocalSuppress" defaultSeverity="ERROR" displayName="@SuppressLint on invalid element" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;@SuppressLint on invalid element&lt;br&gt;&lt;br&gt;The &lt;code&gt;@SuppressAnnotation&lt;/code&gt; is used to suppress Lint warnings in Java files. However, while many lint checks analyzes the Java source code, where they can find annotations on (for example) local variables, some checks are analyzing the &lt;code&gt;.class&lt;/code&gt; files. And in class files, annotations only appear on classes, fields and methods. Annotations placed on local variables disappear. If you attempt to suppress a lint error for a class-file based lint check, the suppress annotation not work. You must move the annotation out to the surrounding method.&lt;br&gt;&lt;br&gt;Issue id: LocalSuppress&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintVectorRaster" defaultSeverity="WARNING" displayName="Vector Image Generation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Vector Image Generation&lt;br&gt;&lt;br&gt;Vector icons require API 21 or API 24 depending on used features, but when &lt;code&gt;minSdkVersion&lt;/code&gt; is less than 21 or 24 and Android Gradle plugin 1.4 or higher is used, a vector drawable placed in the &lt;code&gt;drawable&lt;/code&gt; folder is automatically moved to &lt;code&gt;drawable-anydpi-v21&lt;/code&gt; or &lt;code&gt;drawable-anydpi-v24&lt;/code&gt; and bitmap images are generated for different screen resolutions for backwards compatibility.&lt;br/&gt;
&lt;br/&gt;
However, there are some limitations to this raster image generation, and this lint check flags elements and attributes that are not fully supported. You should manually check whether the generated output is acceptable for those older devices.&lt;br&gt;&lt;br&gt;Issue id: VectorRaster&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateDefinition" defaultSeverity="ERROR" displayName="Duplicate definitions of resources" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Duplicate definitions of resources&lt;br&gt;&lt;br&gt;You can define a resource multiple times in different resource folders; that's how string translations are done, for example. However, defining the same resource more than once in the same resource folder is likely an error, for example attempting to add a new resource without realizing that the name is already used, and so on.&lt;br&gt;&lt;br&gt;Issue id: DuplicateDefinition&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWifiManagerLeak" defaultSeverity="ERROR" displayName="WifiManager Leak" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WifiManager Leak&lt;br&gt;&lt;br&gt;On versions prior to Android N (24), initializing the &lt;code&gt;WifiManager&lt;/code&gt; via &lt;code&gt;Context#getSystemService&lt;/code&gt; can cause a memory leak if the context is not the application context. Change &lt;code&gt;context.getSystemService(...)&lt;/code&gt; to &lt;code&gt;context.getApplicationContext().getSystemService(...)&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: WifiManagerLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintQueryPermissionsNeeded" defaultSeverity="WARNING" displayName="Using APIs affected by query permissions" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using APIs affected by query permissions&lt;br&gt;&lt;br&gt;Apps that target Android 11 cannot query or interact with other installed apps by default. If you need to query or interact with other installed apps, you may need to add a &lt;code&gt;&amp;lt;queries&gt;&lt;/code&gt; declaration in your manifest.&lt;br/&gt;
&lt;br/&gt;
As a corollary, the methods &lt;code&gt;PackageManager#getInstalledPackages&lt;/code&gt; and &lt;code&gt;PackageManager#getInstalledApplications&lt;/code&gt; will no longer return information about all installed apps. To query specific apps or types of apps, you can use methods like &lt;code&gt;PackageManager#getPackageInfo&lt;/code&gt; or &lt;code&gt;PackageManager#queryIntentActivities&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: QueryPermissionsNeeded&lt;br&gt;&lt;br&gt;&lt;a href="https://g.co/dev/packagevisibility"&gt;https://g.co/dev/packagevisibility&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCoarseFineLocation" defaultSeverity="ERROR" displayName="android.permission.ACCESS_COARSE_LOCATION is also required" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Cannot use &lt;code&gt;ACCESS_FINE_LOCATION&lt;/code&gt; without &lt;code&gt;ACCESS_COARSE_LOCATION&lt;/code&gt;&lt;br&gt;&lt;br&gt;If your app requires access to FINE location, on Android 12 and higher you must now request both FINE and COARSE. Users will have the option to grant only COARSE location. Ensure your app can work with just COARSE location.&lt;br&gt;&lt;br&gt;Issue id: CoarseFineLocation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWatchFaceEditor" defaultSeverity="WARNING" displayName="Watch face editor with incorrect launchMode" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Watch face editor must use launchMode="standard"&lt;br&gt;&lt;br&gt;Watch face editor activities must be able to launch in the Wear OS app activity task in order to work correctly. Thus only &lt;code&gt;launchMode="standard"&lt;/code&gt; is allowed. The watch face will not be shown on the watch if it does not satisfy this requirement.&lt;br&gt;&lt;br&gt;Issue id: WatchFaceEditor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingId" defaultSeverity="WARNING" displayName="Fragments should specify an id or tag" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Fragments should specify an &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;tag&lt;/code&gt;&lt;br&gt;&lt;br&gt;If you do not specify an &lt;code&gt;android:id&lt;/code&gt; or an &lt;code&gt;android:tag&lt;/code&gt; attribute on a &lt;code&gt;&amp;lt;fragment&gt;&lt;/code&gt; element, then if the activity is restarted (for example for an orientation rotation) you may lose state. From the fragment documentation:&lt;br/&gt;
&lt;br/&gt;
"Each fragment requires a unique identifier that the system can use to restore the fragment if the activity is restarted (and which you can use to capture the fragment to perform transactions, such as remove it).&lt;br/&gt;
&lt;br/&gt;
* Supply the &lt;code&gt;android:id&lt;/code&gt; attribute with a unique ID.&lt;br/&gt;
* Supply the &lt;code&gt;android:tag&lt;/code&gt; attribute with a unique string.&lt;br/&gt;
&lt;br/&gt;
If you provide neither of the previous two, the system uses the ID of the container view.&lt;br&gt;&lt;br&gt;Issue id: MissingId&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/components/fragments.html"&gt;https://developer.android.com/guide/components/fragments.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintViewBindingType" defaultSeverity="ERROR" displayName="tools:viewBindingType issues" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;tools:viewBindingType&lt;/code&gt; issues&lt;br&gt;&lt;br&gt;All issues related to using the View Binding &lt;code&gt;tools:viewBindingType&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: ViewBindingType&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintIntentReset" defaultSeverity="WARNING" displayName="Suspicious mix of setType and setData" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious mix of &lt;code&gt;setType&lt;/code&gt; and &lt;code&gt;setData&lt;/code&gt;&lt;br&gt;&lt;br&gt;Intent provides the following APIs: &lt;code&gt;setData(Uri)&lt;/code&gt; and &lt;code&gt;setType(String)&lt;/code&gt;. Unfortunately, setting one clears the other. If you want to set both, you should call &lt;code&gt;setDataAndType(Uri, String)&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: IntentReset&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearableConfigurationAction" defaultSeverity="WARNING" displayName="Wear configuration action metadata must match an activity" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Wear configuration action metadata must match an activity&lt;br&gt;&lt;br&gt;Only when a watch face service defines &lt;code&gt;wearableConfigurationAction&lt;/code&gt; metadata, with the value &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt;, there should be an activity in the same package, which has an intent filter for &lt;code&gt;WATCH_FACE_EDITOR&lt;/code&gt; (with &lt;code&gt;com.google.android.wearable.watchface.category.WEARABLE_CONFIGURATION&lt;/code&gt; if &lt;code&gt;minSdkVersion&lt;/code&gt; is less than 30).&lt;br&gt;&lt;br&gt;Issue id: WearableConfigurationAction&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/wearables/watch-faces/configuration"&gt;https://developer.android.com/training/wearables/watch-faces/configuration&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppCompatMethod" defaultSeverity="WARNING" displayName="Using Wrong AppCompat Method" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Wrong AppCompat Method&lt;br&gt;&lt;br&gt;When using the appcompat library, there are some methods you should be calling instead of the normal ones; for example, &lt;code&gt;getSupportActionBar()&lt;/code&gt; instead of &lt;code&gt;getActionBar()&lt;/code&gt;. This lint check looks for calls to the wrong method.&lt;br&gt;&lt;br&gt;Issue id: AppCompatMethod&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/libraries/support-library/"&gt;https://developer.android.com/topic/libraries/support-library/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInnerclassSeparator" defaultSeverity="WARNING" displayName="Inner classes should use $ rather than ." enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Inner classes should use &lt;code&gt;$&lt;/code&gt; rather than &lt;code&gt;.&lt;/code&gt;&lt;br&gt;&lt;br&gt;When you reference an inner class in a manifest file, you must use '$' instead of '.' as the separator character, i.e. Outer$Inner instead of Outer.Inner.&lt;br/&gt;
&lt;br/&gt;
(If you get this warning for a class which is not actually an inner class, it's because you are using uppercase characters in your package name, which is not conventional.)&lt;br&gt;&lt;br&gt;Issue id: InnerclassSeparator&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintShowToast" defaultSeverity="WARNING" displayName="Toast created but not shown" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Toast created but not shown&lt;br&gt;&lt;br&gt;&lt;code&gt;Toast.makeText()&lt;/code&gt; creates a &lt;code&gt;Toast&lt;/code&gt; but does &lt;b&gt;not&lt;/b&gt; show it. You must call &lt;code&gt;show()&lt;/code&gt; on the resulting object to actually make the &lt;code&gt;Toast&lt;/code&gt; appear.&lt;br&gt;&lt;br&gt;Issue id: ShowToast&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotificationIconCompatibility" defaultSeverity="WARNING" displayName="Notification Icon Compatibility" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notification Icon Compatibility&lt;br&gt;&lt;br&gt;Notification icons should define a raster image to support Android versions below 5.0 (API 21). Note that the way Lint decides whether an icon is a notification icon is based on the filename prefix &lt;code&gt;ic_stat_&lt;/code&gt;. This corresponds to the naming convention documented in &lt;a href="https://material.io/design/iconography/"&gt;https://material.io/design/iconography/&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: NotificationIconCompatibility&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBlockedPrivateApi" defaultSeverity="ERROR" displayName="Using Blocked Private API" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using Blocked Private API&lt;br&gt;&lt;br&gt;Usage of restricted non-SDK interface is forbidden for this targetSDK. Accessing non-SDK methods or fields through reflection has a high likelihood to break your app between versions, and is being restricted to facilitate future app compatibility.&lt;br&gt;&lt;br&gt;Issue id: BlockedPrivateApi&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/preview/restrictions-non-sdk-interfaces"&gt;https://developer.android.com/preview/restrictions-non-sdk-interfaces&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDeprecatedSinceApi" defaultSeverity="WARNING" displayName="Using a method deprecated in earlier SDK" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using a method deprecated in earlier SDK&lt;br&gt;&lt;br&gt;Some backport methods are only necessary until a specific version of Android. These have been annotated with &lt;code&gt;@DeprecatedSinceApi&lt;/code&gt;, specifying the relevant API level and replacement suggestions. Calling these methods when the &lt;code&gt;minSdkVersion&lt;/code&gt; is already at the deprecated API level or above is unnecessary.&lt;br&gt;&lt;br&gt;Issue id: DeprecatedSinceApi&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppLinksAutoVerify" defaultSeverity="ERROR" displayName="App Links Auto Verification Failure" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;App Links Auto Verification Failure&lt;br&gt;&lt;br&gt;Ensures that app links are correctly set and associated with website.&lt;br&gt;&lt;br&gt;Issue id: AppLinksAutoVerify&lt;br&gt;&lt;br&gt;&lt;a href="https://g.co/appindexing/applinks"&gt;https://g.co/appindexing/applinks&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLockedOrientationActivity" defaultSeverity="WARNING" displayName="Incompatible screenOrientation manifest value" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Incompatible screenOrientation value&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;activity&gt;&lt;/code&gt; element should not be locked to any orientation so that users can take advantage of the multi-window environments and larger screens available on Android. To fix the issue, consider declaring the corresponding activity element with `screenOrientation="unspecified"&lt;code&gt;or &lt;/code&gt;"fullSensor"` attribute.&lt;br&gt;&lt;br&gt;Issue id: LockedOrientationActivity&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/topic/arc/window-management"&gt;https://developer.android.com/topic/arc/window-management&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNewerVersionAvailable" defaultSeverity="WARNING" displayName="Newer Library Versions Available" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Newer Library Versions Available&lt;br&gt;&lt;br&gt;This detector checks with a central repository to see if there are newer versions available for the dependencies used by this project. This is similar to the &lt;code&gt;GradleDependency&lt;/code&gt; check, which checks for newer versions available in the Android SDK tools and libraries, but this works with any MavenCentral dependency, and connects to the library every time, which makes it more flexible but also &lt;b&gt;much&lt;/b&gt; slower.&lt;br&gt;&lt;br&gt;Issue id: NewerVersionAvailable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNonConstantResourceId" defaultSeverity="WARNING" displayName="Checks use of resource IDs in places requiring constants." enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Checks use of resource IDs in places requiring constants&lt;br&gt;&lt;br&gt;Avoid the usage of resource IDs where constant expressions are required.&lt;br/&gt;
&lt;br/&gt;
A future version of the Android Gradle Plugin will generate R classes with non-constant IDs in order to improve the performance of incremental compilation.&lt;br&gt;&lt;br&gt;Issue id: NonConstantResourceId&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintProtectedPermissions" defaultSeverity="ERROR" displayName="Using system app permission" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using system app permission&lt;br&gt;&lt;br&gt;Permissions with the protection level &lt;code&gt;signature&lt;/code&gt;, &lt;code&gt;privileged&lt;/code&gt; or &lt;code&gt;signatureOrSystem&lt;/code&gt; are only granted to system apps. If an app is a regular non-system app, it will never be able to use these permissions.&lt;br&gt;&lt;br&gt;Issue id: ProtectedPermissions&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCustomViewStyleable" defaultSeverity="WARNING" displayName="Mismatched Styleable/Custom View Name" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Mismatched Styleable/Custom View Name&lt;br&gt;&lt;br&gt;The convention for custom views is to use a &lt;code&gt;declare-styleable&lt;/code&gt; whose name matches the custom view class name. The IDE relies on this convention such that for example code completion can be offered for attributes in a custom view in layout XML resource files.&lt;br/&gt;
&lt;br/&gt;
(Similarly, layout parameter classes should use the suffix &lt;code&gt;_Layout&lt;/code&gt;.)&lt;br&gt;&lt;br&gt;Issue id: CustomViewStyleable&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedAttribute" defaultSeverity="WARNING" displayName="Attribute unused on older versions" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Attribute unused on older versions&lt;br&gt;&lt;br&gt;This check finds attributes set in XML files that were introduced in a version newer than the oldest version targeted by your application (with the &lt;code&gt;minSdkVersion&lt;/code&gt; attribute).&lt;br/&gt;
&lt;br/&gt;
This is not an error; the application will simply ignore the attribute. However, if the attribute is important to the appearance or functionality of your application, you should consider finding an alternative way to achieve the same result with only available attributes, and then you can optionally create a copy of the layout in a layout-vNN folder which will be used on API NN or higher where you can take advantage of the newer attribute.&lt;br/&gt;
&lt;br/&gt;
Note: This check does not only apply to attributes. For example, some tags can be unused too, such as the new &lt;code&gt;&amp;lt;tag&gt;&lt;/code&gt; element in layouts introduced in API 21.&lt;br&gt;&lt;br&gt;Issue id: UnusedAttribute&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintPermissionImpliesUnsupportedHardware" defaultSeverity="WARNING" displayName="Permission Implies Unsupported Hardware" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Permission Implies Unsupported Hardware&lt;br&gt;&lt;br&gt;The &lt;code&gt;&amp;lt;uses-permission&gt;&lt;/code&gt; element should not require a permission that implies an unsupported TV hardware feature. Google Play assumes that certain hardware related permissions indicate that the underlying hardware features are required by default. To fix the issue, consider declaring the corresponding &lt;code&gt;uses-feature&lt;/code&gt; element with &lt;code&gt;required="false"&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: PermissionImpliesUnsupportedHardware&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions"&gt;https://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintParcelClassLoader" defaultSeverity="WARNING" displayName="Default Parcel Class Loader" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Default Parcel Class Loader&lt;br&gt;&lt;br&gt;The documentation for &lt;code&gt;Parcel#readParcelable(ClassLoader)&lt;/code&gt; (and its variations) says that you can pass in &lt;code&gt;null&lt;/code&gt; to pick up the default class loader. However, that ClassLoader is a system class loader and is not able to find classes in your own application.&lt;br/&gt;
&lt;br/&gt;
If you are writing your own classes into the &lt;code&gt;Parcel&lt;/code&gt; (not just SDK classes like &lt;code&gt;String&lt;/code&gt; and so on), then you should supply a &lt;code&gt;ClassLoader&lt;/code&gt; for your application instead; a simple way to obtain one is to just call &lt;code&gt;getClass().getClassLoader()&lt;/code&gt; from your own class.&lt;br&gt;&lt;br&gt;Issue id: ParcelClassLoader&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/android/os/Parcel.html"&gt;https://developer.android.com/reference/android/os/Parcel.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDefaultLocale" defaultSeverity="WARNING" displayName="Implied default locale in case conversion" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Implied default locale in case conversion&lt;br&gt;&lt;br&gt;Calling &lt;code&gt;String#toLowerCase()&lt;/code&gt; or &lt;code&gt;#toUpperCase()&lt;/code&gt; &lt;b&gt;without specifying an explicit locale&lt;/b&gt; is a common source of bugs. The reason for that is that those methods will use the current locale on the user's device, and even though the code appears to work correctly when you are developing the app, it will fail in some locales. For example, in the Turkish locale, the uppercase replacement for &lt;code&gt;i&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; &lt;code&gt;I&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If you want the methods to just perform ASCII replacement, for example to convert an enum name, call &lt;code&gt;String#toUpperCase(Locale.US)&lt;/code&gt; instead. If you really want to use the current locale, call &lt;code&gt;String#toUpperCase(Locale.getDefault())&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: DefaultLocale&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/reference/java/util/Locale.html#default_locale"&gt;https://developer.android.com/reference/java/util/Locale.html#default_locale&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintCommitTransaction" defaultSeverity="WARNING" displayName="Missing commit() calls" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;commit()&lt;/code&gt; calls&lt;br&gt;&lt;br&gt;After creating a &lt;code&gt;FragmentTransaction&lt;/code&gt;, you typically need to commit it as well&lt;br&gt;&lt;br&gt;Issue id: CommitTransaction&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGradlePath" defaultSeverity="WARNING" displayName="Gradle Path Issues" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Gradle Path Issues&lt;br&gt;&lt;br&gt;Gradle build scripts are meant to be cross platform, so file paths use Unix-style path separators (a forward slash) rather than Windows path separators (a backslash). Similarly, to keep projects portable and repeatable, avoid using absolute paths on the system; keep files within the project instead. To share code between projects, consider creating an android-library and an AAR dependency&lt;br&gt;&lt;br&gt;Issue id: GradlePath&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMissingLeanbackLauncher" defaultSeverity="ERROR" displayName="Missing Leanback Launcher Intent Filter" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing Leanback Launcher Intent Filter&lt;br&gt;&lt;br&gt;An application intended to run on TV devices must declare a launcher activity for TV in its manifest using a &lt;code&gt;android.intent.category.LEANBACK_LAUNCHER&lt;/code&gt; intent filter.&lt;br&gt;&lt;br&gt;Issue id: MissingLeanbackLauncher&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/tv/start/start.html#tv-activity"&gt;https://developer.android.com/training/tv/start/start.html#tv-activity&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSwitchIntDef" defaultSeverity="WARNING" displayName="Missing @IntDef in Switch" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing @IntDef in Switch&lt;br&gt;&lt;br&gt;This check warns if a &lt;code&gt;switch&lt;/code&gt; statement does not explicitly include all the values declared by the typedef &lt;code&gt;@IntDef&lt;/code&gt; declaration.&lt;br&gt;&lt;br&gt;Issue id: SwitchIntDef&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintGridLayout" defaultSeverity="ERROR" displayName="GridLayout validation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;GridLayout validation&lt;br&gt;&lt;br&gt;Declaring a layout_row or layout_column that falls outside the declared size of a GridLayout's &lt;code&gt;rowCount&lt;/code&gt; or &lt;code&gt;columnCount&lt;/code&gt; is usually an unintentional error.&lt;br&gt;&lt;br&gt;Issue id: GridLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintScopedStorage" defaultSeverity="WARNING" displayName="Affected by scoped storage" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Affected by scoped storage&lt;br&gt;&lt;br&gt;Scoped storage is enforced on Android 10+ (or Android 11+ if using &lt;code&gt;requestLegacyExternalStorage&lt;/code&gt;). In particular, &lt;code&gt;WRITE_EXTERNAL_STORAGE&lt;/code&gt; will no longer provide write access to all files; it will provide the equivalent of &lt;code&gt;READ_EXTERNAL_STORAGE&lt;/code&gt; instead.&lt;br/&gt;
&lt;br/&gt;
The &lt;code&gt;MANAGE_EXTERNAL_STORAGE&lt;/code&gt; permission can be used to manage all files, but it is rarely necessary and most apps on Google Play are not allowed to use it. Most apps should instead migrate to use scoped storage. To modify or delete files, apps should request write access from the user as described at &lt;a href="https://goo.gle/android-mediastore-createwriterequest"&gt;https://goo.gle/android-mediastore-createwriterequest&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
To learn more, read these resources: Play policy: &lt;a href="https://goo.gle/policy-storage-help"&gt;https://goo.gle/policy-storage-help&lt;/a&gt; Allowable use cases: &lt;a href="https://goo.gle/policy-storage-usecases"&gt;https://goo.gle/policy-storage-usecases&lt;/a&gt;&lt;br&gt;&lt;br&gt;Issue id: ScopedStorage&lt;br&gt;&lt;br&gt;&lt;a href="https://goo.gle/android-storage-usecases"&gt;https://goo.gle/android-storage-usecases&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSuspiciousImport" defaultSeverity="WARNING" displayName="'import android.R' statement" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;'&lt;code&gt;import android.R&lt;/code&gt;' statement&lt;br&gt;&lt;br&gt;Importing &lt;code&gt;android.R&lt;/code&gt; is usually not intentional; it sometimes happens when you use an IDE and ask it to automatically add imports at a time when your project's R class it not present.&lt;br/&gt;
&lt;br/&gt;
Once the import is there you might get a lot of "confusing" error messages because of course the fields available on &lt;code&gt;android.R&lt;/code&gt; are not the ones you'd expect from just looking at your own &lt;code&gt;R&lt;/code&gt; class.&lt;br&gt;&lt;br&gt;Issue id: SuspiciousImport&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSuspiciousIndentation" defaultSeverity="ERROR" displayName="Suspicious indentation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Suspicious indentation&lt;br&gt;&lt;br&gt;This check looks for cases where the indentation suggests a grouping that isn't actually there in the code. A common example of this would be something like
&lt;pre&gt;
if (column &gt; width)
    line++
    column = 0
&lt;/pre&gt;
Here, the &lt;code&gt;column = 0&lt;/code&gt; line will be executed every single time, not just if the condition is true.&lt;br&gt;&lt;br&gt;Issue id: SuspiciousIndentation&lt;br&gt;&lt;br&gt;Available options:&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;always-run&lt;/b&gt; (default is false):&lt;br/&gt;
Whether this check should be included while editing.&lt;br/&gt;
&lt;br/&gt;
While you're editing, it's common to have a temporary situation where you have suspicious indentation scenarios -- e.g. you start typing an &lt;code&gt;if&lt;/code&gt; statement on the line above something you want to make conditional, and you haven't indented it yet. It can be distracting and misleading to suddenly have both statements light up as errors. Therefore, lint will avoid including this check when running on the fly in the editor, unless it looks like the file has not been recently edited. With this option, you can turn it on in all cases.&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="SuspiciousIndentation"&gt;
        &amp;lt;option name="always-run" value="false" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWifiManagerPotentialLeak" defaultSeverity="WARNING" displayName="WifiManager Potential Leak" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;WifiManager Potential Leak&lt;br&gt;&lt;br&gt;On versions prior to Android N (24), initializing the &lt;code&gt;WifiManager&lt;/code&gt; via &lt;code&gt;Context#getSystemService&lt;/code&gt; can cause a memory leak if the context is not the application context.&lt;br/&gt;
&lt;br/&gt;
In many cases, it's not obvious from the code where the &lt;code&gt;Context&lt;/code&gt; is coming from (e.g. it might be a parameter to a method, or a field initialized from various method calls). It's possible that the context being passed in is the application context, but to be on the safe side, you should consider changing &lt;code&gt;context.getSystemService(...)&lt;/code&gt; to &lt;code&gt;context.getApplicationContext().getSystemService(...)&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: WifiManagerPotentialLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExifInterface" defaultSeverity="WARNING" displayName="Using android.media.ExifInterface" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using &lt;code&gt;android.media.ExifInterface&lt;/code&gt;&lt;br&gt;&lt;br&gt;The &lt;code&gt;android.media.ExifInterface&lt;/code&gt; implementation has some known security bugs in older versions of Android. There is a new implementation available of this library in the support library, which is preferable.&lt;br&gt;&lt;br&gt;Issue id: ExifInterface&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Android Lint: Usability" path="Android/Lint"><inspection shortName="AndroidLintNegativeMargin" defaultSeverity="WARNING" displayName="Negative Margins" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Negative Margins&lt;br&gt;&lt;br&gt;Margin values should be positive. Negative values are generally a sign that you are making assumptions about views surrounding the current one, or may be tempted to turn off child clipping to allow a view to escape its parent. Turning off child clipping to do this not only leads to poor graphical performance, it also results in wrong touch event handling since touch events are based strictly on a chain of parent-rect hit tests. Finally, making assumptions about the size of strings can lead to localization problems.&lt;br&gt;&lt;br&gt;Issue id: NegativeMargin&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintViewConstructor" defaultSeverity="WARNING" displayName="Missing View constructors for XML inflation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing View constructors for XML inflation&lt;br&gt;&lt;br&gt;Some layout tools (such as the Android layout editor) need to find a constructor with one of the following signatures:&lt;br/&gt;
* &lt;code&gt;View(Context context)&lt;/code&gt;&lt;br/&gt;
* &lt;code&gt;View(Context context, AttributeSet attrs)&lt;/code&gt;&lt;br/&gt;
* &lt;code&gt;View(Context context, AttributeSet attrs, int defStyle)&lt;/code&gt;&lt;br/&gt;
&lt;br/&gt;
If your custom view needs to perform initialization which does not apply when used in a layout editor, you can surround the given code with a check to see if &lt;code&gt;View#isInEditMode()&lt;/code&gt; is false, since that method will return &lt;code&gt;false&lt;/code&gt; at runtime but true within a user interface editor.&lt;br&gt;&lt;br&gt;Issue id: ViewConstructor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSelectableText" defaultSeverity="WARNING" displayName="Dynamic text should probably be selectable" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Dynamic text should probably be selectable&lt;br&gt;&lt;br&gt;If a &lt;code&gt;&amp;lt;TextView&gt;&lt;/code&gt; is used to display data, the user might want to copy that data and paste it elsewhere. To allow this, the &lt;code&gt;&amp;lt;TextView&gt;&lt;/code&gt; should specify &lt;code&gt;android:textIsSelectable="true"&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
This lint check looks for TextViews which are likely to be displaying data: views whose text is set dynamically.&lt;br&gt;&lt;br&gt;Issue id: SelectableText&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTextFields" defaultSeverity="WARNING" displayName="Missing inputType" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;inputType&lt;/code&gt;&lt;br&gt;&lt;br&gt;Providing an &lt;code&gt;inputType&lt;/code&gt; attribute on a text field improves usability because depending on the data to be input, optimized keyboards can be shown to the user (such as just digits and parentheses for a phone number). &lt;br/&gt;
&lt;br/&gt;
The lint detector also looks at the &lt;code&gt;id&lt;/code&gt; of the view, and if the id offers a hint of the purpose of the field (for example, the &lt;code&gt;id&lt;/code&gt; contains the phrase &lt;code&gt;phone&lt;/code&gt; or &lt;code&gt;email&lt;/code&gt;), then lint will also ensure that the &lt;code&gt;inputType&lt;/code&gt; contains the corresponding type attributes.&lt;br/&gt;
&lt;br/&gt;
If you really want to keep the text field generic, you can suppress this warning by setting &lt;code&gt;inputType="text"&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: TextFields&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAlwaysShowAction" defaultSeverity="WARNING" displayName="Usage of showAsAction=always" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Usage of &lt;code&gt;showAsAction=always&lt;/code&gt;&lt;br&gt;&lt;br&gt;Using &lt;code&gt;showAsAction="always"&lt;/code&gt; in menu XML, or &lt;code&gt;MenuItem.SHOW_AS_ACTION_ALWAYS&lt;/code&gt; in Java code is usually a deviation from the user interface style guide.Use &lt;code&gt;ifRoom&lt;/code&gt; or the corresponding &lt;code&gt;MenuItem.SHOW_AS_ACTION_IF_ROOM&lt;/code&gt; instead.&lt;br/&gt;
&lt;br/&gt;
If &lt;code&gt;always&lt;/code&gt; is used sparingly there are usually no problems and behavior is roughly equivalent to &lt;code&gt;ifRoom&lt;/code&gt; but with preference over other &lt;code&gt;ifRoom&lt;/code&gt; items. Using it more than twice in the same menu is a bad idea.&lt;br/&gt;
&lt;br/&gt;
This check looks for menu XML files that contain more than two &lt;code&gt;always&lt;/code&gt; actions, or some &lt;code&gt;always&lt;/code&gt; actions and no &lt;code&gt;ifRoom&lt;/code&gt; actions. In Java code, it looks for projects that contain references to &lt;code&gt;MenuItem.SHOW_AS_ACTION_ALWAYS&lt;/code&gt; and no references to &lt;code&gt;MenuItem.SHOW_AS_ACTION_IF_ROOM&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: AlwaysShowAction&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSmallSp" defaultSeverity="WARNING" displayName="Text size is too small" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Text size is too small&lt;br&gt;&lt;br&gt;Avoid using sizes smaller than 11sp.&lt;br&gt;&lt;br&gt;Issue id: SmallSp&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintButtonCase" defaultSeverity="WARNING" displayName="Cancel/OK dialog button capitalization" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Cancel/OK dialog button capitalization&lt;br&gt;&lt;br&gt;The standard capitalization for OK/Cancel dialogs is "OK" and "Cancel". To ensure that your dialogs use the standard strings, you can use the resource strings @android:string/ok and @android:string/cancel.&lt;br&gt;&lt;br&gt;Issue id: ButtonCase&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMenuTitle" defaultSeverity="ERROR" displayName="Missing menu title" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing menu title&lt;br&gt;&lt;br&gt;From the action bar documentation:&lt;br/&gt;
"It's important that you always define android:title for each menu item &amp;#8212; even if you don't declare that the title appear with the action item &amp;#8212; for three reasons:&lt;br/&gt;
&lt;br/&gt;
* If there's not enough room in the action bar for the action item, the menu item appears in the overflow menu and only the title appears.&lt;br/&gt;
* Screen readers for sight-impaired users read the menu item's title.&lt;br/&gt;
* If the action item appears with only the icon, a user can long-press the item to reveal a tool-tip that displays the action item's title.&lt;br/&gt;
&lt;br/&gt;
The android:icon is always optional, but recommended.&lt;br&gt;&lt;br&gt;Issue id: MenuTitle&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/training/appbar"&gt;https://developer.android.com/training/appbar&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAutofill" defaultSeverity="WARNING" displayName="Use Autofill" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use Autofill&lt;br&gt;&lt;br&gt;Specify an &lt;code&gt;autofillHints&lt;/code&gt; attribute when targeting SDK version 26 or higher or explicitly specify that the view is not important for autofill. Your app can help an autofill service classify the data correctly by providing the meaning of each view that could be autofillable, such as views representing usernames, passwords, credit card fields, email addresses, etc.&lt;br/&gt;
&lt;br/&gt;
The hints can have any value, but it is recommended to use predefined values like 'username' for a username or 'creditCardNumber' for a credit card number. For a list of all predefined autofill hint constants, see the &lt;code&gt;AUTOFILL_HINT_&lt;/code&gt; constants in the &lt;code&gt;View&lt;/code&gt; reference at &lt;a href="https://developer.android.com/reference/android/view/View.html"&gt;https://developer.android.com/reference/android/view/View.html&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
You can mark a view unimportant for autofill by specifying an &lt;code&gt;importantForAutofill&lt;/code&gt; attribute on that view or a parent view. See &lt;a href="https://developer.android.com/reference/android/view/View.html#setImportantForAutofill(int)"&gt;https://developer.android.com/reference/android/view/View.html#setImportantForAutofill(int)&lt;/a&gt;.&lt;br&gt;&lt;br&gt;Issue id: Autofill&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/text/autofill.html"&gt;https://developer.android.com/guide/topics/text/autofill.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintButtonStyle" defaultSeverity="WARNING" displayName="Button should be borderless" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Button should be borderless&lt;br&gt;&lt;br&gt;Button bars typically use a borderless style for the buttons. Set the &lt;code&gt;style="?android:attr/buttonBarButtonStyle"&lt;/code&gt; attribute on each of the buttons, and set &lt;code&gt;style="?android:attr/buttonBarStyle"&lt;/code&gt; on the parent layout&lt;br&gt;&lt;br&gt;Issue id: ButtonStyle&lt;br&gt;&lt;br&gt;&lt;a href="https://material.io/components/dialogs/"&gt;https://material.io/components/dialogs/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintButtonOrder" defaultSeverity="WARNING" displayName="Button order" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Button order&lt;br&gt;&lt;br&gt;According to the Android Design Guide,&lt;br/&gt;
&lt;br/&gt;
"Action buttons are typically Cancel and/or OK, with OK indicating the preferred or most likely action. However, if the options consist of specific actions such as Close or Wait rather than a confirmation or cancellation of the action described in the content, then all the buttons should be active verbs. As a rule, the dismissive action of a dialog is always on the left whereas the affirmative actions are on the right."&lt;br/&gt;
&lt;br/&gt;
This check looks for button bars and buttons which look like cancel buttons, and makes sure that these are on the left.&lt;br&gt;&lt;br&gt;Issue id: ButtonOrder&lt;br&gt;&lt;br&gt;&lt;a href="https://material.io/components/dialogs/"&gt;https://material.io/components/dialogs/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintBackButton" defaultSeverity="WARNING" displayName="Back button" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Back button&lt;br&gt;&lt;br&gt;According to the Android Design Guide,&lt;br/&gt;
&lt;br/&gt;
"Other platforms use an explicit back button with label to allow the user to navigate up the application's hierarchy. Instead, Android uses the main action bar's app icon for hierarchical navigation and the navigation bar's back button for temporal navigation."&lt;br/&gt;
&lt;br/&gt;
This check is not very sophisticated (it just looks for buttons with the label "Back"), so it is disabled by default to not trigger on common scenarios like pairs of Back/Next buttons to paginate through screens.&lt;br&gt;&lt;br&gt;Issue id: BackButton&lt;br&gt;&lt;br&gt;&lt;a href="https://material.io/design/"&gt;https://material.io/design/&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAppLinkUrlError" defaultSeverity="ERROR" displayName="URL not supported by app for Firebase App Indexing" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;URL not supported by app for Firebase App Indexing&lt;br&gt;&lt;br&gt;Ensure the URL is supported by your app, to get installs and traffic to your app from Google Search.&lt;br&gt;&lt;br&gt;Issue id: AppLinkUrlError&lt;br&gt;&lt;br&gt;&lt;a href="https://g.co/AppIndexing/AndroidStudio"&gt;https://g.co/AppIndexing/AndroidStudio&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Memory" path="Java"><inspection shortName="AnonymousInnerClassMayBeStatic" defaultSeverity="WARNING" displayName="Anonymous class may be a named 'static' inner class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports anonymous classes that may be safely replaced with &lt;code&gt;static&lt;/code&gt; inner classes.
An anonymous class may be a &lt;code&gt;static&lt;/code&gt; inner class if it doesn't explicitly reference its enclosing instance or local classes from its surrounding method.
&lt;p&gt;
A &lt;code&gt;static&lt;/code&gt; inner class does not keep an implicit reference to its enclosing instance.
This prevents a common cause of memory leaks and uses less memory per class instance.
&lt;/p&gt;
&lt;p&gt;The quick-fix extracts the anonymous class into a named &lt;code&gt;static&lt;/code&gt; inner class.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void sample() {
    Thread thread = new Thread(new Runnable() {
      @Override
      public void run() {
      }
    });
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void sample() {
    Thread thread = new Thread(new Task());
  }

  private static class Task implements Runnable {
    @Override
    public void run() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticCollection" defaultSeverity="WARNING" displayName="Static collection" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports static fields of a &lt;code&gt;Collection&lt;/code&gt; type. While it's
not necessarily a problem, static collections often cause memory leaks and are
therefore prohibited by some coding standards.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Example {
    static List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore weak static collections or maps&lt;/b&gt; option to ignore the fields of the &lt;code&gt;java.util.WeakHashMap&lt;/code&gt; type.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ZeroLengthArrayInitialization" defaultSeverity="WARNING" displayName="Zero-length array allocation" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports allocations of arrays with known lengths of zero.
&lt;p&gt;
  Since array lengths in Java are non-modifiable, it is almost always possible to share zero-length arrays, rather than repeatedly
  allocate new ones. Such sharing may provide useful optimizations in the program runtime or footprint.
&lt;/p&gt;
&lt;p&gt;
  Note that the inspection does not report zero-length arrays allocated as static final fields,
  since those arrays are assumed to be used for implementing array sharing.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReturnOfInnerClass" defaultSeverity="WARNING" displayName="Return of instance of anonymous, local or inner class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;return&lt;/code&gt; statements that return an instance of an anonymous, local, or inner class.
Such instances keep an implicit reference to the outer instance, which can prevent the outer instance from being garbage-collected.
Any caller of a method returning such an instance might cause a memory leak by holding on to the instance returned.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore returns from non-public methods&lt;/b&gt; option to ignore returns from &lt;code&gt;protected&lt;/code&gt; or package-private methods.
    Returns from &lt;code&gt;private&lt;/code&gt; methods are always ignored.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemGC" defaultSeverity="WARNING" displayName="Call to 'System.gc()' or 'Runtime.gc()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;System.gc()&lt;/code&gt; or &lt;code&gt;Runtime.gc()&lt;/code&gt; calls.
While occasionally useful in testing, explicitly triggering garbage collection via &lt;code&gt;System.gc()&lt;/code&gt; is almost never recommended in production code and can result in serious performance issues.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryEmptyArrayUsage" defaultSeverity="WARNING" displayName="Unnecessary zero length array usage" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports allocations of arrays with known lengths of zero when there is a constant for that in the class of the array's element type.
As zero-length arrays are immutable, you can save memory reusing the same array instance.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Item {
    // Public zero-length array constant that can be reused 
    public static final Item[] EMPTY_ARRAY = new Item[0];
  }
  class EmptyNode {
    Item[] getChildren() {
      // Unnecessary zero-length array creation
      return new Item[0];
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EmptyNode {
    Item[] getChildren() {
      return Item.EMPTY_ARRAY;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InnerClassMayBeStatic" defaultSeverity="WARNING" displayName="Inner class may be 'static'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports inner classes that can be made &lt;code&gt;static&lt;/code&gt;.
&lt;p&gt;A &lt;code&gt;static&lt;/code&gt; inner class does not keep an implicit reference to its enclosing instance.
  This prevents a common cause of memory leaks and uses less memory per instance of the class.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Outer {
    &lt;b&gt;class&lt;/b&gt; Inner { // not static
      &lt;b&gt;public void&lt;/b&gt; foo() {
        bar("x");
      }

      &lt;b&gt;private void&lt;/b&gt; bar(String string) {}
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Outer {
    &lt;b&gt;static class&lt;/b&gt; Inner {
      &lt;b&gt;public void&lt;/b&gt; foo() {
        bar("x");
      }

      &lt;b&gt;private void&lt;/b&gt; bar(String string) {}
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringBufferField" defaultSeverity="WARNING" displayName="'StringBuilder' field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields of type &lt;code&gt;java.lang.StringBuffer&lt;/code&gt; or &lt;code&gt;java.lang.StringBuilder&lt;/code&gt;.
Such fields can grow without limit and are often the cause of memory leaks.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Example {
    private StringBuilder builder = new StringBuilder();

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Method" path="Java/Naming conventions"><inspection shortName="MethodNameSameAsClassName" defaultSeverity="WARNING" displayName="Method name same as class name" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that are named identically to their class.
While such naming is allowed by the Java language, by convention it is reserved for defining constructors.
Using it for methods is probably a mistake or bad practice.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    int val;

    // Method MyClass named identically to its containing class.
    // Likely, 'void' was added by mistake.
    void MyClass(int val) {
      this.val = val;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When appropriate, a quick-fix converts the method to a constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    int val;

    MyClass(int val) {
      this.val = val;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another quick-fix renames the method.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanMethodNameMustStartWithQuestion" defaultSeverity="WARNING" displayName="Boolean method name must start with question word" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports boolean methods whose names do not start with a question
word.
&lt;p&gt;Boolean methods that override library methods are ignored by this inspection.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;boolean empty(List&amp;lt;String&amp;gt; list) {
  return list.isEmpty();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix that renames such methods is available only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Boolean method name prefixes&lt;/b&gt; list to specify acceptable question words to start boolean method names with.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore methods with 'java.lang.Boolean' return type&lt;/b&gt; option to ignore methods with the &lt;code&gt;java.lang.Boolean&lt;/code&gt; return type. &lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore boolean methods in an @interface&lt;/b&gt; option to ignore boolean methods in annotation types (&lt;code&gt;@interface&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore methods overriding/implementing a super method&lt;/b&gt; to ignore methods the have supers.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NewMethodNamingConvention" defaultSeverity="WARNING" displayName="Method naming convention" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods whose names are too short, too long, or do not follow
the specified regular expression pattern.
&lt;p&gt;Instance methods that override library
  methods and constructors are ignored by this inspection.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt; if the inspection is enabled for static methods, and the minimum specified method name length is 4 (the default),
  the following static method produces a warning, because the length of its name is 3, which is less
  than 4: &lt;code&gt;public static int max(int a, int b)&lt;/code&gt;.
&lt;p&gt;A quick-fix that renames such methods is available only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;Use the list in the &lt;b&gt;Options&lt;/b&gt; section to specify which methods should be checked. Deselect the checkboxes for the method types for which
  you want to skip the check. Specify &lt;b&gt;0&lt;/b&gt; in the length fields to skip the corresponding checks.&lt;/p&gt;
&lt;p&gt;Regular expressions should be specified in the standard &lt;code&gt;java.util.regex&lt;/code&gt; format.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonBooleanMethodNameMayNotStartWithQuestion" defaultSeverity="WARNING" displayName="Non-boolean method name must not start with question word" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-boolean methods whose names start with a question
word. Such method names may be confusing.
&lt;p&gt;Non-boolean methods that override library methods are ignored by this inspection.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  public void hasName(String name) {
    assert names.contains(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix that renames such methods is available only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Boolean method name prefixes&lt;/b&gt; list to specify the question words that should be used only for boolean methods.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore methods with 'java.lang.Boolean' return type&lt;/b&gt; option to ignore methods with &lt;code&gt;java.lang.Boolean&lt;/code&gt; return type.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore methods overriding/implementing a super method&lt;/b&gt; option to ignore methods which have supers. &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverloadedMethodsWithSameNumberOfParameters" defaultSeverity="WARNING" displayName="Overloaded methods with same number of parameters" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that are declared in the same class, have the same name, and the same number of parameters.
Such overloads cam be very confusing because it can be unclear which overload gets called.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public static void execute(Runnable r) {}
    public static &amp;lt;T&amp;gt; void execute(RunnableFuture&amp;lt;T&amp;gt; c) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to ignore overloaded methods whose parameter types are definitely incompatible.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverloadedVarargsMethod" defaultSeverity="WARNING" displayName="Overloaded varargs method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports varargs methods with the same name as other methods in the class or in a superclass.
Overloaded methods that take a variable number of arguments can be very confusing
because it is often unclear which overload gets called.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    public void execute(Runnable... r) {} // warning
    public void execute(Runnable r1, Runnable r2) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodNameSameAsParentName" defaultSeverity="WARNING" displayName="Method name same as parent class name" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that have the same name as the superclass of the method's class, as
such a method name may be confusing.
&lt;p&gt;This inspection doesn't check interfaces or superclasses deep in the hierarchy.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {}
  class Child extends Parent {
     public Parent Parent() {
       return null;
     }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix that renames such methods is available only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MisspelledMethodName" defaultSeverity="WARNING" displayName="Method names differing only by case" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports cases in which multiple methods of a class have the names that differ only by
case. Such names may be very confusing.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
&lt;pre&gt;&lt;code&gt;
  public int hashcode() { // reported, should be hashCode probably?
    return 0;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix that renames such methods is available only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore methods overriding/implementing a super method&lt;/b&gt; option to ignore methods overriding or implementing a method from
  the superclass.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaUnfriendlyMethodOverload" defaultSeverity="WARNING" displayName="Lambda-unfriendly method overload" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports overloaded methods that take functional interfaces with conflicting abstract method signatures.
&lt;p&gt;Such overloads introduce ambiguity and require callers to cast lambdas to a specific type or specify lambda parameter types explicitly.
  It is preferable to give the overloaded methods different names to eliminate ambiguity.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface MyExecutor {
    void execute(Supplier&amp;lt;?&amp;gt; supplier);
    void execute(Callable&amp;lt;?&amp;gt; callable);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
Here, &lt;code&gt;Supplier&lt;/code&gt; and &lt;code&gt;Callable&lt;/code&gt; are functional interfaces
whose single abstract methods do not take any parameters and return a non-void value.
As a result, the type of the lambda cannot be inferred at the call site unless an explicit cast is used.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Portability" path="Java"><inspection shortName="RuntimeExec" defaultSeverity="WARNING" displayName="Call to 'Runtime.exec()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Runtime.exec()&lt;/code&gt; or any of its variants.
Calls to &lt;code&gt;Runtime.exec()&lt;/code&gt; are inherently unportable.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfAWTPeerClass" defaultSeverity="WARNING" displayName="Use of AWT peer class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports uses of AWT peer classes. Such classes represent
native windowing system widgets, and will be non-portable between different windowing
systems.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.awt.peer.ButtonPeer;

  abstract class Sample implements ButtonPeer {
    public void foo() {
        Sample sample;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HardcodedLineSeparators" defaultSeverity="WARNING" displayName="Hardcoded line separator" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports linefeed (&lt;code&gt;\n&lt;/code&gt;) and carriage return (&lt;code&gt;\r&lt;/code&gt;) character escape sequences used in string literals,
character literals or text blocks. These characters are commonly used as line separators, and portability may suffer if they are hardcoded.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String count = "first\nsecond\rthird";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemExit" defaultSeverity="WARNING" displayName="Call to 'System.exit()' or related methods" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;System.exit()&lt;/code&gt;, &lt;code&gt;Runtime.exit()&lt;/code&gt;,
and &lt;code&gt;Runtime.halt()&lt;/code&gt;.
&lt;p&gt;
  Invoking &lt;code&gt;System.exit()&lt;/code&gt; or &lt;code&gt;Runtime.exit()&lt;/code&gt;
  calls the shutdown hooks and terminates the currently running Java
  virtual machine. Invoking &lt;code&gt;Runtime.halt()&lt;/code&gt; forcibly
  terminates the JVM without causing shutdown hooks to be started.
  Each of these methods should be used with extreme caution. Calls
  to these methods make the calling code unportable to most
  application servers.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to ignore calls in main methods.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HardcodedFileSeparators" defaultSeverity="WARNING" displayName="Hardcoded file separator" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the forward (&lt;code&gt;/&lt;/code&gt;) or backward (&lt;code&gt;\&lt;/code&gt;) slash in a string or
character literal. These characters are commonly used as file separators, and portability may suffer if they are hardcoded.
&lt;p&gt;
  The inspection will not report backward slashes inside escape sequences and forward slashes immediately following the '&amp;lt;' character
  or immediately preceding the '&amp;gt;' character, as those often indicate XML or HTML tags rather than file names.
  Strings representing a &lt;code&gt;java.util.TimeZone&lt;/code&gt; ID, strings that are valid regular expressions,
  or strings that equal IANA-registered MIME media types will not be reported either.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new File("C:\\Users\\Name");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to include &lt;code&gt;example/*&lt;/code&gt; in the set of recognized media types.
  Normally, usage of the &lt;code&gt;example/*&lt;/code&gt; MIME media type outside of an example (e.g. in a &lt;code&gt;Content-Type&lt;/code&gt;
  header) is an error.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfSunClasses" defaultSeverity="WARNING" displayName="Use of 'sun.*' classes" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports uses of classes from the &lt;code&gt;sun.*&lt;/code&gt; hierarchy.
Such classes are non-portable between different JVMs.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemGetenv" defaultSeverity="WARNING" displayName="Call to 'System.getenv()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;System.getenv()&lt;/code&gt;.
Calls to &lt;code&gt;System.getenv()&lt;/code&gt; are inherently unportable.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NativeMethods" defaultSeverity="WARNING" displayName="Native method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods declared &lt;code&gt;native&lt;/code&gt;. Native methods are inherently unportable.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfJDBCDriverClass" defaultSeverity="WARNING" displayName="Use of concrete JDBC driver class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports uses of specific JDBC driver classes. Use of such classes will
bind your project to a specific database and driver, defeating the purpose of JDBC and
resulting in loss of portability.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import java.sql.Driver;

  abstract class Sample implements Driver {
    public void foo() {
        Sample sample;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfProcessBuilder" defaultSeverity="WARNING" displayName="Use of 'java.lang.ProcessBuilder' class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports uses of &lt;code&gt;java.lang.ProcessBuilder&lt;/code&gt;,
which might be unportable between operating systems because
paths to executables, environment variables, command-line arguments and
their escaping might vary depending on the OS.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Security" path="Java"><inspection shortName="CustomClassloader" defaultSeverity="WARNING" displayName="Custom 'ClassLoader' is declared" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports user-defined subclasses of &lt;code&gt;java.lang.ClassLoader&lt;/code&gt;.
&lt;p&gt;
  While not necessarily representing a security hole, such classes should be thoroughly
  inspected for possible security issues.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalClone" defaultSeverity="WARNING" displayName="Non-final 'clone()' in secure context" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;clone()&lt;/code&gt; methods without the &lt;code&gt;final&lt;/code&gt; modifier.
&lt;p&gt;
  Since &lt;code&gt;clone()&lt;/code&gt; can be used to instantiate objects without using a constructor, allowing the &lt;code&gt;clone()&lt;/code&gt;
  method to be overridden may result in corrupted objects, and even in security exploits. This may be prevented by making the
  &lt;code&gt;clone()&lt;/code&gt; method or the enclosing class itself &lt;code&gt;final&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Cloneable {
    @Override
    protected Object clone() throws CloneNotSupportedException {
      return super.clone();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneableClassInSecureContext" defaultSeverity="WARNING" displayName="Cloneable class in secure context" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes which may be cloned.
&lt;p&gt;
  A class
  may be cloned if it supports the &lt;code&gt;Cloneable&lt;/code&gt; interface,
  and its &lt;code&gt;clone()&lt;/code&gt; method is not defined to immediately
  throw an error. Cloneable classes may be dangerous in code intended for secure use.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;code&gt;class SecureBean implements Cloneable {}&lt;/code&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;&lt;code&gt;class SecureBean {}&lt;/code&gt;
&lt;p&gt;
When the class extends an existing cloneable class or implements a cloneable interface,
  then after the quick-fix is applied, the code may look like: 
&lt;pre&gt;&lt;code&gt;class SecureBean extends ParentBean {
    @Override
    protected SecureBean clone() throws CloneNotSupportedException {
        throw new CloneNotSupportedException();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableDeserializableClassInSecureContext" defaultSeverity="WARNING" displayName="Serializable class in secure context" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that may be serialized or deserialized.
&lt;p&gt;
  A class may be serialized if it supports the &lt;code&gt;Serializable&lt;/code&gt; interface,
  and its &lt;code&gt;readObject()&lt;/code&gt; and &lt;code&gt;writeObject()&lt;/code&gt; methods are not defined to always
  throw an exception. Serializable classes may be dangerous in code intended for secure use.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class DeserializableClass implements Serializable { // the class doesn't contain 'writeObject()' method throwing an exception
    private int sensitive = 736326;

    private void readObject(ObjectInputStream in) {
        throw new Error();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class DeserializableClass implements Serializable {
    private int sensitive = 736326;

    private void readObject(ObjectInputStream in) {
        throw new Error();
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
        throw new java.io.NotSerializableException("DeserializableClass");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the following options to configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    List classes whose inheritors should not be reported by this inspection.
    This is meant for classes that inherit
    &lt;code&gt;Serializable&lt;/code&gt; from a superclass but are not intended for serialization.
    Note that it still may be more secure to add &lt;code&gt;readObject()&lt;/code&gt; and &lt;code&gt;writeObject()&lt;/code&gt; methods
    which always throw an exception, instead of ignoring those classes.
  &lt;/li&gt;
  &lt;li&gt;
    Whether to ignore serializable anonymous classes.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DesignForExtension" defaultSeverity="WARNING" displayName="Design for extension" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods which are not &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;final&lt;/code&gt; or &lt;code&gt;abstract&lt;/code&gt;, and whose bodies
are not empty.
&lt;p&gt;
  Coding in a style that avoids such methods protects the contracts of classes from being broken by their subclasses. The
  benefit of this style is that subclasses cannot corrupt the state of the superclass by forgetting to call the super method. The cost is
  that
  subclasses are limited in their flexibility, in particular they cannot prevent execution of code in the superclass. Use the quick-fix to
  add
  the missing modifiers.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public boolean equals(Object o) { return true; }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    public final boolean equals(Object o) { return true; }
  }
&lt;/code&gt;&lt;/pre&gt;
This inspection is intended for code that is going to be used in secure environments, and is probably not appropriate for less restrictive environments.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicStaticCollectionField" defaultSeverity="WARNING" displayName="'public static' collection field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports modifiable &lt;code&gt;public&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; Collection fields.
&lt;p&gt;Even though they are often used to store collections of constant values, these fields nonetheless represent a security
  hazard, as their contents may be modified even if the field is declared as &lt;code&gt;final&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public static final List&amp;lt;String&amp;gt; EVENTS = new ArrayList&amp;lt;&amp;gt;();
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the table in the &lt;b&gt;Options&lt;/b&gt; section to specify methods returning unmodifiable collections.
  &lt;code&gt;public&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; collection fields initialized with these methods will not be reported.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemProperties" defaultSeverity="WARNING" displayName="Access of system properties" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code that accesses system properties using one of the following methods:
&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;System.getProperties()&lt;/code&gt;, &lt;code&gt;System.setProperty()&lt;/code&gt;,
    &lt;code&gt;System.setProperties()&lt;/code&gt;, &lt;code&gt;System.clearProperties()&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;Integer.getInteger()&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;Boolean.getBoolean()&lt;/code&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
While accessing the system properties is not a security risk in itself, it is often found in malicious code.
Code that accesses system properties should be closely examined in any security audit.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassLoaderInstantiation" defaultSeverity="WARNING" displayName="'ClassLoader' instantiation" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instantiations of the &lt;code&gt;java.lang.ClassLoader&lt;/code&gt; class.
&lt;p&gt;While often benign, any instantiations of &lt;code&gt;ClassLoader&lt;/code&gt; should be closely examined in any security audit.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Class&amp;lt;?&amp;gt; loadExtraClass(String name) throws Exception {
      try(URLClassLoader loader =
          new URLClassLoader(new URL[]{new URL("extraClasses/")})) {
        return loader.loadClass(name);
      }
    }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JDBCPrepareStatementWithNonConstantString" defaultSeverity="WARNING" displayName="Call to 'Connection.prepare*()' with non-constant string" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.sql.Connection.prepareStatement()&lt;/code&gt;, &lt;code&gt;java.sql.Connection.prepareCall()&lt;/code&gt;, or any of their
variants which take a dynamically-constructed string as the statement to prepare.
&lt;p&gt;
  Constructed SQL statements are a common source of
  security breaches. By default, this inspection ignores compile-time constants.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String bar() { return "bar"; }

  Connection connection = DriverManager.getConnection("", "", "");
  connection.("SELECT * FROM user WHERE name='" + bar() + "'");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
Use the inspection settings to consider any &lt;code&gt;static&lt;/code&gt; &lt;code&gt;final&lt;/code&gt; fields as constants. Be careful, because strings like the
following will be ignored when the option is enabled:
&lt;pre&gt;&lt;code&gt;
  static final String SQL = "SELECT * FROM user WHERE name='" + getUserInput() + "'";
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicStaticArrayField" defaultSeverity="WARNING" displayName="'public static' array field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;public&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; array fields.
&lt;p&gt;
  Such fields are often used to store arrays of constant values. Still, they represent a security
  hazard, as their contents may be modified, even if the field is declared &lt;code&gt;final&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public static String[] allowedPasswords = {"foo", "bar"};
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JDBCExecuteWithNonConstantString" defaultSeverity="WARNING" displayName="Call to 'Statement.execute()' with non-constant string" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.sql.Statement.execute()&lt;/code&gt; or any
of its variants which take a dynamically-constructed string as the query to execute.
&lt;p&gt;Constructed SQL statements are a common source of security breaches.
  By default, this inspection ignores compile-time constants.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ResultSet execute(Statement statement, String name) throws SQLException {
    return statement.executeQuery("select * from " + name); // reports warning
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the inspection options to consider any &lt;code&gt;static&lt;/code&gt; &lt;code&gt;final&lt;/code&gt; fields as constant.
Be careful, because strings like the following will be ignored when the option is enabled:
&lt;pre&gt;&lt;code&gt;
  private static final String SQL = "SELECT * FROM user WHERE name='" + getUserInput() + "'";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RuntimeExecWithNonConstantString" defaultSeverity="WARNING" displayName="Call to 'Runtime.exec()' with non-constant string" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.lang.Runtime.exec()&lt;/code&gt; which take a dynamically-constructed string as the command to execute.
&lt;p&gt;
  Constructed execution strings are a common source of security breaches.
  By default, this inspection ignores compile-time constants.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String i = getUserInput();
  Runtime runtime = Runtime.getRuntime();
  runtime.exec("foo" + i); // reports warning
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the inspection settings to consider any &lt;code&gt;static&lt;/code&gt; &lt;code&gt;final&lt;/code&gt; fields as constant.
Be careful, because strings like the following will be ignored when the option is enabled:
&lt;pre&gt;&lt;code&gt;
  static final String COMMAND = "ping " + getDomainFromUserInput() + "'";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemSetSecurityManager" defaultSeverity="WARNING" displayName="Call to 'System.setSecurityManager()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;System.setSecurityManager()&lt;/code&gt;.
&lt;p&gt;While often benign, any call to &lt;code&gt;System.setSecurityManager()&lt;/code&gt; should be closely examined in any security audit.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LoadLibraryWithNonConstantString" defaultSeverity="WARNING" displayName="Call to 'System.loadLibrary()' with non-constant string" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.lang.System.loadLibrary()&lt;/code&gt;, &lt;code&gt;java.lang.System.load()&lt;/code&gt;, &lt;code&gt;java.lang.Runtime.loadLibrary()&lt;/code&gt;
and &lt;code&gt;java.lang.Runtime.load()&lt;/code&gt;
which take a dynamically-constructed string as the name of the library.
&lt;p&gt;
  Constructed library name strings are a common source of security breaches.
  By default, this inspection ignores compile-time constants.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(int i) {
    System.loadLibrary("foo" + i);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the inspection settings to consider any &lt;code&gt;static final&lt;/code&gt; fields as constant.
Be careful, because strings like the following will be ignored when the option is enabled:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private static final String LIBRARY = getUserInput();
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnsecureRandomNumberGeneration" defaultSeverity="WARNING" displayName="Insecure random number generation" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any uses of &lt;code&gt;java.lang.Random&lt;/code&gt; or
&lt;code&gt;java.lang.Math.random()&lt;/code&gt;.
&lt;p&gt;
  In secure environments,
  &lt;code&gt;java.secure.SecureRandom&lt;/code&gt; is a better choice, since is offers cryptographically secure
  random number generation.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  long token = new Random().nextLong();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CustomSecurityManager" defaultSeverity="WARNING" displayName="Custom 'SecurityManager'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports user-defined subclasses of &lt;code&gt;java.lang.SecurityManager&lt;/code&gt;.
&lt;p&gt;
  While not necessarily representing a security hole, such classes should be thoroughly
  and professionally inspected for possible security issues.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class CustomSecurityManager extends SecurityManager {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 5" path="Java/Java language level migration aids"><inspection shortName="BigDecimalLegacyMethod" defaultSeverity="WARNING" displayName="'BigDecimal' legacy method called" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;BigDecimal.divide()&lt;/code&gt; or &lt;code&gt;BigDecimal.setScale()&lt;/code&gt; that use integer constants to specify the rounding mode.
Since JDK 1.5, consider using methods that take the &lt;code&gt;RoundingMode&lt;/code&gt; &lt;code&gt;enum&lt;/code&gt; parameter instead.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new BigDecimal("42").setScale(2, BigDecimal.ROUND_FLOOR);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new BigDecimal("42").setScale(2, RoundingMode.FLOOR);&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ForCanBeForeach" defaultSeverity="WARNING" displayName="'for' loop can be replaced with enhanced for loop" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;for&lt;/code&gt; loops that iterate over collections or arrays, 
and can be automatically replaced with an enhanced &lt;code&gt;for&lt;/code&gt; loop (foreach iteration syntax).
&lt;!--  'foreach' still used in this description so that the inspection continues to be found using this keyword --&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Iterator&amp;lt;String&amp;gt; iterator = list.iterator(); iterator.hasNext(); ) {
    String item = iterator.next();
    System.out.println(item);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String item : list) {
    System.out.println(item);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Report indexed 'java.util.List' loops&lt;/b&gt; option to find loops involving &lt;code&gt;list.get(index)&lt;/code&gt; calls.
  Generally, these loops can be replaced with enhanced &lt;code&gt;for&lt;/code&gt; loops,
  unless they modify an underlying list in the process, for example, by calling &lt;code&gt;list.remove(index)&lt;/code&gt;.
  If the latter is the case, the enhanced &lt;code&gt;for&lt;/code&gt; loop may throw &lt;code&gt;ConcurrentModificationException&lt;/code&gt;.
  Also, in some cases, &lt;code&gt;list.get(index)&lt;/code&gt; loops may work a little bit faster.&lt;/p&gt;
&lt;p&gt;
  Use the &lt;b&gt;Do not report iterations over untyped collections&lt;/b&gt; option to ignore collections without type parameters.
  This prevents the creation of enhanced &lt;code&gt;for&lt;/code&gt; loop variables of the &lt;code&gt;java.lang.Object&lt;/code&gt; type and the insertion of casts
  where the loop variable is used.&lt;/p&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 5 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryBoxing" defaultSeverity="WARNING" displayName="Unnecessary boxing" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports explicit boxing, that is wrapping of primitive values in objects.
&lt;p&gt;Explicit manual boxing is unnecessary as for Java 5 and later, and can safely be removed.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Integer i = new Integer(1);&lt;/code&gt; &amp;rarr; &lt;code&gt;Integer i = Integer.valueOf(1);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;int i = Integer.valueOf(1);&lt;/code&gt; &amp;rarr; &lt;code&gt;int i = 1;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Only report truly superfluously boxed expressions&lt;/b&gt; option to report only truly superfluous boxing,
  where a boxed value is immediately unboxed either implicitly or explicitly.
In this case, the entire boxing-unboxing step can be removed. The inspection doesn't report simple explicit boxing.
&lt;p&gt;This inspection only reports if the language level of the project or module is 5 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WhileCanBeForeach" defaultSeverity="WARNING" displayName="'while' loop can be replaced with enhanced 'for' loop" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;while&lt;/code&gt; loops that iterate
over collections and can be replaced with enhanced &lt;code&gt;for&lt;/code&gt; loops (foreach iteration syntax).
&lt;!--  'foreach' still used in this description so that the inspection continues to be found using this keyword --&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Iterator it = c.iterator();
  while(it.hasNext()) {
    Object obj = it.next();
    System.out.println(obj);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Can be replaced with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Object obj : c) {
    System.out.println(obj);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 5 or higher.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IndexOfReplaceableByContains" defaultSeverity="WARNING" displayName="'String.indexOf()' expression can be replaced with 'contains()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports comparisons with &lt;code&gt;String.indexOf()&lt;/code&gt; calls
that can be replaced with a call to the &lt;code&gt;String.contains()&lt;/code&gt; method.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; b = "abcd".indexOf('e') &gt;= 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;boolean&lt;/b&gt; b = "abcd".contains('e');
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 5 or higher.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringBufferReplaceableByStringBuilder" defaultSeverity="WARNING" displayName="'StringBuffer' may be 'StringBuilder'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports variables declared as &lt;code&gt;StringBuffer&lt;/code&gt; and suggests replacing them with &lt;code&gt;StringBuilder&lt;/code&gt;.
&lt;code&gt;StringBuilder&lt;/code&gt; is a non-thread-safe replacement for &lt;code&gt;StringBuffer&lt;/code&gt;.
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 5 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RawUseOfParameterizedType" defaultSeverity="WARNING" displayName="Raw use of parameterized class" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports generic classes with omitted type parameters. Such &lt;i&gt;raw&lt;/i&gt; use of generic types is valid
in Java, but it defeats the purpose of type parameters and may mask bugs. This inspection mirrors the
&lt;code&gt;rawtypes&lt;/code&gt; warning of &lt;code&gt;javac&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
//warning: Raw use of parameterized class 'List'
List list = new ArrayList&amp;lt;String&amp;gt;();
//list of strings was created but integer is accepted as well
list.add(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
//no warning as it's impossible to provide type arguments during array creation
IntFunction&amp;lt;List&amp;lt;?&amp;gt;[]&gt; fun = List[]::new;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore construction of new objects&lt;/b&gt; option to ignore raw types used in object construction.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore type casts&lt;/b&gt; option to ignore raw types used in type casts.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore where a type parameter would not compile&lt;/b&gt; option to ignore the cases when a type parameter fails to compile
    (for example, when creating an array or overriding a library method).&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore parameter types of overriding methods&lt;/b&gt; option to ignore type parameters used in parameters of overridden methods.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore when automatic quick-fix is not available&lt;/b&gt; option to ignore the cases when a quick-fix is not available.&lt;/li&gt;
&lt;/ul&gt;
This inspection only reports if the language level of the project or module is 5 or higher.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodCanBeVariableArityMethod" defaultSeverity="INFORMATION" displayName="Method can have varargs parameter" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that can be converted to variable arity methods.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process(String name, Object[] objects);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void process(String name, Object... objects);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  This inspection only reports if the language level of the project or module is 5 or higher.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CollectionsFieldAccessReplaceableByMethodCall" defaultSeverity="WARNING" displayName="Reference to empty collection field can be replaced with method call" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;java.util.Collections&lt;/code&gt; fields: &lt;code&gt;EMPTY_LIST&lt;/code&gt;, &lt;code&gt;EMPTY_MAP&lt;/code&gt;
or &lt;code&gt;EMPTY_SET&lt;/code&gt;. These field usages may be replaced with the following method
calls: &lt;code&gt;emptyList()&lt;/code&gt;, &lt;code&gt;emptyMap()&lt;/code&gt;, or &lt;code&gt;emptySet()&lt;/code&gt;.
Such method calls prevent unchecked warnings by the compiler because the type parameters can be inferred.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; emptyList = Collections.EMPTY_LIST;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; emptyList = Collections.emptyList();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 5 or higher.&lt;/p&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryUnboxing" defaultSeverity="WARNING" displayName="Unnecessary unboxing" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unboxing, that is explicit unwrapping of wrapped primitive values.
&lt;p&gt;Unboxing is unnecessary as for Java 5 and later, and can safely be removed.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Integer i = Integer.valueOf(42).intValue();&lt;/code&gt; &amp;rarr; &lt;code&gt;Integer i = Integer.valueOf(42);&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;int k = Integer.valueOf(42).intValue();&lt;/code&gt; &amp;rarr; &lt;code&gt;int k = Integer.valueOf(42);&lt;/code&gt;
    &lt;p&gt;(reports only when the &lt;b&gt;Only report truly superfluously unboxed expressions&lt;/b&gt; option is not checked)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Only report truly superfluously unboxed expressions&lt;/b&gt; option to only report truly superfluous unboxing,
  where an unboxed value is immediately boxed either implicitly or explicitly.
  In this case, the entire unboxing-boxing step can be removed. The inspection doesn't report simple explicit unboxing.&lt;/p&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 5 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Properties" path="Objective-C"><inspection shortName="AccessorsWereOverridden" defaultSeverity="WARNING" displayName="Overridden accessors" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
 Reports the properties that have the &lt;b&gt;@synthesize&lt;/b&gt; statement if all their accessors (a getter for &lt;code&gt;readonly&lt;/code&gt; properties and
 both a getter and setter, otherwise) are explicitly defined.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReleasingOfAssignProperties" defaultSeverity="WARNING" displayName="Releasing of assign properties" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the properties and instance variables that have the &lt;code&gt;assign&lt;/code&gt; attribute and are released. Only properties with the &lt;code&gt;retain&lt;/code&gt;
and &lt;code&gt;copy&lt;/code&gt; attributes can be released.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SetterForReadonlyProperty" defaultSeverity="WARNING" displayName="Setter for readonly property" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the setter methods for the properties that have the &lt;code&gt;readonly&lt;/code&gt; attribute.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NoGetterOrSetter" defaultSeverity="WARNING" displayName="No getter or setter" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the properties that have neither getter or setter (or only getter for &lt;code&gt;readonly&lt;/code&gt; properties)
  nor the &lt;code&gt;@synthesize&lt;/code&gt; statement.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverriddenAttributeMismatch" defaultSeverity="WARNING" displayName="Overridden attribute mismatch" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the overridden properties that have types and/or attributes different from the types/attributes of the base property.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PropertyAndIvarTypeMismatch" defaultSeverity="WARNING" displayName="Property and ivar type mismatch" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the properties that have the &lt;code&gt;@synthesize&lt;/code&gt; statement with
  an instance variable of a different type.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NoAttributeForProperty" defaultSeverity="WARNING" displayName="No attribute for property" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports missing attributes (&lt;code&gt;assign&lt;/code&gt;, &lt;code&gt;retain&lt;/code&gt;, &lt;code&gt;weak&lt;/code&gt;, &lt;code&gt;strong&lt;/code&gt; or &lt;code&gt;copy&lt;/code&gt;) for object properties.&lt;br&gt;
When ARC (Automatic Reference Counting) is not used, a compiler warning appears when one of these attributes is missing.
  By default, in non-ARC mode, the compiler assumes that the properties have the &lt;code&gt;assign&lt;/code&gt; attribute.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateAttribute" defaultSeverity="WARNING" displayName="Duplicate attribute" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the duplicate attributes of the properties. Although the compiler ignores them,
this may be a sign of a problem.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Performance" path="Android/Lint"><inspection shortName="AndroidLintLogConditional" defaultSeverity="WARNING" displayName="Unconditional Logging Calls" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unconditional Logging Calls&lt;br&gt;&lt;br&gt;The &lt;code&gt;BuildConfig&lt;/code&gt; class provides a constant, &lt;code&gt;DEBUG&lt;/code&gt;, which indicates whether the code is being built in release mode or in debug mode. In release mode, you typically want to strip out all the logging calls. Since the compiler will automatically remove all code which is inside a &lt;code&gt;if (false)&lt;/code&gt; check, surrounding your logging calls with a check for &lt;code&gt;BuildConfig.DEBUG&lt;/code&gt; is a good idea.&lt;br/&gt;
&lt;br/&gt;
If you &lt;b&gt;really&lt;/b&gt; intend for the logging to be present in release mode, you can suppress this warning with a &lt;code&gt;@SuppressLint&lt;/code&gt; annotation for the intentional logging calls.&lt;br&gt;&lt;br&gt;Issue id: LogConditional&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintMergeRootFrame" defaultSeverity="WARNING" displayName="FrameLayout can be replaced with &lt;merge&gt; tag" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;FrameLayout can be replaced with &lt;code&gt;&amp;lt;merge&gt;&lt;/code&gt; tag&lt;br&gt;&lt;br&gt;If a &lt;code&gt;&amp;lt;FrameLayout&gt;&lt;/code&gt; is the root of a layout and does not provide background or padding etc, it can often be replaced with a &lt;code&gt;&amp;lt;merge&gt;&lt;/code&gt; tag which is slightly more efficient. Note that this depends on context, so make sure you understand how the &lt;code&gt;&amp;lt;merge&gt;&lt;/code&gt; tag works before proceeding.&lt;br&gt;&lt;br&gt;Issue id: MergeRootFrame&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2009/03/android-layout-tricks-3-optimize-by.html"&gt;https://android-developers.googleblog.com/2009/03/android-layout-tricks-3-optimize-by.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUselessLeaf" defaultSeverity="WARNING" displayName="Useless leaf layout" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unnecessary leaf layout&lt;br&gt;&lt;br&gt;A layout that has no children or no background can often be removed (since it is invisible) for a flatter and more efficient layout hierarchy.&lt;br&gt;&lt;br&gt;Issue id: UselessLeaf&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRecycle" defaultSeverity="WARNING" displayName="Missing recycle() calls" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;recycle()&lt;/code&gt; calls&lt;br&gt;&lt;br&gt;Many resources, such as TypedArrays, VelocityTrackers, etc., should be recycled (with a &lt;code&gt;recycle()&lt;/code&gt; call) after use. This lint check looks for missing &lt;code&gt;recycle()&lt;/code&gt; calls.&lt;br&gt;&lt;br&gt;Issue id: Recycle&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUsableSpace" defaultSeverity="WARNING" displayName="Using getUsableSpace()" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using getUsableSpace()&lt;br&gt;&lt;br&gt;When you need to allocate disk space for large files, consider using the new &lt;code&gt;allocateBytes(FileDescriptor, long)&lt;/code&gt; API, which will automatically clear cached files belonging to other apps (as needed) to meet your request.&lt;br/&gt;
&lt;br/&gt;
When deciding if the device has enough disk space to hold your new data, call &lt;code&gt;getAllocatableBytes(UUID)&lt;/code&gt; instead of using &lt;code&gt;getUsableSpace()&lt;/code&gt;, since the former will consider any cached data that the system is willing to clear on your behalf.&lt;br/&gt;
&lt;br/&gt;
Note that these methods require API level 26. If your app is running on older devices, you will probably need to use both APIs, conditionally switching on &lt;code&gt;Build.VERSION.SDK_INT&lt;/code&gt;. Lint only looks in the same compilation unit to see if you are already using both APIs, so if it warns even though you are already using the new API, consider moving the calls to the same file or suppressing the warning.&lt;br&gt;&lt;br&gt;Issue id: UsableSpace&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStaticFieldLeak" defaultSeverity="WARNING" displayName="Static Field Leaks" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Static Field Leaks&lt;br&gt;&lt;br&gt;A static field will leak contexts.&lt;br/&gt;
&lt;br/&gt;
Non-static inner classes have an implicit reference to their outer class. If that outer class is for example a &lt;code&gt;Fragment&lt;/code&gt; or &lt;code&gt;Activity&lt;/code&gt;, then this reference means that the long-running handler/loader/task will hold a reference to the activity which prevents it from getting garbage collected.&lt;br/&gt;
&lt;br/&gt;
Similarly, direct field references to activities and fragments from these longer running instances can cause leaks.&lt;br/&gt;
&lt;br/&gt;
ViewModel classes should never point to Views or non-application Contexts.&lt;br&gt;&lt;br&gt;Issue id: StaticFieldLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintVectorPath" defaultSeverity="WARNING" displayName="Long vector paths" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Long vector paths&lt;br&gt;&lt;br&gt;Using long vector paths is bad for performance. There are several ways to make the &lt;code&gt;pathData&lt;/code&gt; shorter:&lt;br/&gt;
* Using less precision&lt;br/&gt;
* Removing some minor details&lt;br/&gt;
* Using the Android Studio vector conversion tool&lt;br/&gt;
* Rasterizing the image (converting to PNG)&lt;br&gt;&lt;br&gt;Issue id: VectorPath&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAnimatorKeep" defaultSeverity="WARNING" displayName="Missing @Keep for Animated Properties" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing @Keep for Animated Properties&lt;br&gt;&lt;br&gt;When you use property animators, properties can be accessed via reflection. Those methods should be annotated with @Keep to ensure that during release builds, the methods are not potentially treated as unused and removed, or treated as internal only and get renamed to something shorter.&lt;br/&gt;
&lt;br/&gt;
This check will also flag other potential reflection problems it encounters, such as a missing property, wrong argument types, etc.&lt;br&gt;&lt;br&gt;Issue id: AnimatorKeep&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintOverdraw" defaultSeverity="WARNING" displayName="Overdraw: Painting regions more than once" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Overdraw: Painting regions more than once&lt;br&gt;&lt;br&gt;If you set a background drawable on a root view, then you should use a custom theme where the theme background is null. Otherwise, the theme background will be painted first, only to have your custom background completely cover it; this is called "overdraw".&lt;br/&gt;
&lt;br/&gt;
NOTE: This detector relies on figuring out which layouts are associated with which activities based on scanning the Java code, and it's currently doing that using an inexact pattern matching algorithm. Therefore, it can incorrectly conclude which activity the layout is associated with and then wrongly complain that a background-theme is hidden.&lt;br/&gt;
&lt;br/&gt;
If you want your custom background on multiple pages, then you should consider making a custom theme with your custom background and just using that theme instead of a root element background.&lt;br/&gt;
&lt;br/&gt;
Of course it's possible that your custom drawable is translucent and you want it to be mixed with the background. However, you will get better performance if you pre-mix the background with your drawable and use that resulting image or color as a custom theme background instead.&lt;br&gt;&lt;br&gt;Issue id: Overdraw&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRedundantNamespace" defaultSeverity="WARNING" displayName="Redundant namespace" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Redundant namespace&lt;br&gt;&lt;br&gt;In Android XML documents, only specify the namespace on the root/document element. Namespace declarations elsewhere in the document are typically accidental leftovers from copy/pasting XML from other files or documentation.&lt;br&gt;&lt;br&gt;Issue id: RedundantNamespace&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseSparseArrays" defaultSeverity="WARNING" displayName="HashMap can be replaced with SparseArray" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;HashMap can be replaced with SparseArray&lt;br&gt;&lt;br&gt;For maps where the keys are of type integer, it's typically more efficient to use the Android &lt;code&gt;SparseArray&lt;/code&gt; API. This check identifies scenarios where you might want to consider using &lt;code&gt;SparseArray&lt;/code&gt; instead of &lt;code&gt;HashMap&lt;/code&gt; for better performance.&lt;br/&gt;
&lt;br/&gt;
This is &lt;b&gt;particularly&lt;/b&gt; useful when the value types are primitives like ints, where you can use &lt;code&gt;SparseIntArray&lt;/code&gt; and avoid auto-boxing the values from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;Integer&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
If you need to construct a &lt;code&gt;HashMap&lt;/code&gt; because you need to call an API outside of your control which requires a &lt;code&gt;Map&lt;/code&gt;, you can suppress this warning using for example the &lt;code&gt;@SuppressLint&lt;/code&gt; annotation.&lt;br&gt;&lt;br&gt;Issue id: UseSparseArrays&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintStringFormatTrivial" defaultSeverity="WARNING" displayName="String.format string only contains trivial conversions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;&lt;code&gt;String.format&lt;/code&gt; string only contains trivial conversions&lt;br&gt;&lt;br&gt;Every call to &lt;code&gt;String.format&lt;/code&gt; creates a new &lt;code&gt;Formatter&lt;/code&gt; instance, which will decrease the performance of your app. &lt;code&gt;String.format&lt;/code&gt; should only be used when necessary--if the formatted string contains only trivial conversions (e.g. &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;) and there are no translation concerns, it will be more efficient to replace them and concatenate with &lt;code&gt;+&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: StringFormatTrivial&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintObsoleteSdkInt" defaultSeverity="WARNING" displayName="Obsolete SDK_INT Version Check" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete SDK_INT Version Check&lt;br&gt;&lt;br&gt;This check flags version checks that are not necessary, because the &lt;code&gt;minSdkVersion&lt;/code&gt; (or surrounding known API level) is already at least as high as the version checked for.&lt;br/&gt;
&lt;br/&gt;
Similarly, it also looks for resources in &lt;code&gt;-vNN&lt;/code&gt; folders, such as &lt;code&gt;values-v14&lt;/code&gt; where the version qualifier is less than or equal to the &lt;code&gt;minSdkVersion&lt;/code&gt;, where the contents should be merged into the best folder.&lt;br&gt;&lt;br&gt;Issue id: ObsoleteSdkInt&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTooDeepLayout" defaultSeverity="WARNING" displayName="Layout hierarchy is too deep" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Layout hierarchy is too deep&lt;br&gt;&lt;br&gt;Layouts with too much nesting is bad for performance. Consider using a flatter layout (such as &lt;code&gt;RelativeLayout&lt;/code&gt; or &lt;code&gt;GridLayout&lt;/code&gt;).The default maximum depth is 10 but can be configured with the environment variable &lt;code&gt;ANDROID_LINT_MAX_DEPTH&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: TooDeepLayout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotifyDataSetChanged" defaultSeverity="WARNING" displayName="Invalidating All RecyclerView Data" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Invalidating All RecyclerView Data&lt;br&gt;&lt;br&gt;The &lt;code&gt;RecyclerView&lt;/code&gt; adapter's &lt;code&gt;onNotifyDataSetChanged&lt;/code&gt; method does not specify what about the data set has changed, forcing any observers to assume that all existing items and structure may no longer be valid. `LayoutManager`s will be forced to fully rebind and relayout all visible views.&lt;br&gt;&lt;br&gt;Issue id: NotifyDataSetChanged&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintExpensiveAssertion" defaultSeverity="WARNING" displayName="Expensive Assertions" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Expensive Assertions&lt;br&gt;&lt;br&gt;In Kotlin, assertions are not handled the same way as from the Java programming language. In particular, they're just implemented as a library call, and inside the library call the error is only thrown if assertions are enabled.&lt;br/&gt;
&lt;br/&gt;
This means that the arguments to the &lt;code&gt;assert&lt;/code&gt; call will &lt;b&gt;always&lt;/b&gt; be evaluated. If you're doing any computation in the expression being asserted, that computation will unconditionally be performed whether or not assertions are turned on. This typically turns into wasted work in release builds.&lt;br/&gt;
&lt;br/&gt;
This check looks for cases where the assertion condition is nontrivial, e.g. it is performing method calls or doing more work than simple comparisons on local variables or fields.&lt;br/&gt;
&lt;br/&gt;
You can work around this by writing your own inline assert method instead:&lt;br/&gt;

&lt;pre&gt;
@Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER")
inline fun assert(condition: () -&gt; Boolean) {
    if (_Assertions.ENABLED &amp;amp;&amp;amp; !condition()) {
        throw AssertionError()
    }
}
&lt;/pre&gt;
&lt;br/&gt;
In Android, because assertions are not enforced at runtime, instead use this:&lt;br/&gt;

&lt;pre&gt;
inline fun assert(condition: () -&gt; Boolean) {
    if (BuildConfig.DEBUG &amp;amp;&amp;amp; !condition()) {
        throw AssertionError()
    }
}
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;Issue id: ExpensiveAssertion&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedIds" defaultSeverity="WARNING" displayName="Unused id" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unused id&lt;br&gt;&lt;br&gt;This resource id definition appears not to be needed since it is not referenced from anywhere. Having id definitions, even if unused, is not necessarily a bad idea since they make working on layouts and menus easier, so there is not a strong reason to delete these.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
The unused resource check can ignore tests. If you want to include resources that are only referenced from tests, consider packaging them in a test source set instead.&lt;br/&gt;
&lt;br/&gt;
You can include test sources in the unused resource check by setting the system property lint.unused-resources.include-tests =true, and to exclude them (usually for performance reasons), use lint.unused-resources.exclude-tests =true.&lt;br/&gt;
&lt;br&gt;&lt;br&gt;Issue id: UnusedIds&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintInefficientWeight" defaultSeverity="WARNING" displayName="Inefficient layout weight" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Inefficient layout weight&lt;br&gt;&lt;br&gt;When only a single widget in a &lt;code&gt;LinearLayout&lt;/code&gt; defines a weight, it is more efficient to assign a width/height of &lt;code&gt;0dp&lt;/code&gt; to it since it will absorb all the remaining space anyway. With a declared width/height of &lt;code&gt;0dp&lt;/code&gt; it does not have to measure its own size first.&lt;br&gt;&lt;br&gt;Issue id: InefficientWeight&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseCompoundDrawables" defaultSeverity="WARNING" displayName="Node can be replaced by a TextView with compound drawables" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Node can be replaced by a &lt;code&gt;TextView&lt;/code&gt; with compound drawables&lt;br&gt;&lt;br&gt;A &lt;code&gt;LinearLayout&lt;/code&gt; which contains an &lt;code&gt;ImageView&lt;/code&gt; and a &lt;code&gt;TextView&lt;/code&gt; can be more efficiently handled as a compound drawable (a single TextView, using the &lt;code&gt;drawableTop&lt;/code&gt;, &lt;code&gt;drawableLeft&lt;/code&gt;, &lt;code&gt;drawableRight&lt;/code&gt; and/or &lt;code&gt;drawableBottom&lt;/code&gt; attributes to draw one or more images adjacent to the text).&lt;br/&gt;
&lt;br/&gt;
If the two widgets are offset from each other with margins, this can be replaced with a &lt;code&gt;drawablePadding&lt;/code&gt; attribute.&lt;br/&gt;
&lt;br/&gt;
There's a lint quickfix to perform this conversion in the Eclipse plugin.&lt;br&gt;&lt;br&gt;Issue id: UseCompoundDrawables&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSyntheticAccessor" defaultSeverity="WARNING" displayName="Synthetic Accessor" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Synthetic Accessor&lt;br&gt;&lt;br&gt;A private inner class which is accessed from the outer class will force the compiler to insert a synthetic accessor; this means that you are causing extra overhead. This is not important in small projects, but is important for large apps running up against the 64K method handle limit, and especially for &lt;b&gt;libraries&lt;/b&gt; where you want to make sure your library is as small as possible for the cases where your library is used in an app running up against the 64K limit.&lt;br&gt;&lt;br&gt;Issue id: SyntheticAccessor&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLaunchActivityFromNotification" defaultSeverity="WARNING" displayName="Notification Launches Services or BroadcastReceivers" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notification Launches Services or BroadcastReceivers&lt;br&gt;&lt;br&gt;Notifications should only launch activities -- that's what users expect (and has been the guidance in both the Android SDK and Material Design documentation for a while).&lt;br/&gt;
&lt;br/&gt;
A &lt;code&gt;Service&lt;/code&gt; or a &lt;code&gt;BroadcastReceiver&lt;/code&gt; should not be used as an intermediate, because this can lead to significant performance problems, and as a result, this will not be allowed in Android 12.&lt;br&gt;&lt;br&gt;Issue id: LaunchActivityFromNotification&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/notifiers/notifications?hl=en#Actions"&gt;https://developer.android.com/guide/topics/ui/notifiers/notifications?hl=en#Actions&lt;/a&gt;&lt;br&gt;&lt;a href="https://material.io/design/platform-guidance/android-notifications.html#behavior"&gt;https://material.io/design/platform-guidance/android-notifications.html#behavior&lt;/a&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/notifiers/notifications?hl=en"&gt;https://developer.android.com/guide/topics/ui/notifiers/notifications?hl=en&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNestedWeights" defaultSeverity="WARNING" displayName="Nested layout weights" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Nested layout weights&lt;br&gt;&lt;br&gt;Layout weights require a widget to be measured twice. When a &lt;code&gt;LinearLayout&lt;/code&gt; with non-zero weights is nested inside another &lt;code&gt;LinearLayout&lt;/code&gt; with non-zero weights, then the number of measurements increase exponentially.&lt;br&gt;&lt;br&gt;Issue id: NestedWeights&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnusedResources" defaultSeverity="WARNING" displayName="Unused resources" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unused resources&lt;br&gt;&lt;br&gt;Unused resources make applications larger and slow down builds.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
The unused resource check can ignore tests. If you want to include resources that are only referenced from tests, consider packaging them in a test source set instead.&lt;br/&gt;
&lt;br/&gt;
You can include test sources in the unused resource check by setting the system property lint.unused-resources.include-tests =true, and to exclude them (usually for performance reasons), use lint.unused-resources.exclude-tests =true.&lt;br/&gt;
,&lt;br&gt;&lt;br&gt;Issue id: UnusedResources&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDuplicateDivider" defaultSeverity="WARNING" displayName="Unnecessary Divider Copy" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unnecessary Divider Copy&lt;br&gt;&lt;br&gt;Older versions of the RecyclerView library did not include a divider decorator, but one was provided as a sample in the support demos. This divider class has been widely copy/pasted into various projects.&lt;br/&gt;
&lt;br/&gt;
In recent versions of the support library, the divider decorator is now included, so you can replace custom copies with the "built-in" version, &lt;code&gt;android.support.v7.widget.DividerItemDecoration&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: DuplicateDivider&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWakelockTimeout" defaultSeverity="WARNING" displayName="Using wakeLock without timeout" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using wakeLock without timeout&lt;br&gt;&lt;br&gt;Wakelocks have two acquire methods: one with a timeout, and one without. You should generally always use the one with a timeout. A typical timeout is 10 minutes. If the task takes longer than it is critical that it happens (i.e. can't use &lt;code&gt;JobScheduler&lt;/code&gt;) then maybe they should consider a foreground service instead (which is a stronger run guarantee and lets the user know something long/important is happening).&lt;br&gt;&lt;br&gt;Issue id: WakelockTimeout&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintLifecycleAnnotationProcessorWithJava8" defaultSeverity="WARNING" displayName="Lifecycle Annotation Processor with Java 8 Compile Option" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Lifecycle Annotation Processor with Java 8 Compile Option&lt;br&gt;&lt;br&gt;For faster incremental build, switch to the Lifecycle Java 8 API with these steps:&lt;br/&gt;
&lt;br/&gt;
First replace
&lt;pre&gt;
annotationProcessor "androidx.lifecycle:lifecycle-compiler:*version*"
kapt "androidx.lifecycle:lifecycle-compiler:*version*"
&lt;/pre&gt;
with
&lt;pre&gt;
implementation "androidx.lifecycle:lifecycle-common-java8:*version*"
&lt;/pre&gt;
Then remove any &lt;code&gt;OnLifecycleEvent&lt;/code&gt; annotations from &lt;code&gt;Observer&lt;/code&gt; classes and make them implement the &lt;code&gt;DefaultLifecycleObserver&lt;/code&gt; interface.&lt;br&gt;&lt;br&gt;Issue id: LifecycleAnnotationProcessorWithJava8&lt;br&gt;&lt;br&gt;&lt;a href="https://d.android.com/r/studio-ui/lifecycle-release-notes"&gt;https://d.android.com/r/studio-ui/lifecycle-release-notes&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseOfBundledGooglePlayServices" defaultSeverity="WARNING" displayName="Use of bundled version of Google Play services" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Use of bundled version of Google Play services&lt;br&gt;&lt;br&gt;Google Play services SDK's can be selectively included, which enables a smaller APK size. Consider declaring dependencies on individual Google Play services SDK's. If you are using Firebase API's (&lt;a href="https://firebase.google.com/docs/android/setup"&gt;https://firebase.google.com/docs/android/setup&lt;/a&gt;), Android Studio's Tools &amp;#8594; Firebase assistant window can automatically add just the dependencies needed for each feature.&lt;br&gt;&lt;br&gt;Issue id: UseOfBundledGooglePlayServices&lt;br&gt;&lt;br&gt;&lt;a href="https://developers.google.com/android/guides/setup#split"&gt;https://developers.google.com/android/guides/setup#split&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUseValueOf" defaultSeverity="WARNING" displayName="Should use valueOf instead of new" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Should use &lt;code&gt;valueOf&lt;/code&gt; instead of &lt;code&gt;new&lt;/code&gt;&lt;br&gt;&lt;br&gt;You should not call the constructor for wrapper classes directly, such as`new Integer(42)`. Instead, call the &lt;code&gt;valueOf&lt;/code&gt; factory method, such as &lt;code&gt;Integer.valueOf(42)&lt;/code&gt;. This will typically use less memory because common integers such as 0 and 1 will share a single instance.&lt;br&gt;&lt;br&gt;Issue id: UseValueOf&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDevModeObsolete" defaultSeverity="WARNING" displayName="Dev Mode Obsolete" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Dev Mode Obsolete&lt;br&gt;&lt;br&gt;In the past, our documentation recommended creating a &lt;code&gt;dev&lt;/code&gt; product flavor with has a minSdkVersion of 21, in order to enable multidexing to speed up builds significantly during development.&lt;br/&gt;
&lt;br/&gt;
That workaround is no longer necessary, and it has some serious downsides, such as breaking API access checking (since the true &lt;code&gt;minSdkVersion&lt;/code&gt; is no longer known).&lt;br/&gt;
&lt;br/&gt;
In recent versions of the IDE and the Gradle plugin, the IDE automatically passes the API level of the connected device used for deployment, and if that device is at least API 21, then multidexing is automatically turned on, meaning that you get the same speed benefits as the &lt;code&gt;dev&lt;/code&gt; product flavor but without the downsides.&lt;br&gt;&lt;br&gt;Issue id: DevModeObsolete&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWearableBindListener" defaultSeverity="ERROR" displayName="Usage of Android Wear BIND_LISTENER is deprecated" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Usage of Android Wear BIND_LISTENER is deprecated&lt;br&gt;&lt;br&gt;BIND_LISTENER receives all Android Wear events whether the application needs them or not. This can be inefficient and cause applications to wake up unnecessarily. With Google Play Services 8.2.0 or later it is recommended to use a more efficient combination of manifest listeners and api-based live listeners filtered by action, path and/or path prefix.&lt;br&gt;&lt;br&gt;Issue id: WearableBindListener&lt;br&gt;&lt;br&gt;&lt;a href="https://android-developers.googleblog.com/2016/04/deprecation-of-bindlistener.html"&gt;https://android-developers.googleblog.com/2016/04/deprecation-of-bindlistener.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintTooManyViews" defaultSeverity="WARNING" displayName="Layout has too many views" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Layout has too many views&lt;br&gt;&lt;br&gt;Using too many views in a single layout is bad for performance. Consider using compound drawables or other tricks for reducing the number of views in this layout.&lt;br/&gt;
&lt;br/&gt;
The maximum view count defaults to 80 but can be configured with the environment variable &lt;code&gt;ANDROID_LINT_MAX_VIEW_COUNT&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: TooManyViews&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAnnotationProcessorOnCompilePath" defaultSeverity="WARNING" displayName="Annotation Processor on Compile Classpath" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Annotation Processor on Compile Classpath&lt;br&gt;&lt;br&gt;This dependency is identified as an annotation processor. Consider adding it to the processor path using &lt;code&gt;annotationProcessor&lt;/code&gt; instead of including it to the compile path.&lt;br&gt;&lt;br&gt;Issue id: AnnotationProcessorOnCompilePath&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHandlerLeak" defaultSeverity="WARNING" displayName="Handler reference leaks" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Handler reference leaks&lt;br&gt;&lt;br&gt;Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a &lt;code&gt;Looper&lt;/code&gt; or &lt;code&gt;MessageQueue&lt;/code&gt; for a thread other than the main thread, then there is no issue. If the &lt;code&gt;Handler&lt;/code&gt; is using the &lt;code&gt;Looper&lt;/code&gt; or &lt;code&gt;MessageQueue&lt;/code&gt; of the main thread, you need to fix your &lt;code&gt;Handler&lt;/code&gt; declaration, as follows: Declare the &lt;code&gt;Handler&lt;/code&gt; as a static class; In the outer class, instantiate a &lt;code&gt;WeakReference&lt;/code&gt; to the outer class and pass this object to your &lt;code&gt;Handler&lt;/code&gt; when you instantiate the &lt;code&gt;Handler&lt;/code&gt;; Make all references to members of the outer class using the &lt;code&gt;WeakReference&lt;/code&gt; object.&lt;br&gt;&lt;br&gt;Issue id: HandlerLeak&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintObsoleteLayoutParam" defaultSeverity="WARNING" displayName="Obsolete layout params" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Obsolete layout params&lt;br&gt;&lt;br&gt;The given layout_param is not defined for the given layout, meaning it has no effect. This usually happens when you change the parent layout or move view code around without updating the layout params. This will cause useless attribute processing at runtime, and is misleading for others reading the layout so the parameter should be removed.&lt;br&gt;&lt;br&gt;Issue id: ObsoleteLayoutParam&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDrawAllocation" defaultSeverity="WARNING" displayName="Memory allocations within drawing code" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Memory allocations within drawing code&lt;br&gt;&lt;br&gt;You should avoid allocating objects during a drawing or layout operation. These are called frequently, so a smooth UI can be interrupted by garbage collection pauses caused by the object allocations.&lt;br/&gt;
&lt;br/&gt;
The way this is generally handled is to allocate the needed objects up front and to reuse them for each drawing operation.&lt;br/&gt;
&lt;br/&gt;
Some methods allocate memory on your behalf (such as &lt;code&gt;Bitmap.create&lt;/code&gt;), and these should be handled in the same way.&lt;br&gt;&lt;br&gt;Issue id: DrawAllocation&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintViewHolder" defaultSeverity="WARNING" displayName="View Holder Candidates" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;View Holder Candidates&lt;br&gt;&lt;br&gt;When implementing a view Adapter, you should avoid unconditionally inflating a new layout; if an available item is passed in for reuse, you should try to use that one instead. This helps make for example &lt;code&gt;ListView&lt;/code&gt; scrolling much smoother.&lt;br&gt;&lt;br&gt;Issue id: ViewHolder&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/ui/layout/recyclerview#ViewHolder"&gt;https://developer.android.com/guide/topics/ui/layout/recyclerview#ViewHolder&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintDisableBaselineAlignment" defaultSeverity="WARNING" displayName="Missing baselineAligned attribute" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Missing &lt;code&gt;baselineAligned&lt;/code&gt; attribute&lt;br&gt;&lt;br&gt;When a &lt;code&gt;LinearLayout&lt;/code&gt; is used to distribute the space proportionally between nested layouts, the baseline alignment property should be turned off to make the layout computation faster.&lt;br&gt;&lt;br&gt;Issue id: DisableBaselineAlignment&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintAssertionSideEffect" defaultSeverity="WARNING" displayName="Assertions with Side Effects" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Assertions with Side Effects&lt;br&gt;&lt;br&gt;Assertion conditions can have side effects. This is risky because the behavior depends on whether assertions are on or off. This is usually not intentional, and can lead to bugs where the production version differs from the version tested during development.&lt;br/&gt;
&lt;br/&gt;
Generally, you'll want to perform the operation with the side effect before the assertion, and then assert that the result was what you expected.&lt;br&gt;&lt;br&gt;Issue id: AssertionSideEffect&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUselessParent" defaultSeverity="WARNING" displayName="Useless parent layout" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unnecessary parent layout&lt;br&gt;&lt;br&gt;A layout with children that has no siblings, is not a scrollview or a root layout, and does not have a background, can be removed and have its children moved directly into the parent for a flatter and more efficient layout hierarchy.&lt;br&gt;&lt;br&gt;Issue id: UselessParent&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNotificationTrampoline" defaultSeverity="ERROR" displayName="Notification Trampolines" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Notification Trampolines&lt;br&gt;&lt;br&gt;Activities should not be launched indirectly from a notification via an intermediate &lt;code&gt;BroadcastReceiver&lt;/code&gt; or &lt;code&gt;Service&lt;/code&gt;. This can lead to significant lags in some scenarios, and is forbidden if &lt;code&gt;targetSdkVersion&lt;/code&gt; is set to the API level for Android 12 or higher.&lt;br/&gt;
&lt;br/&gt;
To fix this, launch the &lt;code&gt;Activity&lt;/code&gt; directly from the notification.&lt;br&gt;&lt;br&gt;Issue id: NotificationTrampoline&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Data flow" path="Java"><inspection shortName="UnnecessaryLocalVariable" defaultSeverity="WARNING" displayName="Redundant local variable" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary local variables that add nothing to the comprehensibility of a method, including:
&lt;ul&gt;
  &lt;li&gt;Local variables that are immediately returned.&lt;/li&gt;
  &lt;li&gt;Local variables that are immediately assigned to another variable and then not used.&lt;/li&gt;
  &lt;li&gt;Local variables that always have the same value as another local variable or parameter.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean yes() {
    boolean b = true;
    return b;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean yes() {
    return true;
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore immediately returned or thrown variables&lt;/b&gt; option to ignore immediately returned or thrown variables.
    Some coding styles suggest using such variables for clarity and ease of debugging.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore variables which have an annotation&lt;/b&gt; option to ignore annotated variables.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanMethodIsAlwaysInverted" defaultSeverity="WARNING" displayName="Boolean method is always inverted" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports methods with a &lt;code&gt;boolean&lt;/code&gt; return type that are used only in a negated context.
&lt;p&gt;The quick-fix makes it possible to rename and invert the method.
  Due to performance reasons, some methods might not be highlighted in the editor.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    boolean alwaysTrue() {
      return true;
    }

    void f() {
      if (!alwaysTrue()) {
        return;
      }
    }
    boolean member = !alwaysTrue();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
    boolean alwaysFalse() {
      return false;
    }

    void f() {
      if (alwaysFalse()) {
        return;
      }
    }
    boolean member = alwaysFalse();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NegativelyNamedBooleanVariable" defaultSeverity="WARNING" displayName="Negatively named boolean variable" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports negatively named variables, for example: &lt;code&gt;disabled&lt;/code&gt;, &lt;code&gt;hidden&lt;/code&gt;, or &lt;code&gt;isNotChanged&lt;/code&gt;.
&lt;p&gt;Usually, inverting the &lt;code&gt;boolean&lt;/code&gt; value and removing the negation from the name makes the code easier to understand.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    boolean disabled = false;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReuseOfLocalVariable" defaultSeverity="WARNING" displayName="Reuse of local variable" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local variables that are "reused" overwriting their
values with new values unrelated to their original use.
&lt;p&gt;Such a local variable reuse may be confusing,
as the intended semantics of the local variable may vary with each use. It may also be
prone to bugs if due to the code changes, the values that have been considered overwritten actually
appear to be alive. It is a good practice to keep variable lifetimes as short as possible, and not
  to reuse local variables for the sake of brevity.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void x() {
        String s = "one";
        System.out.println("s = " + s);
        s = "two"; //reuse of local variable 's'
        System.out.println("s = " + s);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanVariableAlwaysNegated" defaultSeverity="WARNING" displayName="Boolean variable is always inverted" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports boolean variables or fields which are always negated
when their value is used.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
      void m() {
        boolean b = true; //boolean variable 'b' is always inverted
        System.out.println(!b);
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LawOfDemeter" defaultSeverity="WARNING" displayName="Method call violates Law of Demeter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;a href="https://en.wikipedia.org/wiki/Law_of_Demeter"&gt;Law of Demeter&lt;/a&gt; violations.
&lt;p&gt;The Law of Demeter specifies a style guideline: never call a method on an object you got from another call.
The code that follows this guideline is easier to maintain, adapt, and refactor, has less coupling between methods, less duplication,
  and better information hiding. On the other hand, you might need to write many wrapper methods to meet this guideline.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantValueVariableUse" defaultSeverity="WARNING" displayName="Use of variable whose value is known to be constant" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any usages of variables which are known to be constant.
&lt;p&gt;This is the case if the (read) use of the variable is surrounded by an
&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;for&lt;/code&gt;
statement with an &lt;code&gt;==&lt;/code&gt; condition which compares the variable with a constant.
  In this case, the use of a variable which is known to be constant can be replaced with
  an actual constant.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private static void foo(double number) {
        if (number == 1.0) {
            f(number);
        }
    }
    private static void f(double number) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    private static void foo(double number) {
        if (number == 1.0) {
            f(1.0);
        }
    }
    private static void f(double number) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TooBroadScope" defaultSeverity="INFORMATION" displayName="Scope of variable is too broad" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any variable declarations that can be moved to a smaller scope.
&lt;p&gt;This inspection is especially
useful for &lt;i&gt;Pascal style&lt;/i&gt; declarations at the beginning of a method. Additionally variables with too broad a
  scope are also often left behind after refactorings.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  StringBuilder sb = new StringBuilder();
  System.out.println();
  sb.append(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println();
  StringBuilder sb = new StringBuilder();
  sb.append(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Only report variables that can be moved into inner blocks&lt;/b&gt; option to report only those variables that can be moved inside deeper code blocks.
    For example, when the option is enabled, the movement will not be suggested for the &lt;code&gt;sb&lt;/code&gt; variable above.
    However, it will be suggested for the following code:
&lt;pre&gt;&lt;code&gt;
  StringBuilder sb = new StringBuilder(a);
  if (flag) {
    sb.append(1);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Report variables with a new expression as initializer
    (potentially unsafe)&lt;/b&gt; option to report variables that are initialized with a new expression. This makes the inspection potentially
    unsafe when the constructor has non-local side effects. For example, when the option is enabled, the movement will be
    suggested for the &lt;code&gt;foo&lt;/code&gt; variable:
&lt;pre&gt;&lt;code&gt;
  class Foo {
    static List&amp;lt;Foo&amp;gt; fooList = new ArrayList&amp;lt;&amp;gt;();
    String bar;

    Foo(String bar) {
        this.bar = bar;
        fooList.add(this);
    }

    public static void main(String[] args) {
      // movement is possible even though is unsafe
      Foo foo = new Foo("bar");
      System.out.println(fooList.size());
      System.out.println(foo.bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Verbose or redundant code constructs" path="Java"><inspection shortName="RedundantComparatorComparing" defaultSeverity="WARNING" displayName="Comparator method can be simplified" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant &lt;code&gt;Comparator&lt;/code&gt; combinator constructs which can be simplified.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  c.thenComparing(Comparator.comparing(function));

  Comparator.comparing(Map.Entry::getKey);

  Collections.max(list, Comparator.reverseOrder());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fixes are applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  c.thenComparing(function)

  Map.Entry.comparingByKey()

  Collections.min(list, Comparator.naturalOrder());
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExcessiveRangeCheck" defaultSeverity="WARNING" displayName="Excessive range check" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports condition chains in which a value range is checked and these condition chains can be simplified to a single check.
&lt;p&gt;The quick-fix replaces a condition chain with a simplified expression:&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  x &gt; 2 &amp;&amp; x &amp;lt; 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  x == 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  arr.length == 0 || arr.length &gt; 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  arr.length != 1
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2019.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantTypeArguments" defaultSeverity="WARNING" displayName="Redundant type arguments" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports all calls to parametrized methods in which explicit argument types
can be omitted since they will be unambiguously inferred by the compiler.
&lt;p&gt;
  Using redundant type arguments makes code superfluous and thus less readable.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = Arrays.&amp;lt;String&amp;gt;asList("Hello", "World");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix is provided to remove redundant type arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; list = Arrays.asList("Hello", "World");
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DuplicateExpressions" defaultSeverity="WEAK WARNING" displayName="Multiple occurrences of the same expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports multiple equivalent occurrences of the same expression within a method (or constructor, or class initializer)
if the result of the expression can be reused.
&lt;p&gt;
  The expression is reported if it's free of side effects and its result is always the same (in terms of &lt;code&gt;Object.equals()&lt;/code&gt;).
  The examples of such expressions are &lt;code&gt;a + b&lt;/code&gt;, &lt;code&gt;Math.max(a, b)&lt;/code&gt;, &lt;code&gt;a.equals(b)&lt;/code&gt;,
  &lt;code&gt;s.substring(a,b)&lt;/code&gt;. To make sure the result is always the same, it's verified that the variables used in the expression don't
  change their values between the occurrences of the expression.&lt;/p&gt;
&lt;p&gt;
  Such expressions may contain methods of immutable classes like &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;BigDecimal&lt;/code&gt;, and so on,
  and of utility classes like &lt;code&gt;Objects&lt;/code&gt;, &lt;code&gt;Math&lt;/code&gt; (except &lt;code&gt;random()&lt;/code&gt;).
  The well-known methods, such as &lt;code&gt;Object.equals()&lt;/code&gt;, &lt;code&gt;Object.hashCode()&lt;/code&gt;, &lt;code&gt;Object.toString()&lt;/code&gt;,
  &lt;code&gt;Comparable.compareTo()&lt;/code&gt;, and &lt;code&gt;Comparator.compare()&lt;/code&gt; are OK as well because they normally don't have
  any observable side effects.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Expression complexity threshold&lt;/b&gt; option to specify the minimal expression complexity threshold. Specifying bigger
  numbers will remove reports on short expressions.
&lt;/p&gt;
&lt;p&gt;
  &lt;code&gt;Path.of&lt;/code&gt; and &lt;code&gt;Paths.get&lt;/code&gt; calls are treated as equivalent calls if they have the same arguments. These calls
  are always reported no matter how complex their arguments are. This behaviour can be tweaked using different complexity threshold.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2018.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyStreamApiCallChains" defaultSeverity="WARNING" displayName="Stream API call chain can be simplified" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports stream API call chains that can be simplified.
Simplification will often avoid some temporary object creation during collection traversal.
&lt;p&gt;
  The inspection replaces the following call chains:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;collection.stream().forEach()&lt;/code&gt; &amp;rarr; &lt;code&gt;collection.forEach()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;collection.stream().collect(toList/toSet/toCollection())&lt;/code&gt; &amp;rarr; &lt;code&gt;new CollectionType&amp;lt;&amp;gt;(collection)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;collection.stream().toArray()&lt;/code&gt; &amp;rarr; &lt;code&gt;collection.toArray()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Arrays.asList().stream()&lt;/code&gt; &amp;rarr; &lt;code&gt;Arrays.stream()&lt;/code&gt; or &lt;code&gt;Stream.of()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IntStream.range(0, array.length).mapToObj(idx -&gt; array[idx])&lt;/code&gt; &amp;rarr; &lt;code&gt;Arrays.stream(array)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IntStream.range(0, list.size()).mapToObj(idx -&gt; list.get(idx))&lt;/code&gt; &amp;rarr; &lt;code&gt;list.stream()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Collections.singleton().stream()&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.of()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Collections.emptyList().stream()&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.empty()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.filter().findFirst().isPresent()&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.anyMatch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(counting())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.count()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(maxBy())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.max()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(mapping())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.map().collect()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(reducing())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.reduce()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.collect(summingInt())&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.mapToInt().sum()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.mapToObj(x -&gt; x)&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.boxed()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.map(x -&gt; {...; return x;})&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.peek(x -&gt; ...)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;!stream.anyMatch()&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.noneMatch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;!stream.anyMatch(x -&gt; !(...))&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.allMatch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.map().anyMatch(Boolean::booleanValue)&lt;/code&gt; &amp;rarr; &lt;code&gt;stream.anyMatch()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IntStream.range(expr1, expr2).mapToObj(x -&gt; array[x])&lt;/code&gt; &amp;rarr; &lt;code&gt;Arrays.stream(array, expr1, expr2)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Collection.nCopies(count, ...)&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.generate().limit(count)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;stream.sorted(comparator).findFirst()&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.min(comparator)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;optional.orElseGet(() -&gt; { throw new ...; })&lt;/code&gt; &amp;rarr; &lt;code&gt;optional.orElseThrow()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  Note that the replacement semantics may have minor differences in some cases. For example,
  &lt;code&gt;Collections.synchronizedList(...).stream().forEach()&lt;/code&gt; is not synchronized while
  &lt;code&gt;Collections.synchronizedList(...).forEach()&lt;/code&gt; is synchronized.
  Also, &lt;code&gt;collect(Collectors.maxBy())&lt;/code&gt; returns an empty &lt;code&gt;Optional&lt;/code&gt; if the resulting element is
  &lt;code&gt;null&lt;/code&gt; while &lt;code&gt;Stream.max()&lt;/code&gt; throws &lt;code&gt;NullPointerException&lt;/code&gt; in this case.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantCollectionOperation" defaultSeverity="WARNING" displayName="Redundant 'Collection' operation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessarily complex collection operations which have simpler alternatives.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(String[] array, Collection&amp;lt;String&amp;gt; collection) {
    String[] strings = Arrays.asList(array).subList(0, 10).toArray(new String[0]);
    boolean contains = collection.containsAll(Collections.singletonList("x"));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(String[] array, Collection&amp;lt;String&amp;gt; collection) {
    String[] strings = Arrays.copyOf(array, 10);
    boolean contains = collection.contains("x");
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringOperationCanBeSimplified" defaultSeverity="WARNING" displayName="Redundant 'String' operation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant &lt;code&gt;String&lt;/code&gt; constructors and calls to methods like &lt;code&gt;toString()&lt;/code&gt; or &lt;code&gt;substring()&lt;/code&gt;
when they can be replaced with a simplified expression.
&lt;p&gt;For example, calls to these methods can be safely removed in cases
  like &lt;code&gt;"string".substring(0)&lt;/code&gt;, &lt;code&gt;"string".toString()&lt;/code&gt;, or
  &lt;code&gt;new StringBuilder().toString().substring(1,3)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(new String("message"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println("message");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  Note that the quick-fix removes the redundant constructor, and this may affect &lt;code&gt;String&lt;/code&gt; referential equality.
  If you need to preserve it even though it is considered bad practice, suppress the warning or configure the settings to ignore
  redundant &lt;code&gt;String&lt;/code&gt; constructors.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantFileCreation" defaultSeverity="WARNING" displayName="Redundant 'File' instance creation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant &lt;code&gt;File&lt;/code&gt; creation in one of the following constructors when only &lt;code&gt;String&lt;/code&gt; path can be used: &lt;code&gt;FileInputStream&lt;/code&gt;, &lt;code&gt;FileOutputStream&lt;/code&gt;,
&lt;code&gt;FileReader&lt;/code&gt;, &lt;code&gt;FileWriter&lt;/code&gt;, &lt;code&gt;PrintStream&lt;/code&gt;, &lt;code&gt;PrintWriter&lt;/code&gt;, &lt;code&gt;Formatter&lt;/code&gt;.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
InputStream is = new FileInputStream(new File("in.txt"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
InputStream is = new FileInputStream("in.txt");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2020.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifyCollector" defaultSeverity="WARNING" displayName="Simplifiable collector" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports collectors that can be simplified.
&lt;p&gt;In particular, some cascaded &lt;code&gt;groupingBy&lt;/code&gt; collectors can be expressed by using a
  simpler &lt;code&gt;toMap&lt;/code&gt; collector, which is also likely to be more performant.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Collectors.groupingByConcurrent(String::length, Collectors.collectingAndThen(Collectors.maxBy(String::compareTo), Optional::get));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Collectors.toConcurrentMap(String::length, Function.identity(), BinaryOperator.maxBy(String::compareTo));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2017.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringBufferReplaceableByString" defaultSeverity="WARNING" displayName="'StringBuilder' can be replaced with 'String'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;StringBuffer&lt;/code&gt;, &lt;code&gt;StringBuilder&lt;/code&gt;, or &lt;code&gt;StringJoiner&lt;/code&gt;
which can be replaced with a single &lt;code&gt;String&lt;/code&gt; concatenation.
&lt;p&gt;Using &lt;code&gt;String&lt;/code&gt; concatenation
  makes the code shorter and simpler.&lt;/p&gt;
&lt;p&gt;
This inspection only reports when the suggested replacement does not result in significant
performance drawback on modern JVMs. In many cases, &lt;code&gt;String&lt;/code&gt; concatenation may perform better.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  StringBuilder result = new StringBuilder();
  result.append("i = ");
  result.append(i);
  result.append(";");
  return result.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String result = "i = " + i + ";";
  return result;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantCast" defaultSeverity="WARNING" displayName="Redundant type cast" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary cast expressions.

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static Object toObject(String s) {
    return (Object) s;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the checkbox below to ignore clarifying casts e.g., casts in collection calls where &lt;code&gt;Object&lt;/code&gt; is expected:
&lt;pre&gt;&lt;code&gt;
  static void removeFromList(List&amp;lt;String&amp;gt; l, Object o) {
    l.remove((String)o);
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryBreak" defaultSeverity="WARNING" displayName="Unnecessary 'break' statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any unnecessary &lt;code&gt;break&lt;/code&gt; statements.
&lt;p&gt;An &lt;code&gt;break&lt;/code&gt; statement is unnecessary if no other statements are executed after it has been removed.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (e) {
    case A -&amp;gt; {
        System.out.println("A");
        break; // reports 'break' statement is unnecessary
    }
    default -&amp;gt; {
        System.out.println("Default");
        break; // reports 'break' statement is unnecessary
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryDefault" defaultSeverity="WARNING" displayName="Unnecessary 'default' for enum 'switch' statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports enum &lt;code&gt;switch&lt;/code&gt; statements or expression with &lt;code&gt;default&lt;/code&gt; branches which can never be taken,
because all possible values are covered by a &lt;code&gt;case&lt;/code&gt; branch.
&lt;p&gt;Such elements are redundant, especially for &lt;code&gt;switch&lt;/code&gt; expressions, because they don't compile when all
  enum constants are not covered by a &lt;code&gt;case&lt;/code&gt; branch.&lt;/p&gt;
&lt;p&gt;
  The language level needs to be configured to 14 to report &lt;code&gt;switch&lt;/code&gt; expressions.
&lt;/p&gt;
&lt;p&gt;The provided quick-fix removes &lt;code&gt;default&lt;/code&gt; branches.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum E { A, B }
  int foo(E e) {
    return switch (e) {
      case A -&amp;gt; 1;
      case B -&amp;gt; 2;
      default -&amp;gt; 3;
    };
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum E { A, B }
  int foo(E e) {
    return switch (e) {
      case A -&amp;gt; 1;
      case B -&amp;gt; 2;
    };
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Only report switch expressions&lt;/b&gt; option to report only redundant &lt;code&gt;default&lt;/code&gt; branches in switch expressions.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLabelOnContinueStatement" defaultSeverity="WARNING" displayName="Unnecessary label on 'continue' statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;continue&lt;/code&gt; statements with unnecessary
labels.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  LABEL:
  while (a &amp;gt; b) {
    System.out.println("Hello");
    //the code below is the last statement in a loop,
    //so unnecessary label and continue can be removed
    continue LABEL;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantCompareCall" defaultSeverity="WARNING" displayName="Redundant 'compare()' method call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports comparisons in which the &lt;code&gt;compare&lt;/code&gt; method is superfluous.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean result = Integer.compare(a, b) == 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean result = a == b;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryReturn" defaultSeverity="WARNING" displayName="Unnecessary 'return' statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;return&lt;/code&gt; statements at the end of constructors and methods returning
&lt;code&gt;void&lt;/code&gt;. These statements are redundant and may be safely removed.
&lt;p&gt;This inspection does not report in JSP files.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; message() {
    System.out.println("Hello World");
    &lt;b&gt;return&lt;/b&gt;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; message() {
    System.out.println("Hello World");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore in then branch of 'if' statement with 'else' branch&lt;/b&gt; option to ignore &lt;code&gt;return&lt;/code&gt; statements in the then branch of &lt;code&gt;if&lt;/code&gt; statements
which also have an &lt;code&gt;else&lt;/code&gt; branch.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceOnLiteralHasNoEffect" defaultSeverity="WARNING" displayName="Replacement operation has no effect" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to the &lt;code&gt;String&lt;/code&gt; methods &lt;code&gt;replace()&lt;/code&gt;, &lt;code&gt;replaceAll()&lt;/code&gt; or &lt;code&gt;replaceFirst()&lt;/code&gt;
that have no effect. Such calls can be guaranteed to have no effect when the qualifier and search string are compile-time constants
and the search string is not found in the qualifier. This is redundant and may indicate an error.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // replacement does nothing
  "hello".replace("$value$", value);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2022.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryContinue" defaultSeverity="WARNING" displayName="Unnecessary 'continue' statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;continue&lt;/code&gt; statements if they are the last reachable statements in the loop.
These &lt;code&gt;continue&lt;/code&gt; statements are unnecessary and can be safely removed.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String element: elements) {
    System.out.println();
    continue;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String element: elements) {
    System.out.println();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The inspection doesn't analyze JSP files.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignore in then branch of 'if' statement with 'else' branch&lt;/b&gt; option to ignore
  &lt;code&gt;continue&lt;/code&gt; statements when they are placed in a &lt;code&gt;then&lt;/code&gt; branch of a complete
  &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; statement.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String element: elements) {
    if(element.isEmpty()) {
      continue;
    } else {
      //...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantStreamOptionalCall" defaultSeverity="WARNING" displayName="Redundant step in 'Stream' or 'Optional' call chain" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant &lt;code&gt;Stream&lt;/code&gt; or &lt;code&gt;Optional&lt;/code&gt; calls like &lt;code&gt;map(x -&amp;gt; x)&lt;/code&gt;, &lt;code&gt;filter(x -&amp;gt; true)&lt;/code&gt; or
redundant &lt;code&gt;sorted()&lt;/code&gt; or &lt;code&gt;distinct()&lt;/code&gt; calls.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Note that a mapping operation in code like &lt;code&gt;streamOfIntegers.map(Integer::valueOf)&lt;/code&gt;
  works as &lt;code&gt;requireNonNull()&lt;/code&gt; check:
  if the stream contains &lt;code&gt;null&lt;/code&gt;, it throws a &lt;code&gt;NullPointerException&lt;/code&gt;, thus it's not absolutely redundant.
  Disable the &lt;b&gt;Report redundant boxing in Stream.map()&lt;/b&gt; option if you do not want such cases to be reported.&lt;/p&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantArrayCreation" defaultSeverity="WARNING" displayName="Redundant array creation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports arrays that are created specifically to be passed as a varargs parameter.
&lt;p&gt;Example:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Arrays.asList(new String[]{"Hello", "world"})&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the array initializer with individual arguments:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Arrays.asList("Hello", "world")&lt;/code&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantUnmodifiable" defaultSeverity="WARNING" displayName="Redundant usage of unmodifiable collection wrappers" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant calls to unmodifiable collection wrappers within the
&lt;code&gt;Collections&lt;/code&gt; class.
&lt;p&gt;If the argument that is passed to an unmodifiable
  collection wrapper is already immutable, such a wrapping becomes redundant.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Collections.unmodifiableList(Collections.singletonList("abc"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to detect the methods that return unmodifiable collections, the
inspection uses the &lt;code&gt;org.jetbrains.annotations.Unmodifiable&lt;/code&gt;
and &lt;code&gt;org.jetbrains.annotations.UnmodifiableView&lt;/code&gt; annotations.
Use them to extend the inspection to your own unmodifiable collection
  wrappers.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2020.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CastCanBeRemovedNarrowingVariableType" defaultSeverity="WARNING" displayName="Too weak variable type leads to unnecessary cast" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports type casts that can be removed if the variable type is narrowed to the cast type.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object x = "  string  ";
  System.out.println(((String)x).trim());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
Here, changing the type of &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;String&lt;/code&gt; makes the cast redundant. The suggested quick-fix updates the variable type and
removes all redundant casts on that variable:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String x = "  string  ";
  System.out.println(x.trim());
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ManualMinMaxCalculation" defaultSeverity="WARNING" displayName="Manual min/max calculation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports cases where the minimum or the maximum of two numbers can be calculated using
a &lt;code&gt;Math.max()&lt;/code&gt; or &lt;code&gt;Math.min()&lt;/code&gt; call, instead of doing it manually.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int min(int a, int b) {
    return b &amp;lt; a ? b : a;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int min(int a, int b) {
    return Math.min(a, b);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Disable for float and double&lt;/b&gt; option to disable this inspection for &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; types.
  This is useful because the quick-fix may slightly change the semantics for &lt;code&gt;float&lt;/code&gt;/
  &lt;code&gt;double&lt;/code&gt; types when handling &lt;code&gt;NaN&lt;/code&gt;. Nevertheless, in most cases this will actually fix
  a subtle bug where &lt;code&gt;NaN&lt;/code&gt; is not taken into account.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2019.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExplicitArrayFilling" defaultSeverity="WARNING" displayName="Explicit array filling" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports loops that can be replaced with &lt;code&gt;Arrays.setAll()&lt;/code&gt; or &lt;code&gt;Arrays.fill()&lt;/code&gt; calls.
&lt;p&gt;This inspection suggests replacing loops with &lt;code&gt;Arrays.setAll()&lt;/code&gt; if the language level of the project or module is 8 or higher.
  Replacing loops with &lt;code&gt;Arrays.fill()&lt;/code&gt; is possible with any language level.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i=0; i&amp;lt;array.length; i++) {
     array[i] = calc(i);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Arrays.setAll(array, this::calc);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConditionCoveredByFurtherCondition" defaultSeverity="WARNING" displayName="Condition is covered by further condition" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports conditions that become redundant as they are completely covered by a subsequent condition.
&lt;p&gt;For example, in the &lt;code&gt;value != -1 &amp;&amp; value &gt; 0&lt;/code&gt; condition, the first part is redundant:
if it's false, then the second part is also false.
Or in a condition like &lt;code&gt;obj != null &amp;&amp; obj instanceof String&lt;/code&gt;,
  the null-check is redundant as &lt;code&gt;instanceof&lt;/code&gt; operator implies non-nullity.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObviousNullCheck" defaultSeverity="WARNING" displayName="Null-check method is called with obviously non-null argument" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports if a null-checking method (for example, &lt;code&gt;Objects.requireNonNull&lt;/code&gt; or &lt;code&gt;Assert.assertNotNull&lt;/code&gt;) is
called on the value that is obviously non-null (for example, a newly created object). Such a check is redundant and may indicate
a programming error.
&lt;!-- tooltip end --&gt;
&lt;p&gt;New in 2017.2&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryStringEscape" defaultSeverity="WARNING" displayName="Unnecessarily escaped character" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessarily escaped characters in &lt;code&gt;String&lt;/code&gt; and optionally &lt;code&gt;char&lt;/code&gt; literals.
&lt;p&gt;The escaped tab character &lt;code&gt;\t&lt;/code&gt; is not reported, because otherwise it will be invisible.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "\'Scare\' quotes";
  String t = """
    All you need is\n\tLove\n""";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "'Scare' quotes";
  String t = """
    All you need is
    \tLove
  """;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2019.3&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryLabelOnBreakStatement" defaultSeverity="WARNING" displayName="Unnecessary label on 'break' statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;break&lt;/code&gt; statements with unnecessary labels. Such labels do not change the
control flow but make the code difficult to follow.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  label:
  for(int i = 0; i &amp;lt; 10; i++) {
    if (shouldBreak()) break label;
    //doSmth
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  label:
  for(int i = 0; i &amp;lt; 10; i++) {
    if (shouldBreak()) break;
    //doSmth
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExcessiveLambdaUsage" defaultSeverity="WARNING" displayName="Excessive lambda usage" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports if a trivial lambda expression is used in cases in which there's an alternative method that behaves in the same way, but accepts a concrete value
instead of a lambda.
&lt;p&gt;This inspection helps simplify the code.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional.orElseGet(() -&gt; null)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Optional.orElse(null)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SimplifyOptionalCallChains" defaultSeverity="WARNING" displayName="Optional call chain can be simplified" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;b&gt;Optional&lt;/b&gt; call chains that can be simplified. Here are several examples of possible simplifications:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;optional.map(x -&gt; true).orElse(false)&lt;/code&gt; &amp;rarr; &lt;code&gt;optional.isPresent()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;optional.map(x -&gt; Optional.of(x.trim())).orElseGet(Optional::empty)&lt;/code&gt; &amp;rarr; &lt;code&gt;optional.map(String::trim)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;optional.map(x -&gt; (String)x).orElse(null)&lt;/code&gt; &amp;rarr; &lt;code&gt;(String) optional.orElse(null)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Optional.ofNullable(optional.orElse(null))&lt;/code&gt; &amp;rarr; &lt;code&gt;optional&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;val = optional.orElse(null); val != null ? val : defaultExpr &lt;/code&gt; &amp;rarr; &lt;code&gt;optional.orElse(defaultExpr)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;val = optional.orElse(null); if(val != null) expr(val) &lt;/code&gt; &amp;rarr; &lt;code&gt;optional.ifPresent(val -&gt; expr(val))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantClassCall" defaultSeverity="WARNING" displayName="Redundant 'isInstance()' or 'cast()' call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant calls of &lt;code&gt;java.lang.Class&lt;/code&gt; methods.
&lt;p&gt;For example, &lt;code&gt;Xyz.class.isInstance(object)&lt;/code&gt; can be replaced with &lt;code&gt;object instanceof Xyz&lt;/code&gt;.
The instanceof check is preferred: even though the performance will probably be the same as these methods are intrinsics,
they better indicate a static check.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateBranchesInSwitch" defaultSeverity="WEAK WARNING" displayName="Duplicate branches in 'switch'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;switch&lt;/code&gt; statements or expressions that contain the same code in different branches
and suggests merging the duplicate branches.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;switch&lt;/b&gt; (n) {
    &lt;b&gt;case&lt;/b&gt; 1:
      System.out.println(n);
      &lt;b&gt;break&lt;/b&gt;;
    &lt;b&gt;case&lt;/b&gt; 2:
      System.out.println(n);
      &lt;b&gt;break&lt;/b&gt;;
    &lt;b&gt;default&lt;/b&gt;:
      System.out.println("default");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Can be replaced with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;switch&lt;/b&gt; (n) {
    &lt;b&gt;case&lt;/b&gt; 1:
    &lt;b&gt;case&lt;/b&gt; 2:
      System.out.println(n);
      &lt;b&gt;break&lt;/b&gt;;
    &lt;b&gt;default&lt;/b&gt;:
      System.out.println("default");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2019.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Classes" path="Objective-C"><inspection shortName="PrivateCategoryShouldBeNearImplementation" defaultSeverity="WARNING" displayName="Private category should be near implementation" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the private categories located not in the same file with the class implementation.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NoClassDefinition" defaultSeverity="WARNING" displayName="No class definition" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the &lt;code&gt;@class&lt;/code&gt; and &lt;code&gt;@protocol&lt;/code&gt; directives
  that have no classes/protocols with the corresponding names in the project.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NotImplementedMethods" defaultSeverity="WARNING" displayName="Not implemented methods" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the methods declared in &lt;code&gt;@interface&lt;/code&gt; but not implemented in &lt;code&gt;@implementation&lt;/code&gt;.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NotVisibleClass" defaultSeverity="WARNING" displayName="Not visible class" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the implicit class usages where the class is predeclared, but its definition is not imported.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HidesClassScope" defaultSeverity="WARNING" displayName="Hidden class scope" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports local variables and parameters declared in the scope of a class that has instance variables of the same name.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InterfaceHasNoImplementation" defaultSeverity="WARNING" displayName="Interface has no implementation" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the interface declarations that have no implementations in the project scope.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplementationHasNoInterface" defaultSeverity="WARNING" displayName="Implementation has no interface" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the class implementations that have no interface declaration in the project scope.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Proofreading" path=""><inspection shortName="SpellCheckingInspection" defaultSeverity="TYPO" displayName="Typo" enabled="true" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;&lt;body&gt;Reports typos and misspellings in your code, comments, and literals and fixes them with one click.&lt;/body&gt;&lt;/html&gt;
</inspection></group><group name="Performance" path="Java"><inspection shortName="ListRemoveInLoop" defaultSeverity="WARNING" displayName="'List.remove()' called in loop" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;List.remove(index)&lt;/code&gt; called in a loop that can be replaced with &lt;code&gt;List.subList().clear()&lt;/code&gt;.
&lt;p&gt;The replacement
  is more efficient for most &lt;code&gt;List&lt;/code&gt; implementations when many elements are deleted.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void removeRange(List&amp;lt;String&amp;gt; list, int from, int to) {
    for (int i = from; i &amp;lt; to; i++) {
        list.remove(from);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void removeRange(List&amp;lt;String&amp;gt; list, int from, int to) {
    if (to &amp;gt; from) {
      list.subList(from, to).clear();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  The quick-fix adds a range check automatically to prevent a possible &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; when the minimal value is bigger
  than the maximal value. It can be removed if such a situation is impossible in your code.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IOStreamConstructor" defaultSeverity="WARNING" displayName="'InputStream' and 'OutputStream' can be constructed using 'Files' methods" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;FileInputStream&lt;/code&gt; or &lt;code&gt;FileOutputStream&lt;/code&gt; constructors when it is possible to replace
them with &lt;code&gt;Files.newInputStream()&lt;/code&gt; or &lt;code&gt;Files.newOutputStream()&lt;/code&gt; accordingly.
&lt;br&gt;
The streams created using &lt;code&gt;Files&lt;/code&gt; methods are usually more efficient than those created by stream constructors.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
InputStream is = new BufferedInputStream(new FileInputStream(file));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
InputStream is = new BufferedInputStream(Files.newInputStream(file.toPath()));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection does not show warning if the language level 10 or higher, but the quick-fix is still available.&lt;/p&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 7 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2022.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringBufferMustHaveInitialCapacity" defaultSeverity="WARNING" displayName="'StringBuilder' without initial capacity" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports attempts to instantiate a new &lt;code&gt;StringBuffer&lt;/code&gt; or
&lt;code&gt;StringBuilder&lt;/code&gt; object without specifying its initial capacity.
&lt;p&gt;
  If no initial capacity is specified, a default capacity is used, which will rarely be optimal.
  Failing to specify the initial capacity for &lt;code&gt;StringBuffer&lt;/code&gt; may result
  in performance issues if space needs to be reallocated and memory copied
  when the initial capacity is exceeded.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Capacity is not specified
  var sb = new StringBuilder();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WrapperTypeMayBePrimitive" defaultSeverity="WARNING" displayName="Wrapper type may be primitive" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local variables of wrapper type that are mostly used as primitive types.
&lt;p&gt;In some cases, boxing can be source of significant performance penalty, especially in loops.&lt;/p&gt;
&lt;p&gt;Heuristics are applied to estimate the number of boxing operations. For example, conversions inside loops are considered
  as much more numerous.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public void example() {
    Integer value = 12;
    needBox(value);
    for (int i = 0; i &amp;lt; 10; i++) {
      // Loop usages considered as happening more often
      needPrimitive(value);
    }
  }

  void needPrimitive(int value) {}
  void needBox(Integer value) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public void example() {
    int value = 12;
    needBox(value);
    for (int i = 0; i &amp;lt; 10; i++) {
      // Loop usages considered as happening more often
      needPrimitive(value);
    }
  }

  void needPrimitive(int value) {}
  void needBox(Integer value) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;small&gt;New in 2018.2&lt;/small&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LengthOneStringsInConcatenation" defaultSeverity="INFORMATION" displayName="Single character string concatenation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports concatenation with string literals that consist of one character.
&lt;p&gt;These literals may be replaced with equivalent character literals, gaining some performance enhancement.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String hello = hell + "o";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String hello = hell + 'o';
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToSimpleGetterInClass" defaultSeverity="WARNING" displayName="Call to simple getter from within class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to a simple property getter from within the property's class.
&lt;p&gt;
  A simple property getter is defined as one which simply returns the value of a field,
  and does no other calculations. Such simple getter calls can be safely inlined using the quick-fix.
  Some coding standards also suggest against the use of simple getters for code clarity reasons.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Salient {
    private String name;

    public String getName() {
      return name;
    }

    @Override
    public String toString() {
      return getName();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Salient {
    private String name;

    public String getName() {
      return name;
    }

    @Override
    public String toString() {
      return name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the following options to configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Whether to only report getter calls on &lt;code&gt;this&lt;/code&gt;, not on objects of the same type passed in as a parameter.&lt;/li&gt;
  &lt;li&gt;Whether to ignore non-&lt;code&gt;private&lt;/code&gt; getters.&lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceInefficientStreamCount" defaultSeverity="WARNING" displayName="Inefficient Stream API call chains ending with count()" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Stream API call chains ending with the &lt;code&gt;count()&lt;/code&gt; operation that
could be optimized.
&lt;p&gt;
  The following call chains are replaced by this inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Collection.stream().count()&lt;/code&gt; &amp;rarr; &lt;code&gt;Collection.size()&lt;/code&gt;. In Java 8 &lt;code&gt;Collection.stream().count()&lt;/code&gt;
    actually iterates over the collection elements to count them, while &lt;code&gt;Collection.size()&lt;/code&gt; is much faster for most of the collections.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Stream.flatMap(Collection::stream).count()&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.mapToLong(Collection::size).sum()&lt;/code&gt;. Similarly,
    there's no need to iterate over all the nested collections. Instead, their sizes could be summed up.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Stream.filter(o -&gt; ...).count() &gt; 0&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.anyMatch(o -&gt; ...)&lt;/code&gt;. Unlike the original call,
    &lt;code&gt;anyMatch()&lt;/code&gt; may stop the computation as soon as a matching element is found.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Stream.filter(o -&gt; ...).count() == 0&lt;/code&gt; &amp;rarr; &lt;code&gt;Stream.noneMatch(o -&gt; ...)&lt;/code&gt;. Similar to the above.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  Note that if the replacement involves a short-circuiting operation like &lt;code&gt;anyMatch()&lt;/code&gt;, there could be a visible behavior change,
  if the intermediate stream operations produce side effects. In general, side effects should be avoided in Stream API calls.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfStatementMissingBreakInLoop" defaultSeverity="WARNING" displayName="Early loop exit in 'if' condition" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports loops with an &lt;code&gt;if&lt;/code&gt; statement that can end with &lt;code&gt;break&lt;/code&gt; without changing the semantics.
This prevents redundant loop iterations.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean found = false;
  for (int i = 0; i &amp;lt; arr.length; i++) {
    if (Objects.equals(value, arr[i])) {
      found = true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean found = false;
  for (int i = 0; i &amp;lt; arr.length; i++) {
    if (Objects.equals(value, arr[i])) {
      found = true;
      break;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2019.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CollectionContainsUrl" defaultSeverity="WARNING" displayName="'Map' or 'Set' may contain 'URL' objects" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;java.util.Set&lt;/code&gt; and &lt;code&gt;java.util.Map&lt;/code&gt; variables that contain
&lt;code&gt;java.net.URL&lt;/code&gt; objects.
Such collections will call the &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; methods on inserted objects,
which can cause performance problems on &lt;code&gt;URL&lt;/code&gt; objects.
&lt;p&gt;
  &lt;code&gt;URL&lt;/code&gt;'s &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; methods can perform a DNS lookup to resolve the host name.
  This may cause significant delays, depending on the availability and speed of the network and the DNS server.
  Using &lt;code&gt;java.net.URI&lt;/code&gt; instead of &lt;code&gt;java.net.URL&lt;/code&gt; will avoid the DNS lookup.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Set&amp;lt;URL&amp;gt; set = new HashSet&amp;lt;URL&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodMayBeStatic" defaultSeverity="WARNING" displayName="Method can be made 'static'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that can safely be made &lt;code&gt;static&lt;/code&gt;.
Making methods static when possible can reduce memory consumption and improve your code quality.
&lt;p&gt;A method can be &lt;code&gt;static&lt;/code&gt; if:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    it is not &lt;code&gt;synchronized&lt;/code&gt;, &lt;code&gt;native&lt;/code&gt; or &lt;code&gt;abstract&lt;/code&gt;,
  &lt;/li&gt;
  &lt;li&gt;
    does not reference any of non-static methods and non-static fields from the containing class,
  &lt;/li&gt;
  &lt;li&gt;
    is not an override and is not overridden in a subclass.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the following options to configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Whether to report only &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;final&lt;/code&gt; methods, which increases the performance of this inspection.&lt;/li&gt;
  &lt;li&gt;Whether to ignore empty methods.&lt;/li&gt;
  &lt;li&gt;Whether to ignore default methods in interface when using Java 8 or higher.&lt;/li&gt;
  &lt;li&gt;
    Whether to let the quick-fix replace instance qualifiers with class references
    in calls to methods which are made &lt;code&gt;static&lt;/code&gt;,
    that is, call &lt;code&gt;myClass.m()&lt;/code&gt; would be replaced with &lt;code&gt;MyClass.m()&lt;/code&gt;.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CollectionsMustHaveInitialCapacity" defaultSeverity="WARNING" displayName="Collection without initial capacity" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports attempts to instantiate a new &lt;code&gt;Collection&lt;/code&gt; object without specifying
an initial capacity.
&lt;p&gt;
  If no initial capacity is specified, a default capacity is used, which will rarely be optimal. Failing
  to specify initial capacities for collections may result in performance issues if space needs to be reallocated and
  memory copied when the initial capacity is exceeded.
  This inspection checks allocations of classes listed in the inspection's settings.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new HashMap&amp;lt;String, String&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the following options to configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;List collection classes that should be checked.&lt;/li&gt;
  &lt;li&gt;Whether to ignore field initializers.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrivialStringConcatenation" defaultSeverity="WARNING" displayName="Concatenation with empty string" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports string concatenations where one of the arguments is the empty string.
Such a concatenation is unnecessary and inefficient, particularly when used as
an idiom for formatting non-&lt;code&gt;String&lt;/code&gt; objects or primitives into &lt;code&gt;String&lt;/code&gt;s.
&lt;p&gt;
  A quick-fix is suggested to simplify the concatenation.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(int x, int y) {
    String s = "" + x + " ; " + y;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(int x, int y) {
    String s = x + " ; " + y;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ToArrayCallWithZeroLengthArrayArgument" defaultSeverity="WARNING" displayName="'Collection.toArray()' call style" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Collection.toArray()&lt;/code&gt; calls that are not in the preferred style, and suggests applying the preferred style.
&lt;p&gt;There are two styles to convert a collection to an array:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A pre-sized array, for example, &lt;code&gt;c.toArray(new String[c.size()])&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;An empty array, for example,  &lt;code&gt;c.toArray(new String[0])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In older Java versions, using a pre-sized array was recommended, as the reflection
  call necessary to create an array of proper size was quite slow.&lt;/p&gt;
&lt;p&gt;However, since late updates of OpenJDK 6, this call was intrinsified, making
  the performance of the empty array version the same, and sometimes even better, compared
  to the pre-sized version. Also, passing a pre-sized array is dangerous for a concurrent or
  synchronized collection as a data race is possible between the &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;toArray&lt;/code&gt;
  calls. This may result in extra &lt;code&gt;null&lt;/code&gt;s at the end of the array if the collection was concurrently
  shrunk during the operation.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the inspection options to select the preferred style.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryTemporaryOnConversionFromString" defaultSeverity="WARNING" displayName="Unnecessary temporary object in conversion from 'String'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary creation of temporary objects when converting
from &lt;code&gt;String&lt;/code&gt; to primitive types.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new Integer("3").intValue()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer.valueOf("3")
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseBulkOperation" defaultSeverity="WARNING" displayName="Bulk operation can be used instead of iteration" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports single operations inside loops that could be replaced with a bulk method.
&lt;p&gt;
  Not only are bulk methods shorter, but in some cases they may be more performant as well.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void test(Collection&amp;lt;Integer&amp;gt; numbers) {
    List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&gt;();
    for (Integer i : numbers) {
      result.add(i);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Collection&amp;lt;Integer&amp;gt; numbers) {
    List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&gt;();
    result.addAll(numbers);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  The &lt;b&gt;Use Arrays.asList() to wrap arrays&lt;/b&gt; option allows to report arrays, even if the bulk method requires a collection.
  In this case the quick-fix will automatically wrap the array in &lt;code&gt;Arrays.asList()&lt;/code&gt; call.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2017.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AutoUnboxing" defaultSeverity="WARNING" displayName="Auto-unboxing" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports expressions that are affected by unboxing conversion (automatic unwrapping of objects into primitive values).
Try not to use objects instead of primitives. It might significantly affect the performance.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int x = new Integer(42);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix makes the conversion explicit:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int x = new Integer(42).intValue();&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Autoboxing conversion is not supported in Java 1.4 and earlier JVM.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldMayBeStatic" defaultSeverity="WARNING" displayName="Field can be made 'static'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instance variables that can safely be made &lt;code&gt;static&lt;/code&gt;. A field
can be static if it is declared &lt;code&gt;final&lt;/code&gt; and initialized with a constant.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public final String str = "sample";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenationInLoops" defaultSeverity="WARNING" displayName="String concatenation in loop" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports String concatenation in loops.
&lt;p&gt;
  As every String concatenation copies the whole
  string, usually it is preferable to replace it with explicit calls to &lt;code&gt;StringBuilder.append()&lt;/code&gt; or
  &lt;code&gt;StringBuffer.append()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String str = "";
  for(int i=0; i&amp;lt;10; i++) {
    str += i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String str = "";
  StringBuilder strBuilder = new StringBuilder(str);
  for(int i = 0; i&amp;lt;10; i++) {
    strBuilder.append(i);
  }
  str = strBuilder.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Sometimes, the quick-fixes allow you to convert a &lt;code&gt;String&lt;/code&gt; variable to a &lt;code&gt;StringBuilder&lt;/code&gt; or
  introduce a new &lt;code&gt;StringBuilder&lt;/code&gt;. Be careful if the original code specially handles the &lt;code&gt;null&lt;/code&gt; value, as the
  replacement may change semantics. If &lt;code&gt;null&lt;/code&gt; is possible, null-safe fixes that generate
  necessary null-checks are suggested. Also, it's not guaranteed that the automatic replacement will always be more performant.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassInitializerMayBeStatic" defaultSeverity="WARNING" displayName="Class initializer may be 'static'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instance initializers which may be made &lt;code&gt;static&lt;/code&gt;.
&lt;p&gt;
  An instance initializer may be static if it does not reference any of its class' non-static members.
  Static initializers are executed once the class is resolved,
  while instance initializers are executed on each instantiation of the class.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
     public static String CONSTANT;
     {
        CONSTANT = "Hello";
     }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
     public static String CONSTANT;
     static {
        CONSTANT = "Hello"; //now initialized only once per class
     }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StringConcatenationInsideStringBufferAppend" defaultSeverity="WARNING" displayName="String concatenation as argument to 'StringBuilder.append()' call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;String&lt;/code&gt; concatenation used as the argument to &lt;code&gt;StringBuffer.append()&lt;/code&gt;,
&lt;code&gt;StringBuilder.append()&lt;/code&gt; or &lt;code&gt;Appendable.append()&lt;/code&gt;.
&lt;p&gt;
  Such calls may profitably be turned into chained append calls on the existing &lt;code&gt;StringBuffer/Builder/Appendable&lt;/code&gt;
  saving the cost of an extra &lt;code&gt;StringBuffer/Builder&lt;/code&gt; allocation.
  This inspection ignores compile-time evaluated &lt;code&gt;String&lt;/code&gt; concatenations, in which case the conversion would only
  worsen performance.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void bar(StringBuilder builder, String name) {
    builder.append("Hello," + name);    //warning
    builder.append("Hello," + "world"); //no warning
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringReplaceableByStringBuffer" defaultSeverity="WARNING" displayName="Non-constant 'String' can be replaced with 'StringBuilder'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports variables declared as &lt;code&gt;java.lang.String&lt;/code&gt; that are
repeatedly appended to. Such variables could be declared more efficiently as &lt;code&gt;java.lang.StringBuffer&lt;/code&gt;
or &lt;code&gt;java.lang.StringBuilder&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = "";
  for (int i = 0; i &amp;lt; names.length; i++) {
    String name = names[i] + (i == names.length - 1 ? "" : " ");
    s = s + name;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Such a loop can be replaced with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  StringBuilder s = new StringBuilder();
  for (int i = 0; i &amp;lt; names.length; i++) {
    String name = names[i] + (i == names.length - 1 ? "" : " ");
    s.append(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or even with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String s = String.join(" ", names);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to make this inspection only report when the variable is appended to in a loop.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RandomDoubleForRandomInteger" defaultSeverity="WARNING" displayName="Using 'Random.nextDouble()' to get random integer" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to
&lt;code&gt;java.util.Random.nextDouble()&lt;/code&gt; that are used to create a positive integer number by multiplying
the call by a factor and casting to an integer.
&lt;p&gt;
  For generating a random positive integer in a range,
  &lt;code&gt;java.util.Random.nextInt(int)&lt;/code&gt; is simpler and more efficient.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int getRandomInt() {
    return (int) ((new Random()).nextDouble() * SIZE);
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int getRandomInt() {
    return (new Random()).nextInt(SIZE);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AutoBoxing" defaultSeverity="WARNING" displayName="Auto-boxing" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports expressions that are affected by autoboxing conversion (automatic wrapping of primitive values as objects).
Try not to use objects instead of primitives. It might significantly affect performance.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Integer x = 42;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix makes the conversion explicit:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Integer x = Integer.valueOf(42);&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Autoboxing conversion is not supported in Java 1.4 and earlier JVM.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MapReplaceableByEnumMap" defaultSeverity="WARNING" displayName="'Map' can be replaced with 'EnumMap'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instantiations of &lt;code&gt;java.util.Map&lt;/code&gt; objects
whose key types are enumerated classes. Such &lt;code&gt;java.util.Map&lt;/code&gt; objects
can be replaced with &lt;code&gt;java.util.EnumMap&lt;/code&gt; objects.
&lt;p&gt;
  &lt;code&gt;java.util.EnumMap&lt;/code&gt; implementations can be much more efficient
  because the underlying data structure is a simple array.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Map&amp;lt;MyEnum, String&amp;gt; myEnums = new HashMap&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Map&amp;lt;MyEnum, String&amp;gt; myEnums = new EnumMap&amp;lt;&amp;gt;(MyEnum.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringEqualsEmptyString" defaultSeverity="WARNING" displayName="'String.equals()' can be replaced with 'String.isEmpty()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;equals()&lt;/code&gt; being called to compare a &lt;code&gt;String&lt;/code&gt; with an empty string.
In this case, using &lt;code&gt;.isEmpty()&lt;/code&gt; is better as it shows you exactly what you're checking.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void checkString(String s){
    if ("".equals(s)) throw new IllegalArgumentException();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void checkString(String s){
    if (s != null &amp;&amp; s.isEmpty()) throw new IllegalArgumentException();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;code&gt;"".equals(str)&lt;/code&gt; returns false when &lt;code&gt;str&lt;/code&gt; is null. For safety, this inspection's quick-fix inserts an explicit
  null-check when
  the &lt;code&gt;equals()&lt;/code&gt; argument is nullable. Use the option to make the inspection ignore such cases.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryTemporaryOnConversionToString" defaultSeverity="WARNING" displayName="Unnecessary temporary object in conversion to 'String'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary creation of temporary objects when converting
from a primitive type to &lt;code&gt;String&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String foo = new Integer(3).toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String foo = Integer.toString(3);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SlowListContainsAll" defaultSeverity="WARNING" displayName="Call to 'list.containsAll(collection)' may have poor performance" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;containsAll()&lt;/code&gt; on &lt;code&gt;java.util.List&lt;/code&gt;.
&lt;p&gt;
  The time complexity of this method call is O(n&amp;middot;m), where n is the number of elements in the list on which
  the method is called, and m is the number of elements in the collection passed to the method as a parameter.
  When the list is large, this can be an expensive operation.
&lt;/p&gt;
&lt;p&gt;
  The quick-fix wraps the list in &lt;code&gt;new java.util.HashSet&amp;lt;&amp;gt;()&lt;/code&gt; since the time required to create
  &lt;code&gt;java.util.HashSet&lt;/code&gt; from &lt;code&gt;java.util.List&lt;/code&gt; and execute &lt;code&gt;containsAll()&lt;/code&gt; on
  &lt;code&gt;java.util.HashSet&lt;/code&gt; is O(n+m).
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public boolean check(List&amp;lt;String&amp;gt; list, Collection&amp;lt;String&amp;gt; collection) {
    // O(n&amp;middot;m) complexity
    return list.containsAll(collection);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public boolean check(List&amp;lt;String&amp;gt; list, Collection&amp;lt;String&amp;gt; collection) {
    // O(n+m) complexity
    return new HashSet&amp;lt;&amp;gt;(list).containsAll(collection);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2022.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="BulkFileAttributesRead" defaultSeverity="WARNING" displayName="Bulk 'Files.readAttributes' call can be used instead of multiple file attribute calls" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports multiple &lt;code&gt;java.io.File&lt;/code&gt; attribute checks in a row, such as:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;isDirectory&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;isFile&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;lastModified&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;length&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
These calls can be replaced with a bulk &lt;code&gt;Files.readAttributes&lt;/code&gt; call. 
Usually the bulk method is more performant then multiple attribute checks.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
boolean isNewFile(File file, long lastModified) throws IOException {
  return file.isFile() &amp;&amp; file.lastModified() &gt; lastModified;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
boolean isNewFile(File file, long lastModified) throws IOException {
  BasicFileAttributes fileAttributes = Files.readAttributes(file.toPath(), BasicFileAttributes.class);
  return fileAttributes.isRegularFile() &amp;&amp; fileAttributes.lastModifiedTime().toMillis() &gt; lastModified;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection does not show a warning if &lt;code&gt;IOException&lt;/code&gt; is not handled in the current context, but the quick-fix is still available.&lt;/p&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 7 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2022.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CallToSimpleSetterInClass" defaultSeverity="WARNING" displayName="Call to simple setter from within class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to a simple property setter from within the property's class.
&lt;p&gt;
  A simple property setter is defined as one which simply assigns the value of its parameter to a field,
  and does no other calculations. Such simple setter calls can be safely inlined.
  Some coding standards also suggest against the use of simple setters for code clarity reasons.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
  private int index;
    public Foo(int idx) {
       setIndex(idx);
    }
    public void setIndex(int idx) {
       index = idx;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    private int index;
    public Foo(int idx) {
      index = idx;
    }
    public void setIndex(int idx) {
      index = idx;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the following options to configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Whether to only report setter calls on &lt;code&gt;this&lt;/code&gt;, not on objects of the same type passed in as a parameter.&lt;/li&gt;
  &lt;li&gt;Whether to ignore non-&lt;code&gt;private&lt;/code&gt; setters.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsHashCodeCalledOnUrl" defaultSeverity="WARNING" displayName="'equals()' or 'hashCode()' called on 'URL' object" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt; calls on &lt;code&gt;java.net.URL&lt;/code&gt; objects.
&lt;p&gt;
  &lt;code&gt;URL&lt;/code&gt;'s &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; methods can perform a DNS lookup to resolve the host name.
  This may cause significant delays, depending on the availability and speed of the network and the DNS server.
  Using &lt;code&gt;java.net.URI&lt;/code&gt; instead of &lt;code&gt;java.net.URL&lt;/code&gt; will avoid the DNS lookup.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int equalsHashCode(URL url1, URL url2) {
    return url1.hashCode() == url2.hashCode();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SlowAbstractSetRemoveAll" defaultSeverity="WARNING" displayName="Call to 'set.removeAll(list)' may work slowly" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.util.Set.removeAll()&lt;/code&gt; with a &lt;code&gt;java.util.List&lt;/code&gt; argument.
&lt;p&gt;
  Such a call can be slow when the size of the argument is greater than or equal to the size of the set,
  and the set is a subclass of &lt;code&gt;java.util.AbstractSet&lt;/code&gt;.
  In this case, &lt;code&gt;List.contains()&lt;/code&gt; is called for each element in the set, which will perform a linear search.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public void check(String... ss) {
    // possible O(n^2) complexity
    mySet.removeAll(List.of(ss));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public void check(String... ss) {
    // O(n) complexity
    List.of(ss).forEach(mySet::remove);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2020.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CollectionAddAllCanBeReplacedWithConstructor" defaultSeverity="WARNING" displayName="Redundant 'Collection.addAll()' call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Collection.addAll()&lt;/code&gt; and &lt;code&gt;Map.putAll()&lt;/code&gt; calls immediately after instantiation of a collection using the no-arg constructor.
&lt;p&gt;Such constructs can be replaced with a single call to a parametrized constructor, which simplifies code. Also, for some collections the replacement
  might be more performant.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
  set.addAll(Arrays.asList("alpha", "beta", "gamma"));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Can be replaced with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(Arrays.asList("alpha", "beta", "gamma"));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Standard JDK collection classes are supported by default. Additionally, you can specify other classes in the inspection options.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectEqualsCanBeEquality" defaultSeverity="INFORMATION" displayName="'equals()' call can be replaced with '=='" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;equals()&lt;/code&gt; that can be replaced by &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt; expressions without a change in semantics.
&lt;p&gt;These calls can be replaced when they are used to compare &lt;code&gt;final&lt;/code&gt; classes that don't have their own &lt;code&gt;equals()&lt;/code&gt; implementation but use the default &lt;code&gt;Object.equals()&lt;/code&gt;.
This replacement may result in better performance.&lt;/p&gt;
&lt;p&gt;There is a separate inspection for &lt;code&gt;equals()&lt;/code&gt; calls on &lt;code&gt;enum&lt;/code&gt; values: 'equals()' called on Enum value.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;!--&lt;p&gt;&lt;small&gt;New in 2017.3&lt;/small&gt;--&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringBufferToStringInConcatenation" defaultSeverity="WARNING" displayName="'StringBuilder.toString()' in concatenation" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;StringBuffer.toString()&lt;/code&gt; or &lt;code&gt;StringBuilder.toString()&lt;/code&gt; calls in string concatenations.
Such calls are unnecessary when concatenating and can be removed, saving a method call and an object allocation,
which may improve performance.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LengthOneStringInIndexOf" defaultSeverity="WARNING" displayName="Single character string argument in 'String.indexOf()' call" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports single character strings being used as an argument in &lt;code&gt;String.indexOf()&lt;/code&gt; and
&lt;code&gt;String.lastIndexOf()&lt;/code&gt; calls.
&lt;p&gt;A quick-fix is suggested to replace such string literals with equivalent character literals, gaining some performance enhancement.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return s.indexOf("x");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  return s.indexOf('x');
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantStringFormatCall" defaultSeverity="WARNING" displayName="Redundant call to 'String.format()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to methods like &lt;code&gt;format()&lt;/code&gt; and &lt;code&gt;printf()&lt;/code&gt; that can be safely removed or simplified.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.println(String.format("Total count: %d", 42));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.out.printf("Total count: %d%n", 42);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanConstructor" defaultSeverity="WARNING" displayName="Boolean constructor call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports creation of &lt;code&gt;Boolean&lt;/code&gt; objects.
&lt;p&gt;
  Constructing new &lt;code&gt;Boolean&lt;/code&gt; objects is rarely necessary,
  and may cause performance problems if done often enough. Also, &lt;code&gt;Boolean&lt;/code&gt;
  constructors are deprecated since Java 9 and could be removed or made
  inaccessible in future Java versions.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Boolean b1 = new Boolean(true);
  Boolean b2 = new Boolean(str);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Boolean b1 = Boolean.TRUE;
  Boolean b2 = Boolean.valueOf(str);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ManualArrayToCollectionCopy" defaultSeverity="WARNING" displayName="Manual array to collection copy" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code that uses a loop to copy the contents of an array into a collection.
&lt;p&gt;
  A shorter and potentially faster (depending on the collection implementation) way to do this is using &lt;code&gt;Collection.addAll(Arrays.asList())&lt;/code&gt; or &lt;code&gt;Collections.addAll()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
&lt;p&gt;Only loops without additional statements inside are reported.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void addAll(List&amp;lt;String&amp;gt; list, String[] arr) {
    for (int i = 0; i &amp;lt; arr.length; i++) {
      String s = arr[i];
      list.add(s);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void addAll(List&amp;lt;String&amp;gt; list, String[] arr) {
    Collections.addAll(list, arr);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstantiatingObjectToGetClassObject" defaultSeverity="WARNING" displayName="Instantiating object to get 'Class' object" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code that instantiates a class to get its class object.
&lt;p&gt;It is more performant to access the class object
  directly by name.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Class&amp;lt;?&amp;gt; c = new Sample().getClass();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Class&amp;lt;?&amp;gt; c = Sample.class;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExplicitArgumentCanBeLambda" defaultSeverity="INFORMATION" displayName="Explicit argument can be lambda" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method calls that accept a non-trivial expression and can be replaced with an equivalent method call
which accepts a lambda instead.
&lt;p&gt;
Converting an expression to a lambda ensures that the expression won't be evaluated
if it's not used inside the method. For example, &lt;code&gt;optional.orElse(createDefaultValue())&lt;/code&gt; can be converted
to &lt;code&gt;optional.orElseGet(this::createDefaultValue)&lt;/code&gt;.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DynamicRegexReplaceableByCompiledPattern" defaultSeverity="WARNING" displayName="Dynamic regular expression could be replaced by compiled 'Pattern'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to the regular expression methods (such as &lt;code&gt;matches()&lt;/code&gt; or &lt;code&gt;replace()&lt;/code&gt;)
of &lt;code&gt;java.lang.String&lt;/code&gt; using constants arguments.
&lt;p&gt;
  Such calls may be profitably replaced with a &lt;code&gt;private static final Pattern&lt;/code&gt; field
  so that the regular expression does not have to be compiled each time it is used.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  text.replace("abc", replacement);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private static final Pattern ABC = Pattern.compile("abc", Pattern.LITERAL);
  ABC.matcher(text).replaceAll(Matcher.quoteReplacement(replacement));
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BoxingBoxedValue" defaultSeverity="WARNING" displayName="Boxing of already boxed value" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports boxing of already boxed values.
&lt;p&gt;
  This is a redundant
  operation since any boxed value will first be auto-unboxed before boxing the
  value again. If done inside an inner loop, such code may cause performance
  problems.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer value = 1;
  method(Integer.valueOf(value));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer value = 1;
  method(value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectInstantiationInEqualsHashCode" defaultSeverity="WARNING" displayName="Object instantiation inside 'equals()' or 'hashCode()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports construction of (temporary) new objects inside &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt;, &lt;code&gt;compareTo()&lt;/code&gt;, and
&lt;code&gt;Comparator.compare()&lt;/code&gt; methods.
&lt;p&gt;
  Besides constructor invocations, new objects can also be created by autoboxing or iterator creation inside a
  &lt;code&gt;foreach&lt;/code&gt; statement.
  This can cause performance problems, for example, when objects are added to a &lt;code&gt;Set&lt;/code&gt; or &lt;code&gt;Map&lt;/code&gt;,
  where these methods will be called often.
&lt;/p&gt;
&lt;p&gt;
  The inspection will not report when the objects are created in a &lt;code&gt;throw&lt;/code&gt; or &lt;code&gt;assert&lt;/code&gt; statement.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    private String name;
    private int age;

    public boolean equals(Object o) {
      return Arrays.equals(new Object[] {name, age}, new Object[] {((Foo)o).name, ((Foo)o).age});
    }

    public int hashCode() {
      return (name + age).hashCode();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  In this example, two additional arrays are created inside &lt;code&gt;equals()&lt;/code&gt;, usages of &lt;code&gt;age&lt;/code&gt; field require boxing,
  and &lt;code&gt;name + age&lt;/code&gt; implicitly creates a new string.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectAllocationInLoop" defaultSeverity="WARNING" displayName="Object allocation in loop" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports object or array allocations inside loops. While not
necessarily a problem, an object allocation inside a loop is a great place to look for memory leaks
and performance issues.
&lt;p&gt;
  The inspection reports the following constructs:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Explicit allocations via &lt;code&gt;new&lt;/code&gt; operator&lt;/li&gt;
  &lt;li&gt;Methods known to return new object&lt;/li&gt;
  &lt;li&gt;Instance-bound method references&lt;/li&gt;
  &lt;li&gt;Lambdas that capture variables or &lt;code&gt;this&lt;/code&gt; reference&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Explicit allocation
  for (Status status : Status.values()) {
    declarationsMap.put(status, new ArrayList&amp;lt;&amp;gt;());
  }

  // Lambda captures variable
  String message = "Engine running.";
  for (Engine engine : engines) {
      if (!isRunning(engine)) {
          logger.warn(() -&gt; {
              return String.format(message);
          });
      }
  }

  // Instance-bound method reference
  for(Node node : nodes) {
    descriptor = node.getDescription();
    descriptor.ifPresent(dynamicTestExecutor::execute);
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TailRecursion" defaultSeverity="INFORMATION" displayName="Tail recursion" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports tail recursion, that is, when a method calls itself as its last action before returning.
&lt;p&gt;
  Tail recursion can always be replaced by looping, which will be considerably faster.
  Some JVMs perform tail-call optimization, while others do not. Thus, tail-recursive solutions may have considerably different
  performance characteristics on different virtual machines.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int factorial(int val, int runningVal) {
    if (val == 1) {
      return runningVal;
    } else {
      return factorial(val - 1, runningVal * val);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int factorial(int val, int runningVal) {
    while (true) {
      if (val == 1) {
        return runningVal;
      } else {
        runningVal = runningVal * val;
        val = val - 1;
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ManualArrayCopy" defaultSeverity="WARNING" displayName="Manual array copy" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports manual copying of array contents which can be replaced with &lt;code&gt;System.arraycopy()&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i = 0; i &amp;lt; array.length; i++) {
    newArray[i] = array[i];
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  System.arraycopy(array, 0, newArray, 0, array.length);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KeySetIterationMayUseEntrySet" defaultSeverity="WARNING" displayName="Iteration over 'keySet()' can be optimized" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports iterations over the &lt;code&gt;keySet()&lt;/code&gt; of a &lt;code&gt;java.util.Map&lt;/code&gt; instance,
where the iterated keys are used to retrieve the values from the map.
&lt;p&gt;
  Such iteration may be more efficient when replaced with an iteration over the
  &lt;code&gt;entrySet()&lt;/code&gt; or &lt;code&gt;values()&lt;/code&gt; (if the key is not actually used).
&lt;/p&gt;
&lt;p&gt;
  Similarly, &lt;code&gt;keySet().forEach(key -&amp;gt; ...)&lt;/code&gt;
  can be replaced with &lt;code&gt;forEach((key, value) -&amp;gt; ...)&lt;/code&gt; if values are retrieved
  inside a lambda.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Object key : map.keySet()) {
   Object val = map.get(key);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (Object val : map.values()) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SetReplaceableByEnumSet" defaultSeverity="WARNING" displayName="'Set' can be replaced with 'EnumSet'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instantiations of &lt;code&gt;java.util.Set&lt;/code&gt; objects whose content types are enumerated classes. Such &lt;code&gt;Set&lt;/code&gt; objects
can be replaced with &lt;code&gt;java.util.EnumSet&lt;/code&gt; objects.
&lt;p&gt;
  &lt;code&gt;EnumSet&lt;/code&gt; implementations can be much more efficient compared to
  other sets, as the underlying data structure is a bit vector. Use the quick-fix to replace the initializer with a call to
  &lt;code&gt;EnumSet.noneOf()&lt;/code&gt;. This quick-fix is not available when the type of the variable is a sub-class of &lt;code&gt;Set&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum MyEnum { FOO, BAR; }

  Set&amp;lt;MyEnum&amp;gt; enums = new HashSet&amp;lt;MyEnum&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum MyEnum { FOO, BAR; }

  Set&amp;lt;MyEnum&amp;gt; enums = EnumSet.noneOf(MyEnum.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArraysAsListWithZeroOrOneArgument" defaultSeverity="WARNING" displayName="Call to 'Arrays.asList()' with too few arguments" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Arrays.asList()&lt;/code&gt; with at most one argument.
&lt;p&gt;
  Such calls could be replaced
  with &lt;code&gt;Collections.singletonList()&lt;/code&gt;, &lt;code&gt;Collections.emptyList()&lt;/code&gt;,
  or &lt;code&gt;List.of()&lt;/code&gt; on JDK 9 and later, which will save some memory.&lt;/p&gt;
&lt;p&gt;In particular, &lt;code&gt;Collections.emptyList()&lt;/code&gt; and &lt;code&gt;List.of()&lt;/code&gt; with no arguments
  always return a shared instance,
  while &lt;code&gt;Arrays.asList()&lt;/code&gt; with no arguments creates a new object every time it's called.&lt;/p&gt;
&lt;p&gt;Note: the lists returned by &lt;code&gt;Collections.singletonList()&lt;/code&gt; and &lt;code&gt;List.of()&lt;/code&gt; are immutable,
while the list returned &lt;code&gt;Arrays.asList()&lt;/code&gt; allows calling the &lt;code&gt;set()&lt;/code&gt; method.
This may break the code in rare cases.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; empty = Arrays.asList();
  List&amp;lt;String&amp;gt; one = Arrays.asList("one");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;String&amp;gt; empty = Collections.emptyList();
  List&amp;lt;String&amp;gt; one = Collections.singletonList("one");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="XML" path=""><inspection shortName="XmlHighlighting" defaultSeverity="ERROR" displayName="XML highlighting" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports XML validation problems in the results of a batch code inspection.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlPathReference" defaultSeverity="ERROR" displayName="Unresolved file reference" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unresolved file reference in XML.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlWrongRootElement" defaultSeverity="ERROR" displayName="Wrong root element" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a root tag name different from the name specified in the &lt;code&gt;&amp;lt;doctype&amp;gt;&lt;/code&gt; tag.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlInvalidId" defaultSeverity="ERROR" displayName="Unresolved 'id' reference" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unresolved &lt;code&gt;id&lt;/code&gt; reference in XML.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeprecatedClassUsageInspection" defaultSeverity="WARNING" displayName="Deprecated API usage in XML" enabled="true" language="XML" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of deprecated classes and methods in XML files.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckXmlFileWithXercesValidator" defaultSeverity="ERROR" displayName="Failed external validation" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a discrepancy in an XML file with the specified DTD or schema detected by the Xerces validator.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlDefaultAttributeValue" defaultSeverity="WARNING" displayName="Redundant attribute with default value" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a redundant assignment of the default value to an XML attribute.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlUnusedNamespaceDeclaration" defaultSeverity="WARNING" displayName="Unused schema declaration" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unused namespace declaration or location hint in XML.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckTagEmptyBody" defaultSeverity="WARNING" displayName="Empty element content" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports XML elements without contents.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;user&gt;
    &amp;lt;name&gt;&amp;lt;/name&gt;
  &amp;lt;/user&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;user&gt;
    &amp;lt;name/&gt;
  &amp;lt;/user&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlDeprecatedElement" defaultSeverity="WARNING" displayName="Deprecated symbol" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a deprecated XML element or  attribute.
&lt;p&gt;Symbols can be marked by XML comment or documentation tag with text 'deprecated'.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CheckDtdRefs" defaultSeverity="ERROR" displayName="Unresolved DTD reference" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports inconsistency in a DTD-specific reference, for example, in a reference to an XML entity or to a DTD element declaration.
Works in DTD an XML files.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlUnboundNsPrefix" defaultSeverity="WARNING" displayName="Unbound namespace prefix" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unbound namespace prefix in XML.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="XmlDuplicatedId" defaultSeverity="ERROR" displayName="Duplicate 'id' attribute" enabled="true" language="XML" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a duplicate &lt;code&gt;id&lt;/code&gt; attribute in XML.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Assignment issues" path="Java"><inspection shortName="NestedAssignment" defaultSeverity="WARNING" displayName="Nested assignment" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignment expressions that are nested inside other expressions.
&lt;p&gt;Such expressions may be confusing and violate the general design principle, which states that any construct should do precisely one thing.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String userName;
  // Warning: result of assignment to 'userName' is used
  String message = "Hello " + (userName = "Alice") + "!"
  System.out.println(message);
  System.out.println("Goodbye " + userName);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceAssignmentWithOperatorAssignment" defaultSeverity="INFORMATION" displayName="Assignment can be replaced with operator assignment" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignment operations which can be replaced by operator-assignment.
&lt;p&gt;Code using operator assignment is shorter and may be clearer.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  x = x + 3;
  x = x / 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  x += 3;
  x /= 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore conditional operators&lt;/b&gt; option to ignore &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;
and &lt;code&gt;||&lt;/code&gt;. Replacing conditional operators with operator
assignment would change the evaluation from lazy to eager, which may change the semantics of the expression.
&lt;/p&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore obscure operators&lt;/b&gt; option to ignore &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt;, which are less known.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToLambdaParameter" defaultSeverity="WARNING" displayName="Assignment to lambda parameter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignment to, or modification of lambda parameters.
Although occasionally intended, this construct may be confusing and is often caused by a typo or use of a wrong variable.
&lt;p&gt;The quick-fix adds a declaration of a new variable.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  list.forEach(s -&gt; {
    s = s.trim();
    System.out.println("String: " + s);
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  list.forEach(s -&gt; {
    String trimmed = s.trim();
    System.out.println("String: " + trimmed);
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore if assignment is a transformation of the original parameter&lt;/b&gt; option to ignore assignments that modify the parameter
  value based on its previous value.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToSuperclassField" defaultSeverity="WARNING" displayName="Constructor assigns value to field defined in superclass" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignment to, or modification of fields that are declared in a superclass from within a subclass constructor.
&lt;p&gt;It is considered preferable to initialize the fields of a superclass in its own constructor and
  delegate to that constructor in a subclass. This will also allow declaring a field &lt;code&gt;final&lt;/code&gt;
  if it isn't changed after the construction.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    int x;
  }
  class Sub extends Super {
    Sub(int _x) {
      // Warning: x is declared in a superclass
      x = _x;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To avoid the problem, declare a superclass constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    final int x;

    Super(int _x) {
      x = _x;
    }
  }
  class Sub extends Super {
    Sub(int _x) {
      super(_x);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToStaticFieldFromInstanceMethod" defaultSeverity="WARNING" displayName="Assignment to static field from instance context" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignment to, or modification of &lt;code&gt;static&lt;/code&gt; fields from within an instance method.
&lt;p&gt;Although legal, such assignments are tricky to do
  safely and are often a result of marking fields &lt;code&gt;static&lt;/code&gt; inadvertently.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Counter {
    private static int count = 0;

    void increment() {
      // Warning: updating a static field
      // from an instance method
      count++;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToNull" defaultSeverity="WARNING" displayName="'null' assignment" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports variables that are assigned to &lt;code&gt;null&lt;/code&gt; outside a declaration.
&lt;p&gt;The main purpose of &lt;code&gt;null&lt;/code&gt; in Java is to denote uninitialized
  reference variables. In rare cases, assigning a variable explicitly to &lt;code&gt;null&lt;/code&gt;
  is useful to aid garbage collection. However, using &lt;code&gt;null&lt;/code&gt; to denote a missing, not specified, or invalid value or a not
  found element is considered bad practice and may make your code more prone to &lt;code&gt;NullPointerExceptions&lt;/code&gt;.
  Instead, consider defining a sentinel object with the intended semantics
  or use library types like &lt;code&gt;Optional&lt;/code&gt; to denote the absence of a value.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Integer convert(String s) {
    Integer value;
    try {
      value = Integer.parseInt(s);
    } catch (NumberFormatException e) {
      // Warning: null is used to denote an 'invalid value'
      value = null;
    }
    return value;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore assignments to fields&lt;/b&gt; option to ignore assignments to fields.
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToCatchBlockParameter" defaultSeverity="WARNING" displayName="Assignment to 'catch' block parameter" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignments to, &lt;code&gt;catch&lt;/code&gt; block parameters.
&lt;p&gt;Changing a &lt;code&gt;catch&lt;/code&gt; block parameter is very confusing and should be discouraged.&lt;/p&gt;
&lt;p&gt;The quick-fix adds a declaration of a new variable.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void processFile(String fileName) throws Exception {
    try {
      doProcessFile(fileName);
    } catch(Exception ex) {
      if (ex instanceof UncheckedIOException) {
        // Warning: catch block parameter reassigned
        ex = ((UncheckedIOException) ex).getCause();
      }
      throw ex;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void processFile(String fileName) throws Exception {
    try {
      doProcessFile(fileName);
    } catch(Exception ex) {
      Exception unwrapped = ex;
      if (unwrapped instanceof UncheckedIOException) {
        unwrapped = ((UncheckedIOException)
          unwrapped).getCause();
      }
      throw unwrapped;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncrementDecrementUsedAsExpression" defaultSeverity="WARNING" displayName="Result of '++' or '--' used" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports increment or decrement expressions that are nested inside other expressions.
Such expressions may be confusing and violate the general design principle, which states that any construct should do precisely one thing.
&lt;p&gt;The quick-fix extracts the increment or decrement operation to a separate expression statement.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 10;
  while (i-- &gt; 0) {
    System.out.println(i);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int i = 10;
  while (i &gt; 0) {
    i--;
    System.out.println(i);
  }
  i--;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToMethodParameter" defaultSeverity="WARNING" displayName="Assignment to method parameter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignment to, or modification of method parameters.
&lt;p&gt;Although occasionally intended, this construct may be confusing
  and is therefore prohibited in some Java projects.&lt;/p&gt;
&lt;p&gt;The quick-fix adds a declaration of a new variable.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void printTrimmed(String s) {
    s = s.trim();
    System.out.println(s);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void printTrimmed(String s) {
    String trimmed = s.trim();
    System.out.println(trimmed);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignore if assignment is a transformation of the original parameter&lt;/b&gt; option to ignore assignments that modify
  the parameter value based on its previous value.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentToForLoopParameter" defaultSeverity="WARNING" displayName="Assignment to 'for' loop parameter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignment to, or modification of a &lt;code&gt;for&lt;/code&gt; loop parameter inside the body of the loop.
&lt;p&gt;Although occasionally intended, this construct may be confusing and is often the result of a typo or a wrong variable being used.&lt;/p&gt;
&lt;p&gt;The quick-fix adds a declaration of a new variable.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String s : list) {
    // Warning: s is changed inside the loop
    s = s.trim();
    System.out.println("String: " + s);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (String s : list) {
    String trimmed = s.trim();
    System.out.println("String: " + trimmed);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assignments in basic &lt;code&gt;for&lt;/code&gt; loops without an update statement are not reported.
  In such cases the assignment is probably intended and can't be easily moved to the update part of the &lt;code&gt;for&lt;/code&gt; loop.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (int i = 0; i &amp;lt; list.size(); ) {
    if (element.equals(list.get(i))) {
      list.remove(i);
    } else {
      // modification of for loop parameter is not reported
      // as there's no update statement
      i++;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Check enhanced 'for' loop parameters&lt;/b&gt; option to specify whether modifications of enhanced &lt;code&gt;for&lt;/code&gt; loop parameters
  should be also reported.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentUsedAsCondition" defaultSeverity="WARNING" displayName="Assignment used as condition" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignments that are used as a condition of an &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, or
&lt;code&gt;do&lt;/code&gt; statement, or a conditional expression.
&lt;p&gt;Although occasionally intended, this usage is confusing and may indicate a typo, for example, &lt;code&gt;=&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces &lt;code&gt;=&lt;/code&gt; with &lt;code&gt;==&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void update(String str, boolean empty) {
    // Warning: 'empty' is reassigned,
    // not compared to str.isEmpty()
    if (empty = str.isEmpty()) {
      ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void update(String str, boolean empty) {
    if (empty == str.isEmpty()) {
      ...
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Properties files" path="Java"><inspection shortName="UnresolvedPropertyKey" defaultSeverity="ERROR" displayName="Invalid property key" enabled="true" language="JAVA" pluginId="com.intellij.java-i18n" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports invalid arguments that are passed to methods with parameters annotated as &lt;code&gt;@PropertyKey&lt;/code&gt;.
&lt;p&gt;These arguments should be valid property keys in corresponding properties files.
Also, the inspection verifies that the &lt;code&gt;resourceBundle&lt;/code&gt;
  argument of the &lt;code&gt;@PropertyKey&lt;/code&gt; annotation is an existing resource bundle.&lt;/p&gt;
&lt;p&gt;
  Use the quick-fix to create a new property or to select an existing one.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @PropertyKey(resourceBundle = "myBundle") String value = "invalid.key";
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Annotations" path="Groovy"><inspection shortName="DelegatesTo" defaultSeverity="WARNING" displayName="@DelegatesTo" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unused &lt;code&gt;@DelegatesTo.Target&lt;/code&gt; annotations and unresolved &lt;code&gt;@DelegatedTo.target&lt;/code&gt; annotation attribute values.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // unused target 't1' and unresolved target 't2'
  def m(
      @DelegatesTo.Target('t1') target,
      @DelegatesTo(target = 't2') Closure c
  ) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrNamedVariantLabels" defaultSeverity="WARNING" displayName="@NamedVariant/@NamedParam/@NamedDelegate unresolved label" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unresolved argument labels in calls of methods annotated
by &lt;code&gt;@NamedVariant&lt;/code&gt;/&lt;code&gt;@NamedParam&lt;/code&gt;/&lt;code&gt;@NamedDelegate&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @groovy.transform.NamedVariant
  def foo(a, b) {}

  // unresolved label 'c'
  foo(a: 1, b: 2, c: 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SingletonConstructor" defaultSeverity="ERROR" displayName="@Singleton constructors" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports constructors of classes annotated by &lt;code&gt;@Singleton&lt;/code&gt; unless it is declared non-strict.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton
  class Foo{
      Foo(){
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two possible quick-fixes: either to remove the constructor or to declare &lt;code&gt;@Singleton&lt;/code&gt; non-strict.&lt;/p&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton
  class Foo{
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Singleton(&lt;b&gt;strict = false&lt;/b&gt;)
  class Foo{
      Foo(){
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrAnnotationReferencingUnknownIdentifiers" defaultSeverity="WARNING" displayName="@TupleConstructor and @MapConstructor" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unresolved identifiers in &lt;code&gt;@TupleConstructor&lt;/code&gt; and &lt;code&gt;@MapConstructor&lt;/code&gt;
&lt;code&gt;includes&lt;/code&gt; and &lt;code&gt;excludes&lt;/code&gt; annotation attribute values.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // unresolved 'c'
  @TupleConstructor(includes = ['a', 'b', 'c'])
  class X {
      def a
      def b
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GrPOJO" defaultSeverity="WARNING" displayName="@POJO without @CompileStatic" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports annotation &lt;code&gt;@groovy.transform.stc.POJO&lt;/code&gt; applied without &lt;code&gt;@groovy.transform.CompileStatic&lt;/code&gt;.&lt;p&gt;
&lt;p&gt;Annotation &lt;code&gt;@POJO&lt;/code&gt; changes compilation process of Groovy classes to bytecode. It has no effect without explicitly enabled static compilation (which is done via &lt;code&gt;@CompileStatic&lt;/code&gt; annotation).
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @POJO // reports @POJO
  class A {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Class structure" path="Java"><inspection shortName="Singleton" defaultSeverity="WARNING" displayName="Singleton" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports singleton classes.
&lt;p&gt;Singleton classes are declared in a way that only one instance of the class can ever be instantiated. Singleton classes complicate testing,
  and their presence may indicate a lack of object-oriented design.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Singleton {
    private static final Singleton ourInstance = new Singleton();

    private Singleton() {
    }

    public Singleton getInstance() {
        return ourInstance;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticNonFinalField" defaultSeverity="WARNING" displayName="'static', non-'final' field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-&lt;code&gt;final&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; fields.
&lt;p&gt;A quick-fix is available to add the &lt;code&gt;final&lt;/code&gt; modifier to a non-&lt;code&gt;final&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; field.&lt;/p&gt;
&lt;p&gt;This inspection doesn't check fields' mutability. For example, adding the &lt;code&gt;final&lt;/code&gt; modifier to a field that has a value
  being set somewhere will cause a compilation error.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Only report 'public' fields&lt;/b&gt; option so that the inspection reported only &lt;code&gt;public&lt;/code&gt; fields.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantDeclaredInAbstractClass" defaultSeverity="WARNING" displayName="Constant declared in 'abstract' class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports constants (&lt;code&gt;public static final&lt;/code&gt; fields) declared in abstract
classes.
&lt;p&gt;Some coding standards require declaring constants in interfaces instead.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassMayBeInterface" defaultSeverity="INFORMATION" displayName="Abstract 'class' may be 'interface'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;abstract&lt;/code&gt; classes that can be converted to interfaces.
&lt;p&gt;Using interfaces instead of classes is preferable as Java doesn't support multiple class inheritance,
  while a class can implement multiple interfaces.&lt;/p&gt;
&lt;p&gt;A class may be converted to an interface if it has no superclasses (other
than Object), has only &lt;code&gt;public static final&lt;/code&gt; fields,
  &lt;code&gt;public abstract&lt;/code&gt; methods, and &lt;code&gt;public&lt;/code&gt; inner classes.
&lt;!-- tooltip end --&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
abstract class Example {
    public static final int MY_CONST = 42;
    public abstract void foo();
}

class Inheritor extends Example {
    @Override
    public void foo() {
        System.out.println(MY_CONST);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
interface Example {
    int MY_CONST = 42;
    void foo();
}

class Inheritor implements Example {
    @Override
    public void foo() {
        System.out.println(MY_CONST);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;
  Use the &lt;b&gt;Report classes containing non-abstract methods when using Java 8&lt;/b&gt; option to report only the classes with &lt;code&gt;static&lt;/code&gt; methods and non-abstract methods that can be converted to
  &lt;code&gt;default&lt;/code&gt; methods (only applicable to language level of 8 or higher).
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UtilityClassWithPublicConstructor" defaultSeverity="WARNING" displayName="Utility class with 'public' constructor" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports utility classes with &lt;code&gt;public&lt;/code&gt; constructors.
&lt;p&gt;Utility classes have all fields and methods declared as &lt;code&gt;static&lt;/code&gt;. Creating a &lt;code&gt;public&lt;/code&gt;
  constructor in such classes is confusing and may cause accidental class instantiation.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MarkerInterface" defaultSeverity="WARNING" displayName="Marker interface" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports marker interfaces without any methods or fields.
&lt;p&gt;Such interfaces may be confusing and typically indicate a design failure.&lt;/p&gt;
&lt;p&gt;The inspection ignores interfaces that extend two or more interfaces and interfaces
  that specify the generic type of their superinterface.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyClass" defaultSeverity="WARNING" displayName="Redundant empty class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports empty classes and Java files without any defined classes.
&lt;p&gt;A class is empty if it
doesn't contain any fields, methods, constructors, or initializers. Empty classes often remain
  after significant changes or refactorings.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Ignore if annotated by&lt;/b&gt; option to specify special annotations. The inspection will ignore the classes marked with these
    annotations.
  &lt;/li&gt;
  &lt;li&gt;&lt;p&gt;
    Use the &lt;b&gt;Ignore class if it is a parametrization of a super type&lt;/b&gt; option to ignore classes that parameterize a superclass. For example:
  &lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;class MyList extends ArrayList&amp;lt;String&amp;gt; {}&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Ignore subclasses of java.lang.Throwable&lt;/b&gt; to ignore classes that extend &lt;code&gt;java.lang.Throwable&lt;/code&gt;.
  &lt;/li&gt;
  &lt;li&gt;
    Use the &lt;b&gt;Comments count as content&lt;/b&gt; option to ignore classes that contain comments.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinalClass" defaultSeverity="WARNING" displayName="Class is closed to inheritance" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that are declared &lt;code&gt;final&lt;/code&gt;.
Such classes can't be inherited and may indicate a lack of object-oriented design.
  Some coding standards discourage &lt;code&gt;final&lt;/code&gt; classes.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalUtilityClass" defaultSeverity="WARNING" displayName="Utility class is not 'final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports utility classes that aren't &lt;code&gt;final&lt;/code&gt;.
&lt;p&gt;Utility classes have all fields and methods declared as &lt;code&gt;static&lt;/code&gt;.
  Making them &lt;code&gt;final&lt;/code&gt; prevents them from being accidentally subclassed.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UtilityClassWithoutPrivateConstructor" defaultSeverity="WARNING" displayName="Utility class without 'private' constructor" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports utility classes without &lt;code&gt;private&lt;/code&gt; constructors.
&lt;p&gt;Utility classes have all fields and methods declared as &lt;code&gt;static&lt;/code&gt;. Creating &lt;code&gt;private&lt;/code&gt;
constructors in utility classes prevents them from being accidentally instantiated.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignore if annotated by&lt;/b&gt; option to specify special annotations. The inspection ignores classes marked with one of
these annotations.
&lt;p&gt;
Use the &lt;b&gt;Ignore classes with only a main method&lt;/b&gt; option to ignore classes with no methods other than the main one.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LimitedScopeInnerClass" defaultSeverity="WARNING" displayName="Local class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local classes.
&lt;p&gt;A local class is a named nested class declared inside a code block.
Local classes are uncommon and may therefore be confusing.
  In addition, some code standards discourage the use of local classes.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test() {
    class Local { // local class
    }
    new Local();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MultipleTopLevelClassesInFile" defaultSeverity="WARNING" displayName="Multiple top level classes in single file" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports multiple top-level classes in a single Java file.
&lt;p&gt;Putting multiple
top-level classes in one file may be confusing and degrade the usefulness of various
  software tools.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousInnerClass" defaultSeverity="WARNING" displayName="Anonymous inner class can be replaced with inner class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports anonymous inner classes.
&lt;p&gt;In some cases, replacing anonymous inner classes with inner classes can lead to more readable and maintainable code.
  Also, some code standards discourage anonymous inner classes.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassWithOnlyPrivateConstructors" defaultSeverity="WARNING" displayName="Class with only 'private' constructors should be declared 'final'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes with only &lt;code&gt;private&lt;/code&gt; constructors.
&lt;p&gt;A class that only has &lt;code&gt;private&lt;/code&gt; constructors cannot be extended outside a file and should be declared as &lt;code&gt;final&lt;/code&gt;.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassInitializer" defaultSeverity="WARNING" displayName="Non-'static' initializer" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-&lt;code&gt;static&lt;/code&gt; initializers in classes.
&lt;p&gt;Some coding standards prohibit instance initializers and recommend using constructors or field initializers for initialization.
  Also, deleting the &lt;code&gt;static&lt;/code&gt; keyword may accidentally create non-&lt;code&gt;static&lt;/code&gt; initializers and result in obscure bugs.
&lt;/p&gt;
&lt;p&gt;This inspection doesn't report instance initializers in anonymous classes.
  &lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Only warn when the class has one or more constructors&lt;/b&gt; option to ignore instance initializers in classes that don't have any constructors.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InnerClassOnInterface" defaultSeverity="WARNING" displayName="Inner class of interface" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports inner classes in &lt;code&gt;interface&lt;/code&gt; classes.
&lt;p&gt;Some coding standards
discourage the use of such classes. The inspection doesn't report enumeration and annotation classes.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore inner interfaces of interfaces&lt;/b&gt; option to ignore inner interfaces. For example:
&lt;pre&gt;&lt;code&gt;
  interface I {
    interface Inner {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UtilityClassCanBeEnum" defaultSeverity="WARNING" displayName="Utility class can be 'enum'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports utility classes that can be converted to enums.
&lt;p&gt;Some coding style guidelines declare to implement utility classes as enums
  to avoid code coverage issues in &lt;code&gt;private&lt;/code&gt; constructors.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class StringUtils {
    public static final String EMPTY = "";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum StringUtils {
    ;
    public static final String EMPTY = "";
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicConstructor" defaultSeverity="WARNING" displayName="'public' constructor can be replaced with factory method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;public&lt;/code&gt; constructors.
&lt;p&gt;Some coding standards discourage the use of &lt;code&gt;public&lt;/code&gt; constructors and recommend
&lt;code&gt;static&lt;/code&gt; factory methods instead.
This way the implementation can be swapped out without affecting the call sites.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    private String name;

    public Test(String name) {
        this.name = name;
    }

    public void test() {
        System.out.println(name);
    }

    public static void main(String[] args) {
        new Test("str").test();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    private String name;

    private Test(String name) {
        this.name = name;
    }

    public static Test getInstance(String name) {
        return new Test(name);
    }

    public void test() {
        System.out.println(name);
    }

    public static void main(String[] args) {
        getInstance("str").test();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinalStaticMethod" defaultSeverity="WARNING" displayName="'static' method declared 'final'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports static methods that are marked as &lt;code&gt;final&lt;/code&gt;.
&lt;p&gt;Such code might indicate an error or an incorrect assumption about the effect of the &lt;code&gt;final&lt;/code&gt; keyword.
Static methods are not subject to runtime polymorphism, so the only purpose of the &lt;code&gt;final&lt;/code&gt; keyword used with static methods
  is to ensure the method will not be hidden in a subclass.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterCanBeLocal" defaultSeverity="WARNING" displayName="Value passed as parameter never read" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant method parameters that can be replaced with local variables.
&lt;p&gt;If all local usages of a parameter are preceded by assignments to that parameter, the
parameter can be removed and its usages replaced with local variables.
It makes no sense to have such a parameter, as values that are passed to it are overwritten.
  Usually, the problem appears as a result of refactoring.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(int p) {
    p = 1;
    System.out.print(p);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test() {
    int p = 1;
    System.out.print(p);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InterfaceMayBeAnnotatedFunctional" defaultSeverity="WARNING" displayName="Interface may be annotated as '@FunctionalInterface'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports interfaces that can be annotated with &lt;code&gt;@FunctionalInterface&lt;/code&gt; (available since JDK 1.8).
&lt;p&gt;Annotating an interface with &lt;code&gt;@FunctionalInterface&lt;/code&gt; indicates that the interface
  is functional and cannot have any more &lt;code&gt;abstract&lt;/code&gt; methods.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 8 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantDeclaredInInterface" defaultSeverity="WARNING" displayName="Constant declared in interface" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports constants (&lt;code&gt;public static final&lt;/code&gt; fields) declared in interfaces.
&lt;p&gt;Some coding standards require declaring constants in abstract classes instead.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NoopMethodInAbstractClass" defaultSeverity="WARNING" displayName="No-op method in 'abstract' class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports no-op (for "no operation") methods in &lt;code&gt;abstract&lt;/code&gt; classes.
&lt;p&gt;It is usually a better
design to make such methods &lt;code&gt;abstract&lt;/code&gt; themselves so that classes inheriting these
  methods provide their implementations.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class Test {
    protected void doTest() {
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodReturnAlwaysConstant" defaultSeverity="WARNING" displayName="Method returns per-class constant" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports methods that only return a constant, which may differ for various inheritors.
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldCanBeLocal" defaultSeverity="WARNING" displayName="Field can be local" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant class fields that can be replaced with local variables.
&lt;p&gt;If all local usages of a field are preceded by assignments to that field, the
  field can be removed, and its usages can be replaced with local variables.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FinalPrivateMethod" defaultSeverity="WARNING" displayName="'private' method declared 'final'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that are marked with both &lt;code&gt;final&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; keywords.
&lt;p&gt;Since &lt;code&gt;private&lt;/code&gt; methods cannot be meaningfully overridden because of their visibility, declaring them
&lt;code&gt;final&lt;/code&gt; is redundant.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassNameDiffersFromFileName" defaultSeverity="WARNING" displayName="Class name differs from file name" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports top-level class names that don't match the name of a file containing them.
&lt;p&gt;While the Java specification allows for naming non-&lt;code&gt;public&lt;/code&gt; classes this way,
  files with unmatched names may be confusing and decrease usefulness of various software tools.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UtilityClass" defaultSeverity="WARNING" displayName="Utility class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports utility classes.
&lt;p&gt;Utility classes have all fields and methods declared as &lt;code&gt;static&lt;/code&gt; and their
  presence may indicate a lack of object-oriented design.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore if annotated by&lt;/b&gt; option to specify special annotations. The inspection ignores classes annotated with one of
  these annotations.&lt;/p&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonFinalFieldInEnum" defaultSeverity="WARNING" displayName="Non-final field in 'enum'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-final fields in enumeration types as they are rarely needed and provide a global mutable state.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum Enum {
    FIRST("first"),
    SECOND("second");

    public String str;

    Enum(String str) {
        this.str = str;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum Enum {
    FIRST("first"),
    SECOND("second");

    public final String str;

    Enum(String str) {
        this.str = str;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
Configure the `Ignore field if quick-fix is not available` checkbox to only highlight fields that can be made final by the quick-fix.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FinalMethod" defaultSeverity="WARNING" displayName="Method can't be overridden" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that are declared &lt;code&gt;final&lt;/code&gt;.
Such methods can't be overridden and may indicate a lack of object-oriented design.
  Some coding standards discourage &lt;code&gt;final&lt;/code&gt; methods.
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ListenerMayUseAdapter" defaultSeverity="WARNING" displayName="Class may extend adapter instead of implementing listener" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes implementing listeners instead of extending corresponding adapters.
&lt;p&gt;A quick-fix is available to
  remove any redundant empty methods left after replacing a listener implementation with an adapter extension.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Only warn when empty implementing methods are found&lt;/b&gt; option to configure the inspection to warn even if no empty methods are found.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="General" path="C/C++"><inspection shortName="MissingSwitchCase" defaultSeverity="WARNING" displayName="Missing switch case" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the &lt;code&gt;switch&lt;/code&gt; statements that do not include all of the enumerated type's elements as cases.
It also reports the &lt;code&gt;switch&lt;/code&gt; statements over integer type that do not include the &lt;code&gt;default:&lt;/code&gt; branch.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OCInconsistentNaming" defaultSeverity="WEAK WARNING" displayName="Inconsistent Naming" enabled="false" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the names that don't match the naming convention for that kind of symbol.
&lt;p&gt;&lt;small&gt;&lt;a href="https://www.jetbrains.com/help/clion/naming-conventions.html"&gt;Learn More.&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InitializerIssues" defaultSeverity="WARNING" displayName="Initializer issues" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the incorrect usages of the declarator initializers.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OtherCpp" defaultSeverity="WARNING" displayName="Other cpp" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports other problems related to C/C++.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VirtualCallInCtorOrDtor" defaultSeverity="WARNING" displayName="Virtual call from constructor or destructor" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports virtual member function calls from constructors or destructors.
Since construction starts with the base class and moves to the derived classes, the resources of the derived class are not yet initialized.
Destruction is performed in reverse order, so calling a virtual function can lead to accessing the resources that have already been destroyed.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
  public:
      void virtual setUp();

      Test() {
          setUp();
      }
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PreprocessorComment" defaultSeverity="WARNING" displayName="Preprocessor directive comment" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the mismatches between the preprocessor &lt;code&gt;#endif&lt;/code&gt; comments and macro names.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  #ifndef _UTILS_H
  #define _UTILS_H

  #endif //_UTILS
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualityInConditionalOperator" defaultSeverity="WARNING" displayName="'=' in conditional expression" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Detects the conditional expressions where the &lt;code&gt;=&lt;/code&gt; operator is used on the top level.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Simplify" defaultSeverity="WARNING" displayName="Simplifiable statement" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the statements that can be simplified, such as constant conditions, identical if branches, redundant boolean expressions, and others.
Use the checkboxes below to control the analysis options:
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Simplify "if (true)", "while(false)"&lt;/b&gt;: suggest replacing the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; statement with a boolean literal.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Simplify "condition == true"&lt;/b&gt;: suggest replacing equality statements with boolean literals.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Simplify "condition1 ? true : condition2;"&lt;/b&gt;: suggest simplifying ternary operators where one of the expressions is a boolean literal.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;Simplify "if (condition1) return true; return condition2;"&lt;/b&gt;: suggest simplifying &lt;code&gt;if&lt;/code&gt; where a boolean literal is
    returned if the condition is true and another condition is returned otherwise.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyDeclOrStmt" defaultSeverity="WARNING" displayName="Empty declaration or statement" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports empty declarations and statements that can be removed safely.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo() {
    //code
  }; // redundant empty declaration
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnconstrainedVariableType" defaultSeverity="WARNING" displayName="Unconstrained variable type" enabled="false" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports cases where an expression constrained by a concept is assigned to a variable declared as &lt;code&gt;auto&lt;/code&gt; and suggests adding a type constraint.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  template&amp;lt;class T&amp;gt;
  concept Foo = true;

  Foo auto func() { return true; }

  void bar() {
      auto f = func(); //warn here to add constraint 'Foo'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConstructionIsNotAllowed" defaultSeverity="WARNING" displayName="Construction is not allowed" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports illegal constructions.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FormatSpecifiers" defaultSeverity="WARNING" displayName="Format specifiers" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the calls to the string format functions (for example, &lt;code&gt;NSLog&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, and so on) that have inconsistent format specifier or argument types/count.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClangdErrorsAndWarnings" defaultSeverity="WARNING" displayName="Clangd errors and warnings" enabled="true" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports C/C++ errors and warnings from clangd.&lt;br/&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeprecatedApi" defaultSeverity="WARNING" displayName="Usage of deprecated API" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports deprecated code usages in a specified inspection scope.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArgumentSelectionDefects" defaultSeverity="WARNING" displayName="Argument selection defect" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports mismatches between the argument identifier name and the formal parameter name.
This can help detect programming errors, for example, when you accidentally switch the arguments of the same type.
The original research paper can be found &lt;a href="https://static.googleusercontent.com/media/research.google.com/ru//pubs/archive/46317.pdf"&gt;here&lt;/a&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  const User* get_User(int64_t company_id, int64_t user_id) {
    return new User{company_id, user_id, "foo"};
  }

  void call_User(int64_t company_id, int64_t user_id) {
    const User* user = get_User(user_id, company_id); // potential issue here
    //...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the checkbox below to inspect arguments with names shorter than three symbols.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;&lt;a href="https://www.jetbrains.com/help/clion/argument-selection-defects-inspection.html"&gt;Learn More.&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DuplicateSwitchCase" defaultSeverity="WARNING" displayName="Duplicate switch case" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports duplicated case expressions and overlapping case ranges in the &lt;code&gt;switch&lt;/code&gt; statements.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ResourceNotFound" defaultSeverity="WARNING" displayName="Resource not found" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the unresolved references to the resources (NIBs, images, and so on).
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Internationalization" path="Android/Lint/Internationalization"><inspection shortName="AndroidLintRtlHardcoded" defaultSeverity="WARNING" displayName="Using left/right instead of start/end attributes" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using left/right instead of start/end attributes&lt;br&gt;&lt;br&gt;Using &lt;code&gt;Gravity#LEFT&lt;/code&gt; and &lt;code&gt;Gravity#RIGHT&lt;/code&gt; can lead to problems when a layout is rendered in locales where text flows from right to left. Use &lt;code&gt;Gravity#START&lt;/code&gt; and &lt;code&gt;Gravity#END&lt;/code&gt; instead. Similarly, in XML &lt;code&gt;gravity&lt;/code&gt; and &lt;code&gt;layout_gravity&lt;/code&gt; attributes, use &lt;code&gt;start&lt;/code&gt; rather than &lt;code&gt;left&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
For XML attributes such as paddingLeft and &lt;code&gt;layout_marginLeft&lt;/code&gt;, use &lt;code&gt;paddingStart&lt;/code&gt; and &lt;code&gt;layout_marginStart&lt;/code&gt;. &lt;b&gt;NOTE&lt;/b&gt;: If your &lt;code&gt;minSdkVersion&lt;/code&gt; is less than 17, you should add &lt;b&gt;both&lt;/b&gt; the older left/right attributes &lt;b&gt;as well as&lt;/b&gt; the new start/end attributes. On older platforms, where RTL is not supported and the start/end attributes are unknown and therefore ignored, you need the older left/right attributes. There is a separate lint check which catches that type of error.&lt;br/&gt;
&lt;br/&gt;
(Note: For &lt;code&gt;Gravity#LEFT&lt;/code&gt; and &lt;code&gt;Gravity#START&lt;/code&gt;, you can use these constants even when targeting older platforms, because the &lt;code&gt;start&lt;/code&gt; bitmask is a superset of the &lt;code&gt;left&lt;/code&gt; bitmask. Therefore, you can use &lt;code&gt;gravity="start"&lt;/code&gt; rather than &lt;code&gt;gravity="left|start"&lt;/code&gt;.)&lt;br&gt;&lt;br&gt;Issue id: RtlHardcoded&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRtlCompat" defaultSeverity="ERROR" displayName="Right-to-left text compatibility issues" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Right-to-left text compatibility issues&lt;br&gt;&lt;br&gt;API 17 adds a &lt;code&gt;textAlignment&lt;/code&gt; attribute to specify text alignment. However, if you are supporting older versions than API 17, you must &lt;b&gt;also&lt;/b&gt; specify a gravity or layout_gravity attribute, since older platforms will ignore the &lt;code&gt;textAlignment&lt;/code&gt; attribute.&lt;br&gt;&lt;br&gt;Issue id: RtlCompat&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRtlEnabled" defaultSeverity="WARNING" displayName="Using RTL attributes without enabling RTL support" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Using RTL attributes without enabling RTL support&lt;br&gt;&lt;br&gt;To enable right-to-left support, when running on API 17 and higher, you must set the &lt;code&gt;android:supportsRtl&lt;/code&gt; attribute in the manifest &lt;code&gt;&amp;lt;application&gt;&lt;/code&gt; element.&lt;br/&gt;
&lt;br/&gt;
If you have started adding RTL attributes, but have not yet finished the migration, you can set the attribute to false to satisfy this lint check.&lt;br&gt;&lt;br&gt;Issue id: RtlEnabled&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRtlSymmetry" defaultSeverity="WARNING" displayName="Padding and margin symmetry" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Padding and margin symmetry&lt;br&gt;&lt;br&gt;If you specify padding or margin on the left side of a layout, you should probably also specify padding on the right side (and vice versa) for right-to-left layout symmetry.&lt;br&gt;&lt;br&gt;Issue id: RtlSymmetry&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Code maturity" path="Java"><inspection shortName="ThrowablePrintedToSystemOut" defaultSeverity="WARNING" displayName="'Throwable' printed to 'System.out'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;System.out.println()&lt;/code&gt; with an exception as an argument.
&lt;p&gt;Using print statements for logging exceptions hides the stack trace from you, which can complicate the investigation of the problem.
  It is recommended that you use logger instead.&lt;/p&gt;
&lt;p&gt;Calls to &lt;code&gt;System.out.print()&lt;/code&gt;, &lt;code&gt;System.err.println()&lt;/code&gt;, and &lt;code&gt;System.err.print()&lt;/code&gt; with an exception argument are also
reported. It is better to use a logger to log exceptions instead.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;For example, instead of:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      foo();
  } catch (Exception e) {
      System.out.println(e);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;use the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
      foo();
  } catch (Exception e) {
      logger.warn(e); // logger call may be different
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuppressionAnnotation" defaultSeverity="WARNING" displayName="Inspection suppression annotation" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports comments or annotations suppressing inspections.
&lt;p&gt;This inspection can be useful when leaving suppressions intentionally for further review.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    @SuppressWarnings("unused")
    static Stream&amp;lt;String&amp;gt; stringProvider() {
        return Stream.of("foo", "bar");
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowablePrintStackTrace" defaultSeverity="WARNING" displayName="Call to 'printStackTrace()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Throwable.printStackTrace()&lt;/code&gt; without arguments.
&lt;p&gt;Such statements are often used for temporary debugging and should be either removed from the production code
  or replaced with a more robust logging facility.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfObsoleteDateTimeApi" defaultSeverity="WARNING" displayName="Use of obsolete date-time API" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;java.util.Date&lt;/code&gt;, &lt;code&gt;java.util.Calendar&lt;/code&gt;, &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt;, &lt;code&gt;java.util.TimeZone&lt;/code&gt;,
and &lt;code&gt;java.util.SimpleTimeZone&lt;/code&gt;.
&lt;p&gt;While still supported, these classes were made obsolete by the JDK8 Date-Time API and should probably
  not be used in new development.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantScheduledForRemovalAnnotation" defaultSeverity="WARNING" displayName="Redundant @ScheduledForRemoval annotation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;@ApiStatus.ScheduledForRemoval&lt;/code&gt; annotation without &lt;code&gt;inVersion&lt;/code&gt; attribute in code which targets Java 9 or newer version.
&lt;p&gt;
Such usages can be replaced by &lt;code&gt;forRemoval&lt;/code&gt; attribute in &lt;code&gt;@Deprecated&lt;/code&gt; annotation to simplify code.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2022.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadDumpStack" defaultSeverity="WARNING" displayName="Call to 'Thread.dumpStack()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;Thread.dumpStack()&lt;/code&gt;.
&lt;p&gt;Such statements are often used for temporary debugging and should be either removed from the production code
  or replaced with a more robust logging facility.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeprecatedIsStillUsed" defaultSeverity="WARNING" displayName="Deprecated member is still used" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports deprecated classes, methods, and fields that are used in your code nonetheless.
&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  class MyCode {
    @Deprecated
    void oldMethod() {}// warning: "Deprecated member is still used"

    void newMethod() {
      oldMethod(); // forgotten usage
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Usages within deprecated elements are ignored.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SystemOutErr" defaultSeverity="WARNING" displayName="Use of 'System.out' or 'System.err'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;System.out&lt;/code&gt; or &lt;code&gt;System.err&lt;/code&gt;.
&lt;p&gt;Such statements are often used for temporary debugging and should be either removed from the production code, or replaced by a more robust
  logging facility.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Deprecation" defaultSeverity="WARNING" displayName="Deprecated API usage" enabled="true" language="JAVA" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of deprecated APIs (classes, fields, and methods), for example: &lt;code&gt;new Thread().stop();&lt;/code&gt;.
&lt;p&gt;By default, the inspection doesn't produce a warning if it's impossible or hard to avoid it.  For example,
  the following code won't be reported:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class A { //library code
     @Deprecated
     abstract void m();
  }
  class B extends A { //project code
     @Override
     void m() {
        //doSmth;
     }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;
  Use the inspection's options to disable this inspection inside deprecated members,
  overrides of abstract deprecated methods, non-static import statements, methods of deprecated classes, or same top-level classes.
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CommentedOutCode" defaultSeverity="WEAK WARNING" displayName="Commented out code" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports comments that contain Java code.
&lt;p&gt;Usually, code that is commented out gets outdated very quickly and becomes misleading.
As most projects use some kind of version control system,
  it is better to delete commented out code completely and use the VCS history instead.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2020.3&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObsoleteCollection" defaultSeverity="WARNING" displayName="Use of obsolete collection type" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;java.util.Vector&lt;/code&gt;, &lt;code&gt;java.util.Hashtable&lt;/code&gt; and &lt;code&gt;java.util.Stack&lt;/code&gt;.
&lt;p&gt;Usages of these classes can often be replaced with usages of
&lt;code&gt;java.util.ArrayList&lt;/code&gt;, &lt;code&gt;java.util.HashMap&lt;/code&gt; and &lt;code&gt;java.util.ArrayDeque&lt;/code&gt; respectively.
While still supported,
the former classes were made obsolete by the JDK1.2 collection classes, and should probably
not be used in new development.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Ignore obsolete collection types where they are required&lt;/b&gt; option to ignore any cases where the obsolete collections are used
as method arguments or assigned to a variable that requires the obsolete type.
Enabling this option may consume significant processor resources.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MarkedForRemoval" defaultSeverity="ERROR" displayName="Usage of API marked for removal" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of deprecated APIs (classes, fields, and methods) that are marked for removal with
  &lt;code&gt;@Deprecated(&lt;b&gt;forRemoval&lt;/b&gt;=true)&lt;/code&gt;.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  The code that uses an API marked for removal may cause a runtime error with a future version of the API. That is why
  the recommended severity for this inspection is &lt;i&gt;Error&lt;/i&gt;.&lt;/p&gt;
&lt;p&gt;
  You can change the severity to &lt;i&gt;Warning&lt;/i&gt; if you want to use the same code highlighting as in ordinary deprecation.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2017.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Android Lint: Productivity" path="Android/Lint"><inspection shortName="AndroidLintKtxExtensionAvailable" defaultSeverity="INFO" displayName="KTX Extension Available" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;KTX Extension Available&lt;br&gt;&lt;br&gt;Android KTX extensions augment some libraries with support for modern Kotlin language features like extension functions, extension properties, lambdas, named parameters, coroutines, and more.&lt;br/&gt;
&lt;br/&gt;
In Kotlin projects, use the KTX version of a library by replacing the dependency in your &lt;code&gt;build.gradle&lt;/code&gt; file. For example, you can replace &lt;code&gt;androidx.fragment:fragment&lt;/code&gt; with &lt;code&gt;androidx.fragment:fragment-ktx&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: KtxExtensionAvailable&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/kotlin/ktx"&gt;https://developer.android.com/kotlin/ktx&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Naming conventions" path="Java"><inspection shortName="LambdaParameterNamingConvention" defaultSeverity="WARNING" displayName="Lambda parameter naming convention" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports lambda parameters whose names are too short, too long, or do not follow
the specified regular expression pattern.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;Function&amp;lt;String, String&amp;gt; id = X -&amp;gt; X;&lt;/code&gt; 
  should be reported if the inspection is enabled with the default settings in which a parameter name should start with a lowercase letter.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;
Use the fields in the &lt;b&gt;Options&lt;/b&gt; section to specify the minimum length, maximum length, and a regular expression expected for lambda parameter names.
  Specify &lt;b&gt;0&lt;/b&gt; in order not to check the length of names.&lt;/p&gt;
&lt;p&gt;Regular expressions should be specified in the standard &lt;code&gt;java.util.regex&lt;/code&gt; format.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageNamingConvention" defaultSeverity="WARNING" displayName="Package naming convention" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports packages whose names are either too short, too long, or do not follow the specified regular expression pattern.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package io;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the options to specify the minimum and maximum length of the package name
  as well as a regular expression that matches valid package names
  (regular expressions are in standard &lt;code&gt;java.util.regex&lt;/code&gt; format).
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DollarSignInName" defaultSeverity="WARNING" displayName="Use of '$' in identifier" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports variables, methods, and classes with dollar signs (&lt;code&gt;$&lt;/code&gt;) in their names. While
such names are legal Java, their use outside of generated java code is strongly discouraged.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SalaryIn${}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rename quick-fix is suggested only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterNamingConvention" defaultSeverity="WARNING" displayName="Method parameter naming convention" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method parameters whose names are too short, too long, or do not follow
the specified regular expression pattern.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;void fooBar(int X)&lt;/code&gt;
  should be reported if the inspection is enabled with the default settings in which a parameter name should start with a lowercase letter.&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;
  Use the fields in the &lt;b&gt;Options&lt;/b&gt; section to specify the minimum length, maximum length, and a regular expression expected for
  method parameter names. Specify &lt;b&gt;0&lt;/b&gt; in order not to check the length of names.&lt;/p&gt;
&lt;p&gt;Regular expressions should be specified in the standard &lt;code&gt;java.util.regex&lt;/code&gt; format.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UpperCaseFieldNameNotConstant" defaultSeverity="WARNING" displayName="Non-constant field with upper-case name" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-&lt;code&gt;static&lt;/code&gt; non-&lt;code&gt;final&lt;/code&gt;
fields whose names are all in upper case.
&lt;p&gt;Such fields may cause confusion by breaking a common naming convention and
  are often used by mistake.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;pre&gt;&lt;code&gt;
  public static int THE_ANSWER = 42; //a warning here: final modifier is missing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix that renames such fields is available only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterNameDiffersFromOverriddenParameter" defaultSeverity="WARNING" displayName="Parameter name differs from parameter in overridden method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports parameters whose names differ from the corresponding
parameters of the methods they override. While legal in Java, such inconsistent names may be confusing
and decrease the documentation benefits of good naming practices.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    Person(String fullName) {}
  }
  class Child extends Person {
    Child(String name) { super(name); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Person {
    Person(String fullName) {}
  }
  class Child extends Person {
    Child(String fullName) { super(fullName); }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the options to indicate whether to ignore overridden parameter names that are only
  a single character long or come from a library method. Both can be useful if
  you do not wish to be bound by dubious naming conventions used in libraries.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StandardVariableNames" defaultSeverity="WARNING" displayName="Standard variable names" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports variables with 'standard' names that do not correspond to their types.
Such names may be confusing. There are the following standard names for specific types:
&lt;ul&gt;
  &lt;li&gt;i, j, k, m, n - &lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;f - &lt;code&gt;float&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;d - &lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;b - &lt;code&gt;byte&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;c, ch - &lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;l - &lt;code&gt;long&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;s, str - &lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rename quick-fix is suggested only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to ignore parameter names which are identical to the parameter name from a direct super method.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JavaModuleNaming" defaultSeverity="WARNING" displayName="Java module name contradicts the convention" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports cases when a module name contradicts Java Platform Module System recommendations.
&lt;p&gt;One of the &lt;a href="http://mail.openjdk.java.net/pipermail/jpms-spec-experts/2017-March/000659.html"&gt;recommendations&lt;/a&gt;
  is to avoid using digits at the end of module names.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
module foo1.bar2 {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldNamingConvention" defaultSeverity="WARNING" displayName="Field naming convention" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields whose names are too short, too long, or do not follow
the specified regular expression pattern.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt; if the inspection is enabled for constants, and the minimum specified length for a field name is 5 (the default), the following constant
  produces a warning because the length of its name is 3, which is less than 5:  &lt;code&gt;public static final int MAX = 42;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A quick-fix that renames such fields is available only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;Use the list in the &lt;b&gt;Options&lt;/b&gt; section to specify which fields should be checked. Deselect the checkboxes for the fields for which
you want to skip the check.&lt;/p&gt;
&lt;p&gt;For each field type, specify the minimum length, maximum length, and the regular expression expected for field names using the
  provided input fields.
  Specify &lt;b&gt;0&lt;/b&gt; in the length fields to skip the corresponding checks.&lt;/p&gt;
&lt;p&gt;Regular expressions should be specified in the standard
  &lt;code&gt;java.util.regex&lt;/code&gt; format.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalVariableNamingConvention" defaultSeverity="WARNING" displayName="Local variable naming convention" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local variables whose names are too short, too long, or do not follow
the specified regular expression pattern.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;int X = 42;&lt;/code&gt;
  should be reported if the inspection is enabled with the default settings in which a variable name should start with a lowercase letter.&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;
Use the fields in the &lt;b&gt;Options&lt;/b&gt; section to specify the minimum length, maximum length, and a regular expression expected for local variable names.
Specify &lt;b&gt;0&lt;/b&gt; in order not to check the length of names. Regular expressions should be specified in the standard &lt;b&gt;java.util.regex&lt;/b&gt; format.
&lt;p&gt;Use checkboxes to ignore &lt;code&gt;for&lt;/code&gt;-loop and &lt;code&gt;catch&lt;/code&gt; section parameters.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="QuestionableName" defaultSeverity="WARNING" displayName="Questionable name" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports variables, methods, or classes with questionable, not really descriptive names.
Such names do not help to understand the code, and most probably were created as a temporary thing but were forgotten afterwards.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int aa = 42;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rename quick-fix is suggested only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to list names that should be reported.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Cast" path="Java/Numeric issues"><inspection shortName="UnnecessaryExplicitNumericCast" defaultSeverity="WARNING" displayName="Unnecessary explicit numeric cast" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports primitive numeric casts that would be inserted implicitly by the compiler.
Also, reports any primitive numeric casts that the compiler will remove.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int x = (short)5; // The cast will be removed by the javac tool&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;code&gt;int x = 5;&lt;/code&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IntLiteralMayBeLongLiteral" defaultSeverity="WARNING" displayName="Cast to 'long' can be 'long' literal" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;int&lt;/code&gt; literal expressions that are immediately cast to &lt;code&gt;long&lt;/code&gt;.
&lt;p&gt;Such literal expressions can be replaced with equivalent &lt;code&gt;long&lt;/code&gt; literals.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Long l = (long)42;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Long l = 42L;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IntegerMultiplicationImplicitCastToLong" defaultSeverity="WARNING" displayName="Integer multiplication or shift implicitly cast to 'long'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports integer multiplications and left shifts that are implicitly cast to long.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int i) {
    long val = 65536 * i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied, the code changes to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void x(int i) {
    long val = 65536&lt;b&gt;L&lt;/b&gt; * i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int i) {
    long value = i &amp;lt;&amp;lt; 24;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied, the code changes to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void f(int i) {
    long value = (long) i &amp;lt;&amp;lt; 24;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Such multiplications are often a mistake, as overflow truncation may occur unexpectedly.
  Converting an &lt;code&gt;int&lt;/code&gt; literal to a &lt;code&gt;long&lt;/code&gt; literal (&lt;code&gt;65536&lt;b&gt;L&lt;/b&gt;&lt;/code&gt;) fixes the problem.
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DoubleLiteralMayBeFloatLiteral" defaultSeverity="WARNING" displayName="Cast to 'float' can be 'float' literal" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;double&lt;/code&gt; literal expressions that are immediately cast to &lt;code&gt;float&lt;/code&gt;.
&lt;p&gt;Such literal expressions can be replaced with equivalent &lt;code&gt;float&lt;/code&gt; literals.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float f = (float)1.1;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float f = 1.1f;&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CastThatLosesPrecision" defaultSeverity="WARNING" displayName="Numeric cast that loses precision" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports cast operations between primitive numeric types that may
result in precision loss.
&lt;p&gt;Such casts are not necessarily a problem but may result in difficult to
  trace bugs if the loss of precision is unexpected.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int a = 420;
  byte b = (byte) a;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore casts from int to char&lt;/b&gt; option to ignore casts from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;char&lt;/code&gt;.
  This type of cast is often used when implementing I/O operations because the &lt;code&gt;read()&lt;/code&gt; method of the
  &lt;code&gt;java.io.Reader&lt;/code&gt; class returns an &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore casts from int 128-255 to byte &lt;/b&gt; option to ignore casts of constant values (128-255) from &lt;code&gt;int&lt;/code&gt; to
  &lt;code&gt;byte&lt;/code&gt;.
  Such values will overflow to negative numbers that still fit inside a byte.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Google Cloud Endpoints" path=""><inspection shortName="RestSignature" defaultSeverity="ERROR" displayName="Unique REST Signature" enabled="true" language="JAVA" pluginId="com.google.gct.core" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">Ensures that the REST signatures in Endpoint classes are unique.</inspection><inspection shortName="Constructor" defaultSeverity="ERROR" displayName="Nullary Constructor Validation" enabled="true" language="JAVA" pluginId="com.google.gct.core" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">Checks that each class within an Endpoint API has a public nullary constructor.</inspection><inspection shortName="ApiParameter" defaultSeverity="ERROR" displayName="Unnamed API Parameter Check" enabled="true" language="JAVA" pluginId="com.google.gct.core" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">Checks for unnamed API parameters.</inspection><inspection shortName="InvalidParameterAnnotations" defaultSeverity="ERROR" displayName="Method Parameter Annotation Validation" enabled="true" language="JAVA" pluginId="com.google.gct.core" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">Checks that a parameter in the @ApiMethod path is not marked with @Nullable or @Defaultvalue.</inspection><inspection shortName="ApiName" defaultSeverity="ERROR" displayName="API Name Validation" enabled="true" language="JAVA" pluginId="com.google.gct.core" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">Checks that the API name for Endpoint classes starts with a lowercase letter and consists only of letters and digits.</inspection><inspection shortName="FullMethodName" defaultSeverity="ERROR" displayName="Full Method Name Uniqueness Validation" enabled="true" language="JAVA" pluginId="com.google.gct.core" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">Checks that API method names specified using @ApiMethod's name attributes are unique for an Endpoint class.</inspection><inspection shortName="FullJavaName" defaultSeverity="ERROR" displayName="Method Name Uniqueness Validation" enabled="true" language="JAVA" pluginId="com.google.gct.core" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">Checks that the Endpoint methods have unique full Java names.</inspection><inspection shortName="NamedResource" defaultSeverity="ERROR" displayName="Named Resource Uniqueness Validation" enabled="true" language="JAVA" pluginId="com.google.gct.core" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">Checks that parameter names are specified in @Named annotations and that they are unique for each method.</inspection><inspection shortName="MethodName" defaultSeverity="ERROR" displayName="Method Name Validation" enabled="true" language="JAVA" pluginId="com.google.gct.core" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">Checks that method names provided in @ApiMethod consists of only letters, digits, underscores and dots. The dots cannot be in the leading or trailing position.</inspection><inspection shortName="MethodParameterType" defaultSeverity="ERROR" displayName="Method Parameter Type Validation" enabled="true" language="JAVA" pluginId="com.google.gct.core" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">Checks that parameters types do not contain multiple levels of collections or arrays.</inspection><inspection shortName="ResourceParameter" defaultSeverity="ERROR" displayName="Resource Parameter Validation" enabled="true" language="JAVA" pluginId="com.google.gct.core" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">Checks that a specified resource parameter for a class that does not have a transformer is not a multi-level collection or an array and does not use @Named.</inspection><inspection shortName="ApiNamespace" defaultSeverity="ERROR" displayName="API Namespace Validation" enabled="true" language="JAVA" pluginId="com.google.gct.core" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">Checks that the owner domain, owner name and package path attributes are either not specified, or both owner domain and owner name attributes are specified for an API namespace.</inspection><inspection shortName="MethodReturnType" defaultSeverity="ERROR" displayName="Method Return Type Inspection" enabled="true" language="JAVA" pluginId="com.google.gct.core" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">Checks that method return types are of entity types.</inspection></group><group name="Java 14" path="Java/Java language level migration aids"><inspection shortName="EnhancedSwitchBackwardMigration" defaultSeverity="INFORMATION" displayName="Enhanced 'switch'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports enhanced &lt;code&gt;switch&lt;/code&gt; statements and expressions. Suggests replacing them with regular &lt;code&gt;switch&lt;/code&gt;
statements.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean even = switch (condition) {
    case 1, 3, 5, 7, 9 -&gt; false;
    default -&gt; true;
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean even;
  switch (condition) {
    case 1:
    case 3:
    case 5:
    case 7:
    case 9:
      even = false;
      break;
    default:
      even = true;
      break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2019.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnhancedSwitchMigration" defaultSeverity="WARNING" displayName="Statement can be replaced with enhanced 'switch'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;switch&lt;/code&gt; statements that can be automatically replaced with enhanced &lt;code&gt;switch&lt;/code&gt; statements or expressions.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double getPrice(String fruit) {
    // Switch statement can be replaced with enhanced 'switch'
    switch (fruit) {
      case "Apple":
        return 1.0;
      case "Orange":
        return 1.5;
      case "Mango":
        return 2.0;
      default:
        throw new IllegalArgumentException();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double getPrice(String fruit) {
    return switch (fruit) {
      case "Apple" -&gt; 1.0;
      case "Orange" -&gt; 1.5;
      case "Mango" -&gt; 2.0;
      default -&gt; throw new IllegalArgumentException();
    };
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 14 or higher&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2019.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Abstraction issues" path="Java"><inspection shortName="InstanceofChain" defaultSeverity="WARNING" displayName="Chain of 'instanceof' checks" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any chains of &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; statements all of whose conditions are &lt;code&gt;instanceof&lt;/code&gt; expressions
or class equality expressions (e.g. comparison with &lt;code&gt;String.class&lt;/code&gt;).
Such constructions usually indicate a failure in object-oriented design which
dictates that such type-based dispatch should be done via polymorphic method calls rather than explicit chains
of type tests.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  double getArea(Shape shape) {
    // Warning: abstraction failure.
    // It would be better to declare a getArea()
    // abstract method in the shape interface
    // and implement it in every inheritor.
    if (shape instanceof Point) {
      return 0;
    }
    if (shape instanceof Circle) {
      return Math.PI *
        Math.pow(((Circle) shape).radius(), 2);
    }
    if (shape instanceof Rectangle) {
      return ((Rectangle) shape).width() *
        ((Rectangle) shape).height();
    }
    throw new IllegalArgumentException();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the checkbox below to ignore &lt;code&gt;instanceof&lt;/code&gt; expressions on library classes.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassReferencesSubclass" defaultSeverity="WARNING" displayName="Class references one of its subclasses" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes which contain references to one of their subclasses.
Such references may be confusing and violate several rules of object-oriented design.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Entity {
    // Warning: the class references its subclass
    void compare(SimpleEntity entity) {
      ...
    }
  }
  class SimpleEntity extends Entity {
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InterfaceMethodClashesWithObject" defaultSeverity="WARNING" displayName="Interface method clashes with method in 'Object'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports interface methods that clash with the &lt;b&gt;protected&lt;/b&gt; methods &lt;code&gt;clone()&lt;/code&gt; and &lt;code&gt;finalize()&lt;/code&gt; from the &lt;code&gt;java.lang.Object&lt;/code&gt; class.
&lt;p&gt;In an interface, it is possible to declare these methods with a return type that is incompatible with the &lt;code&gt;java.lang.Object&lt;/code&gt; methods.
  A class that implements such an interface will not be compilable.
  When the interface is functional, it remains possible to create a lambda from it, but this is not recommended.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Warning: this interface cannot be implemented
  // by any class, only by a lambda or method reference
  interface MyInterface {
    double clone();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DeclareCollectionAsInterface" defaultSeverity="WARNING" displayName="Collection declared by class, not interface" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports declarations of &lt;code&gt;Collection&lt;/code&gt; variables made by using the collection class as a type,
rather than an appropriate interface. The warning is not issued if weakening the variable type 
will cause a compilation error.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Warning: concrete collection class ArrayList used.
  int getTotalLength(ArrayList&amp;lt;String&amp;gt; list) {
    return list.stream().mapToInt(String::length).sum();
  }

  // No warning, as trimToSize() method is not
  // available in the List interface
  void addData(ArrayList&amp;lt;String&amp;gt; data) {
    data.add("Hello");
    data.add("World");
    data.trimToSize();
  }
&lt;/code&gt;&lt;/pre&gt;
A quick-fix is suggested to use the appropriate collection interface (e.g. &lt;code&gt;Collection&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, or &lt;code&gt;List&lt;/code&gt;).
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverlyStrongTypeCast" defaultSeverity="WARNING" displayName="Overly strong type cast" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports type casts that are overly strong. For instance,
casting an object to &lt;code&gt;ArrayList&lt;/code&gt; when casting it to
&lt;code&gt;List&lt;/code&gt; would do just as well.
&lt;p&gt;
  &lt;b&gt;Note:&lt;/b&gt; much like the &lt;i&gt;Redundant type cast&lt;/i&gt;
  inspection, applying the fix for this inspection may change the semantics of your program if you are
  intentionally using an overly strong cast to cause a &lt;code&gt;ClassCastException&lt;/code&gt; to be generated.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface Super {
    void doSmth();
  }
  interface Sub extends Super { }

  void use(Object obj) {
    // Warning: ((Super)obj).doSmth() could be used
    ((Sub)obj).doSmth();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the checkbox below to ignore casts when there's a matching &lt;code&gt;instanceof&lt;/code&gt; check in the code.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FeatureEnvy" defaultSeverity="WARNING" displayName="Feature envy" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the &lt;em&gt;Feature Envy&lt;/em&gt; code smell. The warning is thrown when a method calls methods on another class three
or more times. Calls to library classes, parent classes, contained or containing
classes are not counted by this inspection. Feature
envy is often an indication of the fact that this functionality is located in a wrong class.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class JobManager {
    // Warning: this method calls three methods
    // of the Job class
    // It would be better to move this chain of
    // calls to the Job class itself.
    void performJob(Job job) {
      job.beforeStart();
      job.process();
      job.afterProcessing();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodOnlyUsedFromInnerClass" defaultSeverity="WARNING" displayName="Private method only used from inner class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;private&lt;/code&gt; methods which
are only called from an inner class of the class containing the method. Such
methods can be safely moved into that inner class.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public class Outer {
  public static void main(String[] args) {
    new Inner().run(args[0]);
  }

  static class Inner {
    void run(String arg) {
      // Method isEmpty() is used from Inner class only
      // consider moving it to the Inner class
      if (!isEmpty(arg)) {
        System.out.println("Argument is supplied");
      }
    }
  }

  private static boolean isEmpty(String s) {
    return s != null &amp;&amp; s.trim().isEmpty();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the first checkbox below to ignore &lt;code&gt;private&lt;/code&gt;
methods which are called from an anonymous or local class.
&lt;p&gt;
Use the third checkbox to only report &lt;code&gt;static&lt;/code&gt; methods.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalUsedAsFieldOrParameterType" defaultSeverity="WARNING" displayName="'Optional' used as field or parameter type" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any cases in which &lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;java.util.OptionalDouble&lt;/code&gt;, &lt;code&gt;java.util.OptionalInt&lt;/code&gt;,
&lt;code&gt;java.util.OptionalLong&lt;/code&gt;, or &lt;code&gt;com.google.common.base.Optional&lt;/code&gt; are used as types for fields or parameters.
&lt;p&gt;&lt;code&gt;Optional&lt;/code&gt; was designed to provide a limited mechanism for library method return types in which a clear way to represent "no result"
  was needed.&lt;/p&gt;
&lt;p&gt;Using a field with the &lt;code&gt;java.util.Optional&lt;/code&gt; type is also problematic if the class needs to be
  &lt;code&gt;Serializable&lt;/code&gt;, as &lt;code&gt;java.util.Optional&lt;/code&gt; is not serializable.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    Optional&amp;lt;String&amp;gt; name; // Optional field

    // Optional parameter
    void setName(Optional&amp;lt;String&amp;gt; name) {
      this.name = name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MagicNumber" defaultSeverity="WARNING" displayName="Magic number" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports "magic numbers": numeric literals that are not named by a constant declaration.
&lt;p&gt;Using magic numbers can lead to unclear code, as well as errors if a magic
number is changed in one location but remains unchanged not another. The numbers 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100, 1000, 0L, 1L, 2L,
  0.0, 1.0, 0.0F and 1.0F are not reported by this inspection.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void checkFileSize(long bytes) {
    if (bytes &gt; 1_048_576) {
      throw new IllegalArgumentException("too big");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix introduces a new constant:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static final int MAX_SUPPORTED_FILE_SIZE = 1_048_576;

  void checkFileSize(long bytes) {
    if (bytes &gt; MAX_SUPPORTED_FILE_SIZE) {
      throw new IllegalArgumentException("too big");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore constants in 'hashCode()' methods&lt;/b&gt; option to disable this inspection within &lt;code&gt;hashCode()&lt;/code&gt; methods.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore in annotations&lt;/b&gt; option to ignore magic numbers in annotations.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore initial capacity for StringBuilders and Collections&lt;/b&gt; option to ignore magic numbers used as initial capacity when constructing
    &lt;code&gt;Collection&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;,
    &lt;code&gt;StringBuilder&lt;/code&gt; or &lt;code&gt;StringBuffer&lt;/code&gt; objects.&lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicMethodNotExposedInInterface" defaultSeverity="WARNING" displayName="'public' method not exposed in interface" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;public&lt;/code&gt; methods in classes
which are not exposed in an interface.
&lt;p&gt;Exposing all &lt;code&gt;public&lt;/code&gt; methods via an interface is important for
  maintaining loose coupling, and may be necessary for certain component-based programming styles.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
interface Person {
  String getName();
}

class PersonImpl implements Person {
  private String name;

  // ok: method is exposed in interface
  @Override
  public String getName() {
    return name;
  }

  // warning: method is public
  // but not exposed in interface
  public void setName() {
    this.name = name;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignore if annotated by&lt;/b&gt; list to specify special annotations. Methods annotated with one of
these annotations will be ignored by this inspection.
&lt;p&gt;
  Use the &lt;b&gt;Ignore if the containing class does not implement a non-library interface&lt;/b&gt; option to ignore methods from classes which do not
implement any interface from the project.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TypeMayBeWeakened" defaultSeverity="WARNING" displayName="Type may be weakened" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports variable and method return types that can be changed to a more abstract (weaker) type.
This allows making the code more abstract, hence more reusable.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Type of parameter can be weakened to java.util.List
  void processList(ArrayList&amp;lt;String&amp;gt; list) {
    if (list.isEmpty()) return;
    System.out.println("Processing");
    for (String s : list) {
      System.out.println("String: " + s);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Enable the &lt;b&gt;Use righthand type&lt;/b&gt; checkbox below
  to prevent weakening the left side of assignments when the right side is not
  a type cast or a new expression. When storing the result of a method call in a variable, it is
  useful to retain the type of the method call result instead of unnecessarily weakening it.
&lt;/p&gt;
&lt;p&gt;
  Enable the &lt;b&gt;Use parameterized type&lt;/b&gt; checkbox below
  to use the parameterized type of the collection as the weakest type when
  the object evaluated is used as an argument to a collection method with a parameter type of
  &lt;code&gt;java.lang.Object&lt;/code&gt;.
  Use this option to prevent weakening to &lt;code&gt;Object&lt;/code&gt; when passing an object to the  following collection methods:
  &lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;remove()&lt;/code&gt;,
  &lt;code&gt;contains()&lt;/code&gt;, &lt;code&gt;indexOf()&lt;/code&gt;,
  &lt;code&gt;lastIndexOf()&lt;/code&gt;, &lt;code&gt;containsKey()&lt;/code&gt; and &lt;code&gt;containsValue()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  Enable the &lt;b&gt;Do not weaken to Object&lt;/b&gt; checkbox below
  to specify whether a type should be weakened to &lt;code&gt;java.lang.Object&lt;/code&gt;.
  Weakening to &lt;code&gt;java.lang.Object&lt;/code&gt; is rarely very useful.
&lt;/p&gt;
&lt;p&gt;
  Enable the &lt;b&gt;Only weaken to an interface&lt;/b&gt; checkbox below
  to only report a problem when the type can be weakened to an interface type.
&lt;/p&gt;
&lt;p&gt;
  Enable the &lt;b&gt;Do not weaken return type&lt;/b&gt; checkbox below
  to prevent reporting a problem when the return type may be weakened.
  Only variables will be analyzed.
&lt;/p&gt;
&lt;p&gt;
  Enable the &lt;b&gt;Do not suggest weakening variable declared as 'var'&lt;/b&gt; checkbox below
  to prevent reporting on local variables declared using the 'var' keyword (Java 10+)
&lt;/p&gt;
&lt;p&gt;
&lt;b&gt;Stop classes&lt;/b&gt; are intended to prevent weakening to classes
lower than stop classes, even if it is possible.
In some cases, this may improve readability.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StaticMethodOnlyUsedInOneClass" defaultSeverity="WARNING" displayName="Static member only used from one other class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;static&lt;/code&gt; methods and fields that
are only used from a class other than the containing class. Such members could be moved into the using class.
Factory methods and members accessed from an anonymous class inside the member's class are ignored by this inspection.
Convenience overloads, which call a method with the same name in the same class but have fewer parameters, are also ignored.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the first checkbox to supress this inspection when the static member is only used from a test class.
&lt;p&gt;
Use the second checkbox below to ignore member usages from inside anonymous, local, or non-static inner classes.
&lt;p&gt;
Use the third checkbox below to not warn on members that cannot be moved without problems,
  for example, because a method with an identical signature is already present in the target class,
  or because a field or a method used inside the method will not be accessible when this method is moved.
&lt;p&gt;
Use the fourth checkbox to ignore members located in utility classes.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnresolvedClassReferenceRepair" defaultSeverity="INFORMATION" displayName="Unresolved class reference" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unresolved class reference.
&lt;p&gt;The quick-fix suggests trying to resolve reference.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfConcreteClass" defaultSeverity="WARNING" displayName="Use of concrete class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of concrete classes, rather than interfaces.
Such declarations may represent a failure of abstraction and may make testing more difficult.
&lt;p&gt;
Declarations whose classes come from system or third-party libraries will not be reported by this inspection.
Casts, instanceofs, and local variables are not reported in &lt;code&gt;equals()&lt;/code&gt; method implementations.
Also, casts are not reported in &lt;code&gt;clone()&lt;/code&gt; method implementations.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface Entity {}
  class EntityImpl implements Entity {}

  void processObject(Object obj) {
    // warning: instanceof of the concrete class
    if (obj instanceof EntityImpl) {
      // warning: cast to the concrete class,
      // rather than the interface
      processEntity((EntityImpl)obj);
    }
  }
  // warning: parameter of concrete class
  void processEntity(EntityImpl obj) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignore abstract class type&lt;/b&gt; option to ignore casts to abstract classes.&lt;/p&gt;
&lt;p&gt;Use the subsequent options to control contexts where the problem is reported.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceofThis" defaultSeverity="WARNING" displayName="'instanceof' check for 'this'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;instanceof&lt;/code&gt; or &lt;code&gt;getClass() == SomeClass.class&lt;/code&gt; in which a
&lt;code&gt;this&lt;/code&gt; expression is checked.
&lt;p&gt;Such expressions indicate a failure of the object-oriented design, and should be replaced by
  polymorphic constructions.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Super {
  void process() {
    if (this instanceof Sub) { // warning
      doSomething();
    } else {
      doSomethingElse();
    }
  }
}
  
class Sub extends Super {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix the problem, use an overriding method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Super {
  void process() {
    doSomethingElse();
  }
}
  
class Sub extends Super {
  @Override
  void process() {
    doSomething();
  }
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BooleanParameter" defaultSeverity="WARNING" displayName="'public' method with 'boolean' parameter" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports public methods that accept a &lt;code&gt;boolean&lt;/code&gt; parameter.
&lt;p&gt;It's almost always bad practice to add a &lt;code&gt;boolean&lt;/code&gt; parameter to a public method (part of an API) if that method is not a setter.
When reading code using such a method, it can be difficult to decipher what the &lt;code&gt;boolean&lt;/code&gt; stands for without looking at
the source or documentation.&lt;/p&gt;
&lt;p&gt;This problem is also known as &lt;a href="https://ariya.io/2011/08/hall-of-api-shame-boolean-trap"&gt;the boolean trap&lt;/a&gt;.
  The &lt;code&gt;boolean&lt;/code&gt; parameter can often be replaced with an &lt;code&gt;enum&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Warning: it's hard to understand what the
  // boolean parameters mean when looking at
  // a call to this method
  public boolean setPermission(File f,
                               int access,
                               boolean enable,
                               boolean ownerOnly) {
    // ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
Use the &lt;b&gt;Only report methods with multiple boolean parameters&lt;/b&gt; option to warn only when a method contains more than one boolean parameter.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java language level migration aids" path="Java"><inspection shortName="UseCompareMethod" defaultSeverity="WARNING" displayName="'compare()' method can be used to compare numbers" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports cases where the static &lt;code&gt;Integer.compare()&lt;/code&gt; method or similar methods can be used
instead of more verbose or less efficient constructs.
&lt;p&gt;If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are already boxed integers, then &lt;code&gt;x.compareTo(y)&lt;/code&gt; is suggested.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int compare(int x, int y) {
    return x &gt; y ? 1 : x &amp;lt; y ? -1 : 0;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public int compare(int x, int y) {
    return Integer.compare(x, y);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Note that &lt;code&gt;Double.compare&lt;/code&gt; and &lt;code&gt;Float.compare&lt;/code&gt; slightly change the code semantics. In particular,
  they make &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;0.0&lt;/code&gt; distinguishable (&lt;code&gt;Double.compare(-0.0, 0.0)&lt;/code&gt; yields -1).
  Also, they consistently process &lt;code&gt;NaN&lt;/code&gt; value. In most of the cases, this semantics change actually improves the
  code. Use the checkbox to disable this inspection for floating point numbers if semantics change is unacceptable
  in your case.
&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EnumerationCanBeIteration" defaultSeverity="WARNING" displayName="Enumeration can be iteration" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Enumeration&lt;/code&gt; methods that are used on collections and may be replaced with equivalent
&lt;code&gt;Iterator&lt;/code&gt; constructs.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Enumeration&amp;lt;String&amp;gt; keys = map.keys();
  while (keys.hasMoreElements()) {
    String name = keys.nextElement();
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Iterator&amp;lt;String&amp;gt; iterator = map.keySet().iterator();
  while (iterator.hasNext()) {
    String name = iterator.next();
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IfCanBeSwitch" defaultSeverity="WARNING" displayName="'if' can be replaced with 'switch'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; statements that can be replaced with &lt;code&gt;switch&lt;/code&gt; statements.
&lt;p&gt;The replacement result is usually shorter and clearer.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(String str) {
    if (str.equals("1")) {
      System.out.println(1);
    } else if (str.equals("2")) {
      System.out.println(2);
    } else if (str.equals("3")) {
      System.out.println(3);
    } else {
      System.out.println(4);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(String str) {
    switch (str) {
      case "1" -&amp;gt; System.out.println(1);
      case "2" -&amp;gt; System.out.println(2);
      case "3" -&amp;gt; System.out.println(3);
      default -&amp;gt; System.out.println(4);
    }
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 7 or higher.&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Minimum number of 'if' condition branches&lt;/b&gt; field to specify the minimum number of &lt;code&gt;if&lt;/code&gt; condition branches
  for an &lt;code&gt;if&lt;/code&gt; statement to have to be reported. Note that the terminal &lt;code&gt;else&lt;/code&gt; branch (without &lt;code&gt;if&lt;/code&gt;) is not counted.&lt;/p&gt;
&lt;p&gt;
Use the &lt;b&gt;Suggest switch on numbers&lt;/b&gt; option to enable the suggestion of &lt;code&gt;switch&lt;/code&gt; statements on
primitive and boxed numbers and characters.
&lt;p&gt;
Use the &lt;b&gt;Suggest switch on enums&lt;/b&gt; option to enable the suggestion of &lt;code&gt;switch&lt;/code&gt; statements on
&lt;code&gt;enum&lt;/code&gt; constants.
&lt;p&gt;
  Use the &lt;b&gt;Only suggest on null-safe expressions&lt;/b&gt; option to suggest &lt;code&gt;switch&lt;/code&gt; statements that can't introduce a &lt;code&gt;NullPointerException&lt;/code&gt; only.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Android Lint: Interoperability" path="Android/Lint"><inspection shortName="AndroidLintJavaPluginLanguageLevel" defaultSeverity="WARNING" displayName="Java Plugin Language Level" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;No Explicit Java Language Level Given&lt;br&gt;&lt;br&gt;In modules using plugins deriving from the Gradle &lt;code&gt;java&lt;/code&gt; plugin (e.g. &lt;code&gt;java-library&lt;/code&gt; or &lt;code&gt;application&lt;/code&gt;), the java source and target compatibility default to the version of the JDK being used to run Gradle, which may cause compatibility problems with Android (or other) modules.&lt;br/&gt;
&lt;br/&gt;
You can specify an explicit sourceCompatibility and targetCompatibility in this module to maintain compatibility no matter which JDK is used to run Gradle.&lt;br&gt;&lt;br&gt;Issue id: JavaPluginLanguageLevel&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Android Lint: Internationalization" path="Android/Lint"><inspection shortName="AndroidLintEnforceUTF8" defaultSeverity="ERROR" displayName="Encoding used in resource files is not UTF-8" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Encoding used in resource files is not UTF-8&lt;br&gt;&lt;br&gt;XML supports encoding in a wide variety of character sets. However, not all tools handle the XML encoding attribute correctly, and nearly all Android apps use UTF-8, so by using UTF-8 you can protect yourself against subtle bugs when using non-ASCII characters.&lt;br/&gt;
&lt;br/&gt;
In particular, the Android Gradle build system will merge resource XML files assuming the resource files are using UTF-8 encoding.&lt;br&gt;&lt;br&gt;Issue id: EnforceUTF8&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintWeekBasedYear" defaultSeverity="WARNING" displayName="Week Based Year" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Week Based Year&lt;br&gt;&lt;br&gt;The &lt;code&gt;DateTimeFormatter&lt;/code&gt; pattern &lt;code&gt;YYYY&lt;/code&gt; returns the &lt;i&gt;week&lt;/i&gt; based year, not the era-based year. This means that 12/29/2019 will format to 2019, but 12/30/2019 will format to 2020!&lt;br/&gt;
&lt;br/&gt;
If you expected this to format as 2019, you should use the pattern &lt;code&gt;yyyy&lt;/code&gt; instead.&lt;br&gt;&lt;br&gt;Issue id: WeekBasedYear&lt;br&gt;&lt;br&gt;&lt;a href="https://stackoverflow.com/questions/46847245/using-datetimeformatter-on-january-first-cause-an-invalid-year-value"&gt;https://stackoverflow.com/questions/46847245/using-datetimeformatter-on-january-first-cause-an-invalid-year-value&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintHardcodedText" defaultSeverity="WARNING" displayName="Hardcoded text" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Hardcoded text&lt;br&gt;&lt;br&gt;Hardcoding text attributes directly in layout files is bad for several reasons:&lt;br/&gt;
&lt;br/&gt;
* When creating configuration variations (for example for landscape or portrait) you have to repeat the actual text (and keep it up to date when making changes)&lt;br/&gt;
&lt;br/&gt;
* The application cannot be translated to other languages by just adding new translations for existing string resources.&lt;br/&gt;
&lt;br/&gt;
There are quickfixes to automatically extract this hardcoded string into a resource lookup.&lt;br&gt;&lt;br&gt;Issue id: HardcodedText&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintConstantLocale" defaultSeverity="WARNING" displayName="Constant Locale" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Constant Locale&lt;br&gt;&lt;br&gt;Assigning &lt;code&gt;Locale.getDefault()&lt;/code&gt; to a constant is suspicious, because the locale can change while the app is running.&lt;br&gt;&lt;br&gt;Issue id: ConstantLocale&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintRelativeOverlap" defaultSeverity="WARNING" displayName="Overlapping items in RelativeLayout" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Overlapping items in RelativeLayout&lt;br&gt;&lt;br&gt;If relative layout has text or button items aligned to left and right sides they can overlap each other due to localized text expansion unless they have mutual constraints like &lt;code&gt;toEndOf&lt;/code&gt;/&lt;code&gt;toStartOf&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: RelativeOverlap&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintSetTextI18n" defaultSeverity="WARNING" displayName="TextView Internationalization" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;TextView Internationalization&lt;br&gt;&lt;br&gt;When calling &lt;code&gt;TextView#setText&lt;/code&gt;&lt;br/&gt;
* Never call &lt;code&gt;Number#toString()&lt;/code&gt; to format numbers; it will not handle fraction separators and locale-specific digits properly. Consider using &lt;code&gt;String#format&lt;/code&gt; with proper format specifications (&lt;code&gt;%d&lt;/code&gt; or &lt;code&gt;%f&lt;/code&gt;) instead.&lt;br/&gt;
* Do not pass a string literal (e.g. "Hello") to display text. Hardcoded text can not be properly translated to other languages. Consider using Android resource strings instead.&lt;br/&gt;
* Do not build messages by concatenating text chunks. Such messages can not be properly translated.&lt;br&gt;&lt;br&gt;Issue id: SetTextI18n&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/guide/topics/resources/localization.html"&gt;https://developer.android.com/guide/topics/resources/localization.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintByteOrderMark" defaultSeverity="ERROR" displayName="Byte order mark inside files" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Byte order mark inside files&lt;br&gt;&lt;br&gt;Lint will flag any byte-order-mark (BOM) characters it finds in the middle of a file. Since we expect files to be encoded with UTF-8 (see the EnforceUTF8 issue), the BOM characters are not necessary, and they are not handled correctly by all tools. For example, if you have a BOM as part of a resource name in one particular translation, that name will not be considered identical to the base resource's name and the translation will not be used.&lt;br&gt;&lt;br&gt;Issue id: ByteOrderMark&lt;br&gt;&lt;br&gt;&lt;a href="https://en.wikipedia.org/wiki/Byte_order_mark"&gt;https://en.wikipedia.org/wiki/Byte_order_mark&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Declaration redundancy" path="Groovy"><inspection shortName="GroovyUnusedDeclaration" defaultSeverity="WARNING" displayName="Unused declaration" enabled="true" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports unused classes, methods and fields.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Department {
      private Organization myOrganization;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here &lt;code&gt;Department&lt;/code&gt; explicitly references &lt;code&gt;Organization&lt;/code&gt; but if &lt;code&gt;Department&lt;/code&gt; class itself is unused,
then inspection would report both classes. 

&lt;p&gt;
The inspection also reports parameters, which are not used by their methods and all method implementations/overriders, as well as local
variables, which are declared but not used.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;For more information, see the same inspection in Java.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Bitwise operation issues" path="Java"><inspection shortName="PointlessBitwiseExpression" defaultSeverity="WARNING" displayName="Pointless bitwise expression" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports pointless bitwise expressions.
&lt;p&gt;
  Such expressions include applying the &lt;code&gt;&amp;&lt;/code&gt; operator to the maximum value for the given type, applying the
  &lt;code&gt;or&lt;/code&gt; operator to zero, and shifting by zero. Such expressions may be the result of automated
  refactorings not followed through to completion and are unlikely to be originally intended.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Warning: operation is pointless and can be replaced with just `flags`
  // 0xFFFF_FFFF is the maximum value for an integer, and both literals are treated
  // as 32 bit integer literals.
  int bits = flags &amp; 0xFFFF_FFFF;

  // Warning: operation is pointless and can be replaced with just `bits`
  // OR-ing with 0 always outputs the other operand.
  int or = bits | 0x0;

  // Warning: operation is pointless, as always results in 0
  int xor = or ^ or;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ShiftOutOfRange" defaultSeverity="WARNING" displayName="Shift operation by inappropriate constant" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports shift operations
where the shift value is a constant outside the reasonable range.
&lt;p&gt;Integer shift operations outside the range &lt;code&gt;0..31&lt;/code&gt; and long shift operations outside the
  range &lt;code&gt;0..63&lt;/code&gt; are reported. Shifting by negative or overly large values is almost certainly
  a coding error.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int shiftSize = 32;
  // Warning: shift by 32 bits is equivalent to shift by 0 bits, so there's no shift at all.
  int mask = (1 &amp;lt;&amp;lt; shiftSize) - 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncompatibleMask" defaultSeverity="WARNING" displayName="Incompatible bitwise mask operation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports bitwise mask expressions which are guaranteed to
evaluate to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.
&lt;p&gt;
  The inspection checks the expressions of the form &lt;code&gt;(var &amp; constant1) == constant2&lt;/code&gt; or
  &lt;code&gt;(var | constant1) == constant2&lt;/code&gt;, where &lt;code&gt;constant1&lt;/code&gt;
  and &lt;code&gt;constant2&lt;/code&gt; are incompatible bitmask constants.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  // Incompatible mask: as the mask ends in 00,
  // the result could be 0x1200 but not 0x1234
  if ((mask &amp; 0xFF00) == 0x1234) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Static Analysis Tools" path="C/C++"><inspection shortName="Misra" defaultSeverity="WARNING" displayName="MISRA" enabled="false" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports various issues defined by the MISRA C 2012 and MISRA C++ 2008 guidelines.
&lt;p&gt;The list of currently supported checks is &lt;a href="https://youtrack.jetbrains.com/articles/CPP-A-191430682/MISRA-checks-supported-in-CLion"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="Clazy" defaultSeverity="WARNING" displayName="Clazy" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the Qt-related compiler warnings, ranging from unneeded memory allocations to
the misused API.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClangTidy" defaultSeverity="WARNING" displayName="Clang-Tidy" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports various issues related to The C++ Core Guidelines, Modernize, Readability and Performance. &lt;br/&gt;
CLion's default configuration is described &lt;a href="https://youtrack.jetbrains.com/articles/CPP-A-90276519/Clang-Tidy-in-CLion:-default-configuration"&gt;here&lt;/a&gt;. &lt;br/&gt;
For more information, visit the official &lt;a href="https://clang.llvm.org/extra/clang-tidy/"&gt;Clang-Tidy&lt;/a&gt; page.
&lt;p&gt;Use the checkbox below to have this inspection ignore the IDE settings and use a list of checks specified in the &lt;b&gt;.clang-tidy&lt;/b&gt; file if any exist.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Structural search" path=""><inspection shortName="SSBasedInspection" defaultSeverity="WARNING" displayName="Structural search inspection" enabled="true" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Allows configuring &lt;b&gt;Structural Search/Structural Replace&lt;/b&gt; templates that you can apply to the file you are editing.
&lt;/p&gt;
&lt;p&gt;All matches will be highlighted and marked with the template name that you have configured.
If you configure the &lt;b&gt;Structural Replace&lt;/b&gt; pattern as well, the corresponding replace option will be available as a quick-fix.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Code" path="Plugin DevKit"><inspection shortName="UsePluginIdEquals" defaultSeverity="WARNING" displayName="Use 'PluginId#equals(Object)'" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports comparing &lt;code&gt;PluginId&lt;/code&gt; instances using &lt;code&gt;==&lt;/code&gt;.
&lt;p&gt;
  Replace with &lt;code&gt;equals()&lt;/code&gt; call.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableCtor" defaultSeverity="WARNING" displayName="Non-default constructor in serializable class" enabled="false" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-default constructor in serializable classes.
&lt;p&gt;
  The platform's &lt;code&gt;IonObjectSerializer&lt;/code&gt; requires specifying &lt;code&gt;@PropertyMapping&lt;/code&gt; explicitly.
&lt;/p&gt;
&lt;p&gt;
  Quick-fix generates necessary &lt;code&gt;@PropertyMapping&lt;/code&gt; annotation for the constructor.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StatefulEp" defaultSeverity="WARNING" displayName="Stateful extension" enabled="true" language="JVM" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports extensions and quick-fixes holding potentially leaking state.
&lt;p&gt;
  Keeping references to &lt;code&gt;PsiElement&lt;/code&gt;, &lt;code&gt;PsiReference&lt;/code&gt;, or &lt;code&gt;Project&lt;/code&gt; instances can result in memory leaks.
&lt;/p&gt;
&lt;p&gt;
  Ideally, these should be stateless.
  For quick-fix, see &lt;code&gt;LocalQuickFixOnPsiElement&lt;/code&gt; as a convenient base class.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InspectionUniqueToolbarId" defaultSeverity="WARNING" displayName="Specify toolbar id" enabled="true" language="JAVA" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports passing non-unique &lt;code&gt;place&lt;/code&gt; parameter for &lt;code&gt;ActionManager.createActionToolbar()&lt;/code&gt;.
&lt;p&gt;
  Specifying proper &lt;code&gt;place&lt;/code&gt; is required to distinguish Action's usage in &lt;code&gt;update()/actionPerformed()&lt;/code&gt; via &lt;code&gt;AnActionEvent.getPlace()&lt;/code&gt;.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UsePrimitiveTypes" defaultSeverity="WARNING" displayName="Use 'PsiType#equals(Object)' with primitive types" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports comparing &lt;code&gt;PsiPrimitiveType&lt;/code&gt; instances using &lt;code&gt;==&lt;/code&gt;.
&lt;p&gt;
  Primitive types should be compared with &lt;code&gt;equals&lt;/code&gt; as Java 8 type annotations are also applicable for them.
&lt;/p&gt;
&lt;p&gt;
  Replace with &lt;code&gt;equals()&lt;/code&gt; call.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UElementAsPsi" defaultSeverity="WARNING" displayName="UElement as PsiElement usage" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usage of UAST &lt;code&gt;UElement&lt;/code&gt; as &lt;code&gt;PsiElement&lt;/code&gt;.
&lt;p&gt;
  The &lt;code&gt;PsiElement&lt;/code&gt; obtained this way is ambiguous.
&lt;/p&gt;
&lt;p&gt;
  To obtain "physical" &lt;code&gt;PsiElement&lt;/code&gt; use &lt;code&gt;UElementKt.getSourcePsiElement()&lt;/code&gt;,
  for &lt;code&gt;PsiElement&lt;/code&gt; that "emulates" behaviour of Java-elements (&lt;code&gt;PsiClass&lt;/code&gt;, &lt;code&gt;PsiMethod&lt;/code&gt;, etc.)
  use &lt;code&gt;UElementKt.getAsJavaPsiElement()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  See &lt;a href="https://plugins.jetbrains.com/docs/intellij/uast.html"&gt;UAST - Unified Abstract Syntax Tree&lt;/a&gt; in SDK Docs.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PresentationAnnotation" defaultSeverity="ERROR" displayName="Invalid icon path in @Presentation" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports invalid and deprecated value for &lt;code&gt;icon&lt;/code&gt; attribute in &lt;code&gt;com.intellij.ide.presentation.Presentation&lt;/code&gt; annotation.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingAccessibleContext" defaultSeverity="WARNING" displayName="Accessible context is missing" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Swing components that do not provide accessibility context.
&lt;p&gt;
  This information is used by screen readers. Failing to provide it makes the component inaccessible for
  visually impaired users.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  ListCellRenderer&amp;lt;String&amp;gt; renderer = (list, val, index, sel, cell) -&gt; {
    JPanel panel = new JPanel();
    return panel;
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  To fix the problem, you should either call &lt;code&gt;setAccessibleName()&lt;/code&gt; on the returned &lt;code&gt;JPanel&lt;/code&gt;
  or override its &lt;code&gt;getAccessibleContext()&lt;/code&gt; method.
&lt;/p&gt;
&lt;p&gt;
  The returned text should reflect the purpose
  of the component. For example, in the case of &lt;code&gt;ListCellRenderer&lt;/code&gt;, this would be the text of the menu
  item.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseVirtualFileEquals" defaultSeverity="WARNING" displayName="Use 'VirtualFile#equals(Object)'" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports comparing &lt;code&gt;VirtualFile&lt;/code&gt; instances using &lt;code&gt;==&lt;/code&gt;.
&lt;p&gt;
  Replace with &lt;code&gt;equals()&lt;/code&gt; call.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonDefaultConstructor" defaultSeverity="ERROR" displayName="Non-default constructors for service and extension class" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports extension/service class having a non-default (empty) constructor.
&lt;p&gt;
  Other dependencies should be acquired when needed in corresponding methods only.
  Constructor having &lt;code&gt;Project&lt;/code&gt; for extension/service on the corresponding level is allowed.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnresolvedPluginConfigReference" defaultSeverity="ERROR" displayName="Unresolved plugin configuration reference" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unresolved references to plugin configuration elements.
&lt;p&gt;
  Referencing extension with an unknown &lt;code&gt;id&lt;/code&gt; might result in errors at runtime.
&lt;/p&gt;
&lt;p&gt;
  The following extension points are supported:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;com.intellij.advancedSetting&lt;/code&gt; in resource bundle &lt;code&gt;advanced.setting.*&lt;/code&gt; key&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.intellij.experimentalFeature&lt;/code&gt; in &lt;code&gt;Experiments.isFeatureEnabled()/setFeatureEnabled()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.intellij.notificationGroup&lt;/code&gt; in &lt;code&gt;Notification&lt;/code&gt; constructor and &lt;code&gt;NotificationGroupManager.getNotificationGroup()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.intellij.registryKey&lt;/code&gt; in &lt;code&gt;Registry&lt;/code&gt; methods &lt;code&gt;key&lt;/code&gt; parameter&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.intellij.toolWindow&lt;/code&gt; in resource bundle &lt;code&gt;toolwindow.stripe.*&lt;/code&gt; key&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MissingRecentApi" defaultSeverity="ERROR" displayName="Usage of IntelliJ API not available in older IDEs" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of IntelliJ Platform API introduced in a version &lt;em&gt;newer&lt;/em&gt; than the one specified in &lt;code&gt;&amp;lt;idea-version&gt;&lt;/code&gt; &lt;code&gt;@since-build&lt;/code&gt; in &lt;code&gt;plugin.xml&lt;/code&gt;.
&lt;p&gt;
  Using such API may lead to incompatibilities of the plugin with older IDE versions.
&lt;/p&gt;
&lt;p&gt;
  To avoid possible issues when running the plugin in older IDE versions, increase &lt;code&gt;since-build&lt;/code&gt; accordingly,
  or remove usages of this API.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
If &lt;code&gt;&amp;lt;idea-version&gt;&lt;/code&gt; &lt;code&gt;@since/until-build&lt;/code&gt; attributes are not specified in &lt;code&gt;plugin.xml&lt;/code&gt;, set &lt;b&gt;Since&lt;/b&gt;/&lt;b&gt;Until&lt;/b&gt; explicitly.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseJBColor" defaultSeverity="WARNING" displayName="Use Darcula aware JBColor" enabled="true" language="JAVA" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;java.awt.Color&lt;/code&gt;.
&lt;p&gt;
  These are not aware of "dark" themes (e.g., bundled "Darcula") and might result in bad looking UI.
&lt;/p&gt;
&lt;p&gt;
  Quick-fix replaces usages with &lt;code&gt;JBColor&lt;/code&gt;, which defines "dark" color variant.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseCouple" defaultSeverity="WARNING" displayName="Use Couple instead of Pair" enabled="false" language="JAVA" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;Pair&amp;lt;T, T&amp;gt;&lt;/code&gt; replaceable by &lt;code&gt;Couple&amp;lt;T&amp;gt;&lt;/code&gt;.
&lt;p&gt;
  Quick-fix performs replacement.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InspectionUsingGrayColors" defaultSeverity="WARNING" displayName="Using new Color(a,a,a)" enabled="true" language="JAVA" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;java.awt.Color&lt;/code&gt; to create gray colors.
&lt;p&gt;
  Quick-fix &lt;b&gt;Convert to Gray&lt;/b&gt; replaces it using &lt;code&gt;com.intellij.ui.Gray&lt;/code&gt; constants instead.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;code&gt;Color myGray = new Color(55, 55, 55);&lt;/code&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;code&gt;Color myGray = Gray._55;&lt;/code&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ComponentNotRegistered" defaultSeverity="WARNING" displayName="Component/Action not registered" enabled="true" language="JVM" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports plugin components and actions that are not registered in a &lt;code&gt;plugin.xml&lt;/code&gt; descriptor.
&lt;p&gt;
  This eases developing new components when using the "Create Class" intention and helps keep track of potentially obsolete components.
&lt;/p&gt;
&lt;p&gt;
  Provided quick-fix to register the component adds necessary registration in &lt;code&gt;plugin.xml&lt;/code&gt; descriptor.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Check Actions&lt;/b&gt; option to turn off the check for Actions, as they may be intentionally created and
    registered dynamically.
  &lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore non-public classes&lt;/b&gt; option to ignore abstract and non-public classes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LeakableMapKey" defaultSeverity="WARNING" displayName="Map key may leak" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports using &lt;code&gt;Language&lt;/code&gt; or &lt;code&gt;FileType&lt;/code&gt; as a map key in plugin code.
&lt;p&gt;
  Such usages might lead to inability to unload the plugin properly.
&lt;/p&gt;
&lt;p&gt;
  Please consider using &lt;code&gt;String&lt;/code&gt; as keys instead.
&lt;/p&gt;
&lt;p&gt;
  See &lt;a href="https://plugins.jetbrains.com/docs/intellij/dynamic-plugins.html"&gt;Dynamic
  Plugins&lt;/a&gt; in SDK Docs for more information.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseDPIAwareBorders" defaultSeverity="WARNING" displayName="Use DPI-aware borders" enabled="true" language="JAVA" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;javax.swing.border.EmptyBorder&lt;/code&gt;.
&lt;p&gt;
  These are not DPI-aware and can result in UI layout problems.
&lt;/p&gt;
&lt;p&gt;
  Quick-fix performs replacement with &lt;code&gt;JBUI.Borders.empty()&lt;/code&gt;.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncorrectParentDisposable" defaultSeverity="WARNING" displayName="Incorrect parentDisposable parameter" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports using &lt;code&gt;Application&lt;/code&gt; or &lt;code&gt;Project&lt;/code&gt; as a parent &lt;code&gt;Disposable&lt;/code&gt; in plugin code.
&lt;p&gt;
  Such usages will lead to plugins not being unloaded correctly.
  Please see &lt;a
  href="https://plugins.jetbrains.com/docs/intellij/disposers.html?from=IncorrectParentDisposable#choosing-a-disposable-parent"&gt;Choosing a
  Disposable Parent&lt;/a&gt; in SDK Docs.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="FileEqualsUsage" defaultSeverity="WARNING" displayName="File.equals() usage" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;java.io.File.equals()/hashCode()/compareTo()&lt;/code&gt; methods.
&lt;p&gt;
  These do not honor case-insensitivity on macOS.
&lt;/p&gt;
&lt;p&gt;
  Use &lt;code&gt;com.intellij.openapi.util.io.FileUtil.filesEquals()/fileHashCode()/compareFiles()&lt;/code&gt; methods instead.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PsiElementConcatenation" defaultSeverity="WARNING" displayName="Using PsiElement string representation to generate new expression is incorrect" enabled="true" language="JAVA" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports direct usage of &lt;code&gt;PsiElement&lt;/code&gt; and &lt;code&gt;PsiType&lt;/code&gt; in strings.
&lt;p&gt;
  When building strings for &lt;code&gt;PsiJavaParserFacade.createExpressionFromText()&lt;/code&gt; (or similar methods), &lt;code&gt;PsiElement.getText()&lt;/code&gt; should be used
  instead.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UndesirableClassUsage" defaultSeverity="WARNING" displayName="Undesirable class usage" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of undesirable classes (mostly Swing components).
&lt;p&gt;
  Quick-fix offers replacement with recommended IntelliJ Platform replacement.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnsafeReturnStatementVisitor" defaultSeverity="WARNING" displayName="Unsafe return statements visitor" enabled="true" language="JAVA" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unsafe use of &lt;code&gt;JavaRecursiveElementVisitor.visitReturnStatement()&lt;/code&gt;.
&lt;p&gt;
  Processing &lt;code&gt;PsiReturnStatement&lt;/code&gt;s
  even if they belong to another &lt;code&gt;PsiClass&lt;/code&gt; or &lt;code&gt;PsiLambdaExpression&lt;/code&gt; is a bug in most cases.
&lt;/p&gt;
&lt;p&gt;
  Quick-fix inserts necessary explicit &lt;code&gt;visitClass()/visitLambdaExpression()&lt;/code&gt; method(s).
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="QuickFixGetFamilyNameViolation" defaultSeverity="WARNING" displayName="QuickFix's getFamilyName() implementation must not depend on a specific context" enabled="true" language="JAVA" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;QuickFix#getFamilyName()&lt;/code&gt; using contextual information.
&lt;p&gt;
  This method must not use any non-static information.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ActionIsNotPreviewFriendly" defaultSeverity="WARNING" displayName="Field blocks intention preview" enabled="true" language="UAST" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields in &lt;code&gt;LocalQuickFix&lt;/code&gt; implementations that prevent intention preview action from functioning properly.
&lt;p&gt;
  Intention preview is an IntelliJ platform feature that displays how quick-fix or intention action
  will change the current file when applied. To implement this, &lt;code&gt;LocalQuickFix.generatePreview()&lt;/code&gt;
  is called with a custom &lt;code&gt;ProblemDescriptor&lt;/code&gt; that points to the non-physical copy of current file.
  Normally, it just delegates to &lt;code&gt;LocalQuickFix.applyFix()&lt;/code&gt;. However, some quick-fixes
  may refer directly or indirectly to physical elements and use them for writing. As a result,
  preview won't work, as the quick-fix will attempt to update physical PSI instead of non-physical one.
  To avoid this, default implementation of &lt;code&gt;generatePreview()&lt;/code&gt; delegates only if all the
  instance fields of a quick-fix class have safe types: primitives, Strings, etc.
&lt;/p&gt;
&lt;p&gt;
  You may fix this problem in a number of ways:
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    If the field does not actually store any PSI reference, or that PSI is used only for reading,
    you may annotate the field with &lt;code&gt;@SafeFieldForPreview&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
    You may override &lt;code&gt;getFileModifierForPreview()&lt;/code&gt; method and create a copy of the quick-fix
    rebinding it to the non-physical file copy which is supplied as a parameter. Use
    &lt;code&gt;PsiTreeUtil.findSameElementInCopy()&lt;/code&gt; to find the corresponding PSI elements inside the
    supplied non-physical copy.
  &lt;/li&gt;
  &lt;li&gt;
    Instead of storing PSI references in fields, try to extract all the necessary information from
    &lt;code&gt;ProblemDescriptor.getPsiElement()&lt;/code&gt;.
  &lt;/li&gt;
  &lt;li&gt;
    You may override &lt;code&gt;generatePreview()&lt;/code&gt; method and provide completely custom preview behavior.
    For example, it's possible to display a custom HTML document instead of actual preview if your action
    does something besides modifying a current file.
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
  This inspection does not report if a custom implementation of &lt;code&gt;getFileModifierForPreview()&lt;/code&gt;
  or &lt;code&gt;generatePreview()&lt;/code&gt; exists. However, this doesn't mean that the implementation is correct and preview works.
  Please test. Also note that preview result is calculated in background thread, so you cannot start a write action
  during the preview or do any operation that requires a write action. Finally, no preview is generated automatically
  if &lt;code&gt;startInWriteAction()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. In this case, having custom &lt;code&gt;generatePreview()&lt;/code&gt;
  implementation is desired.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2022.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseDPIAwareInsets" defaultSeverity="WARNING" displayName="Use DPI-aware insets" enabled="true" language="JAVA" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;java.awt.Insets&lt;/code&gt;.
&lt;p&gt;
  These are not DPI-aware and can result in UI layout problems.
&lt;/p&gt;
&lt;p&gt;
  Quick-fix performs replacement with &lt;code&gt;JBUI.insets()&lt;/code&gt;.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnsafeVfsRecursion" defaultSeverity="WARNING" displayName="Unsafe VFS recursion" enabled="true" language="JAVA" pluginId="DevKit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usage of &lt;code&gt;VirtualFile.getChildren()&lt;/code&gt; inside recursive methods.
&lt;p&gt;
  This may cause endless loops when iterating over cyclic symlinks.
  Use &lt;code&gt;VfsUtilCore.visitChildrenRecursively()&lt;/code&gt; instead.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Cloning issues" path="Java"><inspection shortName="CloneableImplementsClone" defaultSeverity="WARNING" displayName="Cloneable class without 'clone()' method" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes implementing the &lt;code&gt;Cloneable&lt;/code&gt; interface that don't override the
&lt;code&gt;clone()&lt;/code&gt; method.
&lt;p&gt;Such classes use the default implementation of &lt;code&gt;clone()&lt;/code&gt;,
  which isn't &lt;code&gt;public&lt;/code&gt; but &lt;code&gt;protected&lt;/code&gt;, and which does not copy the mutable state of the class.&lt;/p&gt;
&lt;p&gt;A quick-fix is available to generate a basic &lt;code&gt;clone()&lt;/code&gt; method,
which can be used as a basis for a properly functioning &lt;code&gt;clone()&lt;/code&gt; method
  expected from a &lt;code&gt;Cloneable&lt;/code&gt; class.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Data &lt;b&gt;implements&lt;/b&gt; Cloneable {
    &lt;b&gt;private&lt;/b&gt; String[] names;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Data &lt;b&gt;implements&lt;/b&gt; Cloneable {
    &lt;b&gt;private&lt;/b&gt; String[] names;

    @Override
    &lt;b&gt;public&lt;/b&gt; Data clone() {
      &lt;b&gt;try&lt;/b&gt; {
        Data clone = (Data) &lt;b&gt;super&lt;/b&gt;.clone();
        // TODO: copy mutable state here, so the clone can't change the internals of the original
        &lt;b&gt;return&lt;/b&gt; clone;
      } &lt;b&gt;catch&lt;/b&gt; (CloneNotSupportedException e) {
        &lt;b&gt;throw new&lt;/b&gt; AssertionError();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!--
Note for translators: the text of the TODO comment in the example code above comes from
community/plugins/InspectionGadgets/InspectionGadgetsAnalysis/resources/messages/InspectionGadgetsBundle.properties
property key: cloneable.class.without.clone.todo.message
--&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore classes cloneable due to inheritance&lt;/b&gt; option to ignore classes that are
  &lt;code&gt;Cloneable&lt;/code&gt; because they inherit from the &lt;code&gt;Cloneable&lt;/code&gt; class.&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore when Cloneable is necessary to call clone() method of super class&lt;/b&gt;
  option to ignore classes that require implementing &lt;code&gt;Cloneable&lt;/code&gt; because they call the &lt;code&gt;clone()&lt;/code&gt; method from a superclass.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneCallsConstructors" defaultSeverity="WARNING" displayName="'clone()' instantiates objects with constructor" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to object constructors inside &lt;code&gt;clone()&lt;/code&gt; methods.
&lt;p&gt;It is considered good practice to call &lt;code&gt;clone()&lt;/code&gt; to instantiate objects inside of a &lt;code&gt;clone()&lt;/code&gt; method
  instead of creating them directly to support later subclassing.
This inspection will not report
&lt;code&gt;clone()&lt;/code&gt; methods declared as &lt;code&gt;final&lt;/code&gt;
  or &lt;code&gt;clone()&lt;/code&gt; methods on &lt;code&gt;final&lt;/code&gt; classes.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneInNonCloneableClass" defaultSeverity="WARNING" displayName="'clone()' method in non-Cloneable class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that override the
&lt;code&gt;clone()&lt;/code&gt; method but don't implement the &lt;code&gt;Cloneable&lt;/code&gt; interface.
This usually represents a programming error.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Only warn on 'public' clone methods&lt;/b&gt; option to ignore methods that aren't &lt;code&gt;public&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For classes designed to be inherited, you may choose to override &lt;code&gt;clone()&lt;/code&gt; and declare it as &lt;code&gt;protected&lt;/code&gt;
without implementing the &lt;code&gt;Cloneable&lt;/code&gt; interface and decide whether to implement the &lt;code&gt;Cloneable&lt;/code&gt; interface in subclasses.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfClone" defaultSeverity="WARNING" displayName="Use of 'clone()' or 'Cloneable'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports implementations of and calls to the &lt;code&gt;clone()&lt;/code&gt; method and uses of &lt;code&gt;java.lang.Cloneable&lt;/code&gt;.
&lt;p&gt;Some coding standards prohibit the use of &lt;code&gt;clone()&lt;/code&gt; and recommend using a copy constructor or
  the &lt;code&gt;static&lt;/code&gt; factory method instead.&lt;/p&gt;
&lt;p&gt;The inspection ignores calls to &lt;code&gt;clone()&lt;/code&gt; on arrays because it's a correct and compact way to copy an array.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneReturnsClassType" defaultSeverity="WARNING" displayName="'clone()' should have return type equal to the class it contains" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;clone()&lt;/code&gt; methods with return types different from the class they're located in.
&lt;p&gt;Often a &lt;code&gt;clone()&lt;/code&gt; method will have a return type of &lt;code&gt;java.lang.Object&lt;/code&gt;, which makes it harder to use by its clients.
&lt;i&gt;Effective Java&lt;/i&gt; (the second and third editions) recommends making the return type of the &lt;code&gt;clone()&lt;/code&gt; method the same as the
  class type of the object it returns.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;class&lt;/b&gt; Foo &lt;b&gt;implements&lt;/b&gt; Cloneable {
    &lt;b&gt;public&lt;/b&gt; Object clone() {
      &lt;b&gt;try&lt;/b&gt; {
        &lt;b&gt;return&lt;/b&gt; super.clone();
      } &lt;b&gt;catch&lt;/b&gt; (CloneNotSupportedException e) {
        &lt;b&gt;throw new&lt;/b&gt; AssertionError();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;class&lt;/b&gt; Foo &lt;b&gt;implements&lt;/b&gt; Cloneable {
    &lt;b&gt;public&lt;/b&gt; Foo clone() {
      &lt;b&gt;try&lt;/b&gt; {
        &lt;b&gt;return&lt;/b&gt; (Foo)super.clone();
      } &lt;b&gt;catch&lt;/b&gt; (CloneNotSupportedException e) {
        &lt;b&gt;throw new&lt;/b&gt; AssertionError();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonPublicClone" defaultSeverity="WARNING" displayName="'clone()' method not 'public'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;clone()&lt;/code&gt; methods that are &lt;code&gt;protected&lt;/code&gt; and not &lt;code&gt;public&lt;/code&gt;.
&lt;p&gt;When overriding the &lt;code&gt;clone()&lt;/code&gt; method from &lt;code&gt;java.lang.Object&lt;/code&gt;, it is expected to make the method &lt;code&gt;public&lt;/code&gt;,
  so that it is accessible from non-subclasses outside the package.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CloneDeclaresCloneNotSupported" defaultSeverity="WARNING" displayName="'clone()' does not declare 'CloneNotSupportedException'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;clone()&lt;/code&gt; methods that do not declare &lt;code&gt;throws CloneNotSupportedException&lt;/code&gt;.
&lt;p&gt;If &lt;code&gt;throws CloneNotSupportedException&lt;/code&gt; is not declared, the method's subclasses will not be able to prohibit cloning
in the standard way. This inspection does not report &lt;code&gt;clone()&lt;/code&gt; methods declared &lt;code&gt;final&lt;/code&gt;
and &lt;code&gt;clone()&lt;/code&gt; methods on &lt;code&gt;final&lt;/code&gt; classes.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Only warn on 'protected' clone methods&lt;/b&gt; option to indicate that this inspection should only warn on &lt;code&gt;protected clone()&lt;/code&gt; methods.
The &lt;i&gt;Effective Java&lt;/i&gt; book (second and third edition) recommends omitting the &lt;code&gt;CloneNotSupportedException&lt;/code&gt;
declaration on &lt;code&gt;public&lt;/code&gt; methods, because the methods that do not throw checked exceptions are easier to use.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; Example &lt;b&gt;implements&lt;/b&gt; Cloneable {
    // method doesn't declare 'throws CloneNotSupportedException'
    &lt;b&gt;protected&lt;/b&gt; Object clone() {
        &lt;b&gt;try&lt;/b&gt; {
            &lt;b&gt;return&lt;/b&gt; &lt;b&gt;super&lt;/b&gt;.clone();
        } &lt;b&gt;catch&lt;/b&gt; (CloneNotSupportedException e) {
            &lt;b&gt;return&lt;/b&gt; null;
        }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JVM languages" path=""><inspection shortName="NonExtendableApiUsage" defaultSeverity="WARNING" displayName="Class, interface, or method should not be extended" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes, interfaces and methods that extend, implement, or override API elements marked with &lt;code&gt;@ApiStatus.NonExtendable&lt;/code&gt;.
&lt;p&gt;
  The &lt;code&gt;@ApiStatus.NonExtendable&lt;/code&gt; annotation indicates that the class, interface, or method &lt;strong&gt;must not be extended, 
  implemented, or overridden&lt;/strong&gt;.
  Since casting such interfaces and classes to the internal library implementation is rather common,
  if a client provides a different implementation, you will get &lt;code&gt;ClassCastException&lt;/code&gt;.
  Adding new abstract methods to such classes and interfaces will break the compatibility with the client's implementations.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="OverrideOnly" defaultSeverity="WARNING" displayName="Method can only be overridden" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to API methods marked with &lt;code&gt;@ApiStatus.OverrideOnly&lt;/code&gt;.
&lt;p&gt;
  The &lt;code&gt;@ApiStatus.OverrideOnly&lt;/code&gt; annotation indicates that the method is part of SPI (Service Provider Interface).
  Clients of the declaring library should implement or override such methods, not call them directly.
  Marking a class or interface with this annotation is the same as marking every method with it.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MissingDeprecatedAnnotationOnScheduledForRemovalApi" defaultSeverity="ERROR" displayName="Missing '@Deprecated' annotation on scheduled for removal API" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports declarations marked with &lt;code&gt;@ApiStatus.ScheduledForRemoval&lt;/code&gt; without &lt;code&gt;@Deprecated&lt;/code&gt;.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;
  @ApiStatus.ScheduledForRemoval(inVersion = "2017.3")
  public void myLegacyMethod() { }
&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied the result looks like:&lt;/p&gt;
&lt;pre&gt;
  @Deprecated
  @ApiStatus.ScheduledForRemoval(inVersion = "2017.3")
  public void myLegacyMethod() { }
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnit5Converter" defaultSeverity="WARNING" displayName="JUnit 4 test can be JUnit 5" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JUnit 4 tests that can be automatically migrated to JUnit 5.
While default runners are automatically convertible, custom runners, method- and field- rules are not and require manual changes.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import org.junit.Assert;
  import org.junit.Test;

  public class RelevantTest {
    @Test
    public void testIt() {
      Assert.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import org.junit.jupiter.api.Assertions;
  import org.junit.jupiter.api.Test;

  public class RelevantTest {
    @Test
    public void testIt() {
      Assertions.assertEquals("expected", "actual");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection requires that the JUnit 5 library is available in the classpath, and JDK 1.8 or later is configured for the project.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IllegalDependencyOnInternalPackage" defaultSeverity="ERROR" displayName="Illegal dependency on internal package" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports references in modules without &lt;code&gt;module-info.java&lt;/code&gt; on packages which are not exported from named modules. 
&lt;p&gt;Such configuration may occur when some modules in the project are already migrated to Java modules but others are still non-modular.
By analogy to the JDK, such non-modular code should not get access to the code in named modules which is not explicitly exported.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnit5AssertionsConverter" defaultSeverity="WARNING" displayName="Obsolete assertions in JUnit 5 tests" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports any calls to methods from the &lt;code&gt;junit.framework.Assert&lt;/code&gt;, &lt;code&gt;org.junit.Assert&lt;/code&gt;, or &lt;code&gt;org.junit.Assume&lt;/code&gt;
  classes inside JUnit 5 tests.&lt;/p&gt;
&lt;p&gt;Although the tests work properly, migration to &lt;code&gt;org.junit.jupiter.api.Assertions&lt;/code&gt;/&lt;code&gt;org.junit.jupiter.api.Assumptions&lt;/code&gt;
  will help you avoid dependencies on old JUnit version.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import org.junit.Assert;
  import org.junit.jupiter.api.Test;

  public class MyTest {
    @Test
    public void simpleTest() {
      Assert.assertEquals(4, 2 + 2);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import org.junit.jupiter.api.Assertions;
  import org.junit.jupiter.api.Test;

  public class MyTest {
    @Test
    public void simpleTest() {
      Assertions.assertEquals(4, 2 + 2);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="BlockingMethodInNonBlockingContext" defaultSeverity="WARNING" displayName="Possibly blocking call in non-blocking context" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports thread-blocking method calls in code fragments where threads should not be blocked.

&lt;p&gt;&lt;b&gt;Example (Project Reactor):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Flux.just("1").flatMap(f -&amp;gt; {
    Flux&amp;lt;String&amp;gt; just = loadUsersFromDatabase();
    just.toIterable(); // Error: blocking operator call in non-blocking scope
    return just;
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Consider running blocking code &lt;a href="https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking"&gt;with a proper
  scheduler&lt;/a&gt;, for example &lt;code&gt;Schedulers.boundedElastic()&lt;/code&gt;, or try to find an alternative non-blocking API.&lt;/p&gt;

&lt;br/&gt;

&lt;p&gt;&lt;b&gt;Example (Kotlin Coroutines):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
suspend fun exampleFun() {
    Thread.sleep(100); // Error: blocking method call inside suspend function
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Consider running blocking code &lt;a href="https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html"&gt;with a special dispatcher&lt;/a&gt;,
  for example &lt;code&gt;Dispatchers.IO&lt;/code&gt;, or try to find an alternative non-blocking API.&lt;/p&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;In the &lt;b&gt;Blocking Annotations&lt;/b&gt; list, specify annotations that mark thread-blocking methods.&lt;/li&gt;
  &lt;li&gt;In the &lt;b&gt;Non-Blocking Annotations&lt;/b&gt; list, specify annotations that mark non-blocking methods.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Specified annotations can be used as &lt;a href="https://www.jetbrains.com/help/idea/external-annotations.html"&gt;External Annotations&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SourceToSinkFlow" defaultSeverity="WARNING" displayName="Non-safe string is passed to safe method" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;&lt;body&gt;
Reports cases when non-safe string is passed to a method with parameter marked with annotation &lt;code&gt;org.checkerframework.checker.tainting.qual.Untainted&lt;/code&gt;.
&lt;p&gt;
  Safe string is:
&lt;ul&gt;
  &lt;li&gt;call of method that is marked as &lt;code&gt;@Untainted&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;local variable or method parameter that does not call non-safe methods&lt;/li&gt;
  &lt;li&gt;field, local variable or parameter that is marked as &lt;code&gt;@Untainted&lt;/code&gt; and does not have non-safe methods calls assigned&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
Example:
&lt;pre&gt;
&lt;code&gt;
  void doSmth(boolean b) {
    String s = safe();
    String s1 = "other";
    if (b) s1 = s;
    sink(s);
  }
  
  String sink(@Untainted String s) {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;
Here we do not have non-safe string assignments to &lt;code&gt;s&lt;/code&gt; so warning is not produced. On the other hand:
&lt;pre&gt;
&lt;code&gt;
  void doSmth(boolean b) {
    String s = safe();
    String s1 = "other";
    s1 = foo();
    if (b) s = s1;
    sink(s);        // warning here
  }
  
  String foo();

  String sink(@Untainted String s) {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;
Here we have a warning since &lt;code&gt;s1&lt;/code&gt; has an unknown state after &lt;code&gt;foo&lt;/code&gt; call result assignment.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2021.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="Dependency" defaultSeverity="ERROR" displayName="Illegal package dependencies" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports illegal dependencies between scopes according to the dependency rules given. Dependency rules can be used to prohibit usage from a
scope to another scope.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Configure dependency rules&lt;/b&gt; button below to customize validation rules.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MustAlreadyBeRemovedApi" defaultSeverity="ERROR" displayName="API must already be removed" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports declarations marked with &lt;code&gt;@ApiStatus.ScheduledForRemoval&lt;/code&gt;
that should have been removed in the current version of the declaring library.
&lt;!-- tooltip end --&gt;
&lt;p&gt;It compares the specified scheduled removal version with the version that you can set below.&lt;/p&gt;
&lt;p&gt;
  Specify the version as a string separated with dots and optionally postfixed with
  &lt;code&gt;alpha&lt;/code&gt;, &lt;code&gt;beta&lt;/code&gt;, &lt;code&gt;snapshot&lt;/code&gt;, or &lt;code&gt;eap&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;Examples of valid versions: &lt;code&gt;1.0&lt;/code&gt;, &lt;code&gt;2.3.1&lt;/code&gt;, &lt;code&gt;2018.1&lt;/code&gt;, &lt;code&gt;7.5-snapshot&lt;/code&gt;, &lt;code&gt;3.0-eap&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  Version comparison is intuitive: &lt;code&gt;1.0 &amp;lt; 2.0&lt;/code&gt;, &lt;code&gt;1.0-eap &amp;lt; 1.0&lt;/code&gt;, &lt;code&gt;2.3-snapshot &amp;lt; 2.3&lt;/code&gt; and so on.
  For detailed comparison logic, refer to the implementation of &lt;a
  href="https://github.com/JetBrains/intellij-community/blob/master/platform/util-rt/src/com/intellij/util/text/VersionComparatorUtil.java"&gt;VersionComparatorUtil&lt;/a&gt;.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TestOnlyProblems" defaultSeverity="WARNING" displayName="Test-only usage in production code" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;@TestOnly&lt;/code&gt;- and &lt;code&gt;@VisibleForTesting&lt;/code&gt;-annotated methods and classes that are used in production code. Also reports
usage of applying &lt;code&gt;@TestOnly&lt;/code&gt; &lt;code&gt;@VisibleForTesting&lt;/code&gt; to the same element.

&lt;p&gt;The problems are not reported if such method or class is referenced from:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Code under the &lt;b&gt;Test Sources&lt;/b&gt; folder
  &lt;li&gt;A test class (JUnit/TestNG)
  &lt;li&gt;Another &lt;code&gt;@TestOnly&lt;/code&gt;-annotated method
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;Example (in production code):&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @TestOnly
  fun foo() { ... }

  fun main () {
    foo()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="TestFailedLine" defaultSeverity="WARNING" displayName="Failed line in test" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports failed method calls or assertions in tests. It helps detect the failed line in code faster and start debugging it immediately.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Test
  fun foo() {
    assertEquals(1, 0) // highlighted
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SerializableHasSerialVersionUIDField" defaultSeverity="WARNING" displayName="Serializable class without 'serialVersionUID'" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that implement &lt;code&gt;Serializable&lt;/code&gt; and do not declare a &lt;code&gt;serialVersionUID&lt;/code&gt; field.
&lt;p&gt;
  Without a &lt;code&gt;serialVersionUID&lt;/code&gt; field, any change to the class will make previously serialized versions unreadable.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Serializable {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main implements Serializable {
    private static final long serialVersionUID = -1446398935944895849L;
  }
&lt;/code&gt;&lt;/pre&gt;
When using a language level of JDK 14 or higher, the quickfix will also add the &lt;code&gt;java.io.Serial&lt;/code&gt; annotation.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the following options to configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    List classes whose inheritors should not be reported by this inspection.
    This is meant for classes that inherit
    &lt;code&gt;Serializable&lt;/code&gt; from a superclass but are not intended for serialization.
  &lt;/li&gt;
  &lt;li&gt;
    Whether to ignore &lt;code&gt;Serializable&lt;/code&gt; anonymous classes.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Since15" defaultSeverity="ERROR" displayName="Usages of API which isn't available at the configured language level" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of the API that is unavailable at the configured language level.
This inspection does 3 things:
&lt;ul&gt;
  &lt;li&gt;Highlight usage of generified classes when the language level is below Java 7.&lt;/li&gt;
  &lt;li&gt;Highlight when default methods are not overridden and the language level is below Java 8.&lt;/li&gt;
  &lt;li&gt;Highlight usage of API when the language level is lower than marked using the &lt;code&gt;@since&lt;/code&gt; tag in the documentation.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Forbid API usages&lt;/b&gt; option to forbid usages of the API in respect to the project or custom language level.
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnstableTypeUsedInSignature" defaultSeverity="WARNING" displayName="Unstable type is used in signature" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports declarations of classes, methods, and fields that reference an unstable API type in the signature,
but are not marked with the same unstable annotation.
&lt;p&gt;
  This inspection ensures that the signatures of a public API do not expose any &lt;i&gt;unstable&lt;/i&gt; (internal, experimental) types.
  For example, if a method returns an &lt;i&gt;experimental&lt;/i&gt; class, the method itself is considered &lt;i&gt;experimental&lt;/i&gt;
  because incompatible changes of the type (deletion or move to another package) lead to incompatible method signature changes.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the list below to specify which annotations mark an unstable API.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnstableApiUsage" defaultSeverity="WARNING" displayName="Unstable API Usage" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking
the code that uses it.
&lt;!-- tooltip end --&gt;
&lt;p&gt;The annotations which are used to mark unstable APIs are shown in the list below.&lt;/p&gt;
&lt;p&gt;By default, the inspection ignores usages of unstable APIs
if their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.
  However, it may be inconvenient if the project is big, so one can switch off the &lt;b&gt;Ignore API declared in this project&lt;/b&gt; option to report
the usages of unstable APIs declared in both the project sources and libraries.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JUnitRule" defaultSeverity="ERROR" displayName="Malformed @Rule/@ClassRule field" enabled="false" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports malformed &lt;code&gt;@Rule&lt;/code&gt; or &lt;code&gt;@ClassRule&lt;/code&gt; annotation usages.
Tests with malformed &lt;a href="https://github.com/junit-team/junit4/wiki/Rules"&gt;rules&lt;/a&gt; cannot be run.
&lt;ul&gt;
  &lt;li&gt;
    A &lt;code&gt;@Rule&lt;/code&gt; annotated member must be &lt;code&gt;public&lt;/code&gt; and a subtype of
    &lt;code&gt;org.junit.rules.TestRule&lt;/code&gt; or &lt;code&gt;org.junit.rules.MethodRule&lt;/code&gt;
  &lt;li&gt;
    A &lt;code&gt;@ClassRule&lt;/code&gt; annotated member must be &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; and a subtype of
    &lt;code&gt;org.junit.rules.TestRule&lt;/code&gt;
&lt;/ul&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; MomentousTest {
    @Rule
    &lt;b&gt;private final&lt;/b&gt; TemporaryFolder tempFolder =
      &lt;b&gt;new&lt;/b&gt; TemporaryFolder();

    // ... tests go here
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick fix is provided to fix the modifiers:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;public class&lt;/b&gt; MomentousTest {
    @Rule
    &lt;b&gt;public final&lt;/b&gt; TemporaryFolder tempFolder =
      &lt;b&gt;new&lt;/b&gt; TemporaryFolder();

    // ... tests go here
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThreadRun" defaultSeverity="WARNING" displayName="Call to 'Thread.run()'" enabled="true" language="UAST" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports calls to &lt;code&gt;run()&lt;/code&gt; on &lt;code&gt;java.lang.Thread&lt;/code&gt; or any of its subclasses.&lt;/p&gt;
&lt;p&gt;
  While occasionally intended, this is usually a mistake, because &lt;code&gt;run()&lt;/code&gt; doesn't start a new thread.
  To execute the code in a separate thread, &lt;code&gt;start()&lt;/code&gt; should be used.&lt;/p&gt;
&lt;p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Message resolution" path="Objective-C"><inspection shortName="NotInHierarchyMessage" defaultSeverity="WARNING" displayName="Not in a hierarchy message" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the send message expressions which resolve to the methods not declared in the receiver's class or its ancestors.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnresolvedMessage" defaultSeverity="WARNING" displayName="Unresolved message" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the send message expressions that have no target method in the project scope.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnresolvedCollectionMessage" defaultSeverity="WARNING" displayName="Unresolved collection message" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the expressions that are used in the &lt;code&gt;for..in&lt;/code&gt; loops and don't conform to the &lt;code&gt;NSFastEnumeration&lt;/code&gt; protocol.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SeveralTargetsMessage" defaultSeverity="WARNING" displayName="Several targets message" enabled="false" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the send message expressions that may resolve to several target methods.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Resource management" path="Java"><inspection shortName="IOResource" defaultSeverity="WARNING" displayName="I/O resource opened but not safely closed" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports I/O resources that are not safely closed. I/O resources checked
by this inspection include &lt;code&gt;java.io.InputStream&lt;/code&gt;,
&lt;code&gt;java.io.OutputStream&lt;/code&gt;, &lt;code&gt;java.io.Reader&lt;/code&gt;,
&lt;code&gt;java.io.Writer&lt;/code&gt;, &lt;code&gt;java.util.zip.ZipFile&lt;/code&gt;, &lt;code&gt;java.io.Closeable&lt;/code&gt; and &lt;code&gt;java.io.RandomAccessFile&lt;/code&gt;.
&lt;p&gt;
  I/O resources wrapped by other I/O resources are not reported, as the wrapped resource will be closed by the wrapping resource.
&lt;/p&gt;
&lt;p&gt;
  By default, the inspection assumes that the resources can be closed by any method with
  'close' or 'cleanup' in its name.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void save() throws IOException {
    FileWriter writer = new FileWriter("filename.txt"); //warning
    writer.write("sample");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the following options to configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;List I/O resource classes that do not need to be closed and should be ignored by this inspection.&lt;/li&gt;
  &lt;li&gt;
    Whether an I/O resource is allowed to be opened inside a &lt;code&gt;try&lt;/code&gt;block.
    This style is less desirable because it is more verbose than opening a resource in front of a &lt;code&gt;try&lt;/code&gt; block.
  &lt;/li&gt;
  &lt;li&gt;
    Whether the resource can be closed by any method call with the resource passed as argument.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JDBCResource" defaultSeverity="WARNING" displayName="JDBC resource opened but not safely closed" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JDBC resources that are not safely closed. JDBC resources reported
by this inspection include &lt;code&gt;java.sql.Connection&lt;/code&gt;,
&lt;code&gt;java.sql.Statement&lt;/code&gt;, &lt;code&gt;java.sql.PreparedStatement&lt;/code&gt;,
&lt;code&gt;java.sql.CallableStatement&lt;/code&gt;, and &lt;code&gt;java.sql.ResultSet&lt;/code&gt;.
&lt;p&gt;
  By default, the inspection assumes that the resources can be closed by any method with
  'close' or 'cleanup' in its name.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ResultSet findAllElements(Connection connection) throws SQLException {
    PreparedStatement statement = connection.prepareStatement("SELECT * FROM TABLE");//statement is not closed
    statement.execute();
    return statement.getResultSet();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the following options to configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Whether a JDBC resource is allowed to be opened inside a &lt;code&gt;try&lt;/code&gt;
    block. This style is less desirable because it is more verbose than opening a resource
    in front of a &lt;code&gt;try&lt;/code&gt; block.
  &lt;/li&gt;
  &lt;li&gt;
    Whether the resource can be closed by any method call with the resource passed as argument.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DriverManagerGetConnection" defaultSeverity="WARNING" displayName="Use of 'DriverManager' to get JDBC connection" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any uses of &lt;code&gt;java.sql.DriverManager&lt;/code&gt;
to acquire a JDBC connection. 
&lt;p&gt;
  &lt;code&gt;java.sql.DriverManager&lt;/code&gt;
  has been superseded by &lt;code&gt;javax.sql.Datasource&lt;/code&gt;, which
  allows for connection pooling and other optimizations.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Connection conn = DriverManager.getConnection(url, username, password);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="JNDIResource" defaultSeverity="WARNING" displayName="JNDI resource opened but not safely closed" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports JNDI resources that are not safely closed. JNDI resources reported
by this inspection include &lt;code&gt;javax.naming.InitialContext&lt;/code&gt;,
and &lt;code&gt;javax.naming.NamingEnumeration&lt;/code&gt;.
&lt;p&gt;
  By default, the inspection assumes that the resources can be closed by any method with
  'close' or 'cleanup' in its name.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object findObject(Properties properties, String name) throws NamingException {
    Context context = new InitialContext(properties); //context is not closed
    return context.lookup(name);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the following options to configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Whether a JNDI Resource is allowed to be opened inside a &lt;code&gt;try&lt;/code&gt; block.
    This style is less desirable because it is more verbose than opening a resource in front of a &lt;code&gt;try&lt;/code&gt; block.
  &lt;/li&gt;
  &lt;li&gt;
    Whether the resource can be closed by any method call with the resource passed as argument.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AutoCloseableResource" defaultSeverity="WARNING" displayName="AutoCloseable used without 'try'-with-resources" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;AutoCloseable&lt;/code&gt; instances which are not used in a try-with-resources statement, also known as
&lt;i&gt;Automatic Resource Management&lt;/i&gt;.
&lt;p&gt;
  This means that the "open resource before/in &lt;code&gt;try&lt;/code&gt;, close in &lt;code&gt;finally&lt;/code&gt;" style that had been used before
  try-with-resources became available, is also reported.
  This inspection is meant to replace all &lt;i&gt;opened but not safely closed&lt;/i&gt; inspections when developing in Java 7 and higher.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  private static void foo() throws IOException {
    InputStream profile = Thread.currentThread().getContextClassLoader().getResourceAsStream("/someFile");
    System.out.println(profile.read());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the following options to configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    List subclasses of &lt;code&gt;AutoCloseable&lt;/code&gt; that do not need to be closed and should be ignored by this inspection.
    &lt;br/&gt;
    &lt;b&gt;Note&lt;/b&gt;: The inspection will still report streams returned from the &lt;code&gt;java.nio.file.Files&lt;/code&gt; methods &lt;code&gt;lines()&lt;/code&gt;,
    &lt;code&gt;walk()&lt;/code&gt;, &lt;code&gt;list()&lt;/code&gt; and &lt;code&gt;find()&lt;/code&gt;,
    even when &lt;code&gt;java.util.stream.Stream&lt;/code&gt; is listed to be ignored.
    These streams contain an associated I/O resource that needs to be closed.
  &lt;/li&gt;
  &lt;li&gt;
    List methods returning &lt;code&gt;AutoCloseable&lt;/code&gt; that should be ignored when called.
  &lt;/li&gt;
  &lt;li&gt;
    Whether to ignore an &lt;code&gt;AutoCloseable&lt;/code&gt; if it is the result of a method call.
    When this option is enabled, the results of factory methods will also be ignored.
  &lt;/li&gt;
  &lt;li&gt;
    Whether the inspection should report if an &lt;code&gt;AutoCloseable&lt;/code&gt; instance is passed as a method call argument.
    If this option is enabled, the inspection assumes the resource is closed in the called method.
    Method calls inside a &lt;code&gt;finally&lt;/code&gt; block with 'close' in the name and an
    &lt;code&gt;AutoCloseable&lt;/code&gt; argument will not be ignored.
  &lt;/li&gt;
  &lt;li&gt;
    Whether to ignore method references to constructors of resource classes.
  &lt;/li&gt;
  &lt;li&gt;
    Whether to ignore methods that return a resource and whose name starts with 'get'.
    This can reduce false positives because most of the getters do not transfer the ownership of the resource,
    and their call sites are not responsible for closing the resource.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ChannelResource" defaultSeverity="WARNING" displayName="'Channel' opened but not safely closed" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Channel&lt;/code&gt; resources that are not safely closed, including any instances created by calling
&lt;code&gt;getChannel()&lt;/code&gt; on a file or socket resource.
&lt;p&gt;
  By default, the inspection assumes that the resources can be closed by any method with
  'close' or 'cleanup' in its name.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void send(Socket socket) throws IOException {
    SocketChannel channel = socket.getChannel(); //warning
    channel.write(ByteBuffer.wrap("message".getBytes()));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the following options to configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Whether a &lt;code&gt;Channel&lt;/code&gt; resource is allowed to be opened inside a &lt;code&gt;try&lt;/code&gt;
    block. This style is less desirable because it is more verbose than opening a &lt;code&gt;Channel&lt;/code&gt;
    in front of a &lt;code&gt;try&lt;/code&gt; block.
  &lt;/li&gt;
  &lt;li&gt;
    Whether the resource can be closed by any method call with the resource passed as argument.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SocketResource" defaultSeverity="WARNING" displayName="Socket opened but not safely closed" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports socket resources that are not safely closed. Socket resources reported
by this inspection include &lt;code&gt;java.net.Socket&lt;/code&gt;,
&lt;code&gt;java.net.DatagramSocket&lt;/code&gt;, and &lt;code&gt;java.net.ServerSocket&lt;/code&gt;.
&lt;p&gt;
  By default, the inspection assumes that the resources can be closed by any method with
  'close' or 'cleanup' in its name.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  byte[] getMessage(ServerSocket socket) throws IOException {
    Socket client = socket.accept(); //socket is not closed
    return client.getInputStream().readAllBytes();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the following options to configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Whether a socket is allowed to be opened inside a &lt;code&gt;try&lt;/code&gt; block.
    This style is less desirable because it is more verbose than opening a resource in front of a &lt;code&gt;try&lt;/code&gt; block.
  &lt;/li&gt;
  &lt;li&gt;
    Whether the resource can be closed by any method call with the resource passed as argument.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HibernateResource" defaultSeverity="WARNING" displayName="Hibernate resource opened but not safely closed" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to the &lt;code&gt;openSession()&lt;/code&gt; method if the returned &lt;code&gt;org.hibernate.Session&lt;/code&gt; resource is not safely closed.
&lt;p&gt;
  By default, the inspection assumes that the resources can be closed by any method with
  'close' or 'cleanup' in its name.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void doHibernateQuery(SessionFactory factory) {
    Session session = factory.openSession(); //warning
    session.createQuery("...");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the following options to configure the inspection:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    Whether a &lt;code&gt;org.hibernate.Session&lt;/code&gt; resource is allowed to be opened inside a &lt;code&gt;try&lt;/code&gt;
    block. This style is less desirable because it is more verbose than opening a resource
    in front of a &lt;code&gt;try&lt;/code&gt; block.
  &lt;/li&gt;
  &lt;li&gt;
    Whether the resource can be closed by any method call with the resource passed as argument.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Type checks" path="C/C++"><inspection shortName="ValueMayNotFitIntoReceiver" defaultSeverity="WARNING" displayName="Value may not fit into receiver" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the cases when an expression of type A is used in the context of type B (assigned, cast, passed as a parameter, returned from a
  method, function, or a block, and so on) while the range of the values of type B is not large enough to store all possible values of type A.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NotSuperclass" defaultSeverity="WARNING" displayName="Not superclass" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the cases when an expression of type A is used in the context of type B (assigned, cast, passed as a parameter, returned from a
  method, function, or block, and so on) under the condition that A and B are class types, and B is not a superclass of A.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SignednessMismatch" defaultSeverity="WARNING" displayName="Signedness mismatch" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the cases when an expression of the signed type A is used in the context of the unsigned type B (assigned, cast, passed as a parameter, returned from a
  method, function, or block, and so on).
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncompatiblePointers" defaultSeverity="WARNING" displayName="Incompatible pointers" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the cases when an expression of a pointer type A is used in the context of another pointer type B (assigned, cast, passed as a parameter, returned from a
  method, function, or block, and so on). You must explicitly cast one pointer type to another to avoid the compiler warnings.
  This inspection isn't applicable when the both types are pointers to a class type.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitPointerAndIntegerConversion" defaultSeverity="WARNING" displayName="Implicit pointer and integer conversion" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the cases when the expressions of the integer type are used in the context of the pointer type or vice versa (assigned, cast, passed a parameter, returned from a
  method, function, or block, and so on). You must explicitly cast one type to another to avoid the compiler warnings.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitIntegerAndEnumConversion" defaultSeverity="WARNING" displayName="Implicit integer and enum conversion" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the cases when the expressions of the &lt;code&gt;enum&lt;/code&gt; type are used in the context of an integer or pointer type or vice versa (assigned, cast, passed as a parameter, returned from a
  method, function, or block, and so on). You must explicitly cast one type to another to avoid the compiler warnings.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayIssues" defaultSeverity="WARNING" displayName="Array issues" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports incorrect array usages.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncompatibleInitializers" defaultSeverity="WARNING" displayName="Incompatible initializers" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the cases when the variable initializer does not correspond to its declared type.
For example, there are too many initializers for an array or structure.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScalarTypeRequired" defaultSeverity="WARNING" displayName="Scalar type required" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the expressions that are required to have the scalar type but don't have it.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InitializationIssue" defaultSeverity="WARNING" displayName="Initialization issue" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports issues with C++ variables initialization.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncompatibleTypes" defaultSeverity="WARNING" displayName="Incompatible types" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports type inconsistencies.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TemplateArgumentsIssues" defaultSeverity="WARNING" displayName="Template arguments issues" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the class and function template specializations and instantiations with incorrect type or value arguments.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstExpressionRequired" defaultSeverity="WARNING" displayName="Const expression required" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the expressions that are required to be constant but are not.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncompatibleEnums" defaultSeverity="WARNING" displayName="Incompatible enums" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
  Reports the cases when an expression of the &lt;code&gt;enum&lt;/code&gt; type A is used in the context of another &lt;code&gt;enum&lt;/code&gt; type B (assigned, cast, passed as a parameter, returned from a
  method, function, or block, and so on).
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PointerTypeRequired" defaultSeverity="WARNING" displayName="Pointer type required" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the expressions that are required to have the pointer type but don't have it.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NotAssignable" defaultSeverity="WARNING" displayName="Not assignable" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the assignments to the non-assignable symbols.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IntegerTypeRequired" defaultSeverity="WARNING" displayName="Integer type required" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the expressions that are required to have the integer type but don't have it.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Language injection" path=""><inspection shortName="LanguageMismatch" defaultSeverity="WARNING" displayName="Language mismatch" enabled="true" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports when the language of a reference does not match the expected language of the usage context.

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Language("JavaScript")
  String JS_CODE = "var x;";

  @Language("XPath")
  String XPATH_CODE = JS_CODE; // warning here
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="InjectionNotApplicable" defaultSeverity="ERROR" displayName="Injection Annotation not applicable" enabled="true" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports when a &lt;code&gt;@Language&lt;/code&gt; annotation is applied to an element with a type other than &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;String[]&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Language("HTML") &lt;b&gt;int&lt;/b&gt; i;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;int&lt;/b&gt; i;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnknownLanguage" defaultSeverity="ERROR" displayName="Unknown Language ID" enabled="true" language="JAVA" pluginId="org.intellij.intelliLang" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports when the ID of the language used in a &lt;code&gt;@Language&lt;/code&gt; annotation is unknown.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Language("HMTL") String html;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Probable bugs" path="Kotlin"><inspection shortName="ConflictingExtensionProperty" defaultSeverity="WARNING" displayName="Extension property conflicting with synthetic one" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports extension properties that conflict with synthetic ones that have been automatically produced from Java &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; methods.
&lt;p&gt;Such properties should be either removed or renamed to avoid breaking code by future changes in the compiler.&lt;/p&gt;
&lt;p&gt;A quick-fix deletes an extention property.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val File.name: String
      get() = getName()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix adds the &lt;code&gt;@Deprecated&lt;/code&gt; annotation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Deprecated("Is replaced with automatic synthetic extension", ReplaceWith("name"), level = DeprecationLevel.HIDDEN)
  val File.name: String
      get() = getName()
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SelfAssignment" defaultSeverity="WARNING" displayName="Redundant assignment" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignments of a variable to itself.
&lt;p&gt;The quick-fix removes the redundant assignment.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      var bar = 1
      bar = bar
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      var bar = 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousVarProperty" defaultSeverity="WARNING" displayName="Suspicious 'var' property: its setter does not influence its getter result" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;var&lt;/code&gt; properties with default setter and getter that do not reference backing field.
&lt;p&gt;
Such properties do not affect calling its setter; therefore, it will be clearer to change such property to &lt;code&gt;val&lt;/code&gt; and delete the initializer.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Change to val and delete initializer&lt;/b&gt; quick-fix can be used to amend the code automatically.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // This property always returns '1' and it doesn't important that the property is a 'var'
  var foo: Int = 0
      get() = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedDataClassCopyResult" defaultSeverity="WARNING" displayName="Unused result of data class copy" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to data class &lt;code&gt;copy&lt;/code&gt; function without using its result.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnsafeCastFromDynamic" defaultSeverity="INFO" displayName="Implicit (unsafe) cast from dynamic type" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports expressions with a dynamic type in the specified inspection scope that are implicitly cast to another type.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ControlFlowWithEmptyBody" defaultSeverity="WARNING" displayName="Control flow with empty body" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt; statements with empty bodies.
&lt;p&gt;While occasionally intended, this construction is confusing and often the result of a typo.&lt;/p&gt;
&lt;p&gt;A quick-fix removes a statement.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (a &amp;gt; b) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CanSealedSubClassBeObject" defaultSeverity="WEAK WARNING" displayName="Sealed sub-class without state and overridden equals" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports direct inheritors of &lt;code&gt;sealed&lt;/code&gt; classes that have no state and overridden &lt;code&gt;equals()&lt;/code&gt; method.
&lt;p&gt;It's highly recommended to override &lt;code&gt;equals()&lt;/code&gt; to provide comparison stability, or convert the &lt;code&gt;class&lt;/code&gt; to an &lt;code&gt;object&lt;/code&gt; to reach the same effect.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class Receiver {
      class Everyone : Receiver()
      class User(val id: Int) : Receiver()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix converts a &lt;code&gt;class&lt;/code&gt; into an &lt;code&gt;object&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  sealed class Receiver {
      object Everyone : Receiver()
      class User(val id: Int) : Receiver()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MainFunctionReturnUnit" defaultSeverity="WARNING" displayName="Entry point function should return Unit" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports entry point functions with an incorrect return type (should be &lt;code&gt;Unit&lt;/code&gt;).
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;code&gt;fun main() = "Hello world!"&lt;/code&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousCollectionReassignment" defaultSeverity="WARNING" displayName="Augmented assignment creates a new collection under the hood" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports augmented assignment (&lt;code&gt;+=&lt;/code&gt;) expressions on read-only &lt;code&gt;Collection&lt;/code&gt;.
&lt;p&gt;Augment assignment (&lt;code&gt;+=&lt;/code&gt;) expression on read-only &lt;code&gt;Collection&lt;/code&gt; doesn't modify the target collection,
    it creates a new one under the hood which can be misleading and lead to performance issues.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Change type to mutable&lt;/b&gt; quick-fix can be used to amend the code automatically.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      var list = listOf(0)
      list += 42 // new list is created, variable 'list' still contains only '0'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      val list = mutableListOf(0)
      list += 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinThrowableNotThrown" defaultSeverity="WARNING" displayName="Throwable not thrown" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instantiations of &lt;code&gt;Throwable&lt;/code&gt; or its subclasses, when the created &lt;code&gt;Throwable&lt;/code&gt;
is never actually thrown.
&lt;p&gt;The reported code indicates mistakes that are hard to catch in tests.&lt;/p&gt;
&lt;p&gt;
    Also, this inspection reports method calls that return instances of &lt;code&gt;Throwable&lt;/code&gt; or its subclasses,
    when the resulting &lt;code&gt;Throwable&lt;/code&gt; instance is not thrown.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(condition: Boolean) {
      if (!condition) /* throw is missing here */ IllegalArgumentException("condition is not met");
  }

  fun createError() = RuntimeException()

  fun foo() {
      /* throw is missing here */ createError()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RecursivePropertyAccessor" defaultSeverity="WARNING" displayName="Recursive property accessor" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
    Reports recursive property accessor calls which can end up with a &lt;code&gt;StackOverflowError&lt;/code&gt;.
    Such calls are usually confused with backing field access.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var counter: Int = 0
      set(value) {
          &lt;b&gt;counter&lt;/b&gt; = if (value &lt; 0) 0 else value
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  var counter: Int = 0
      set(value) {
          &lt;b&gt;field&lt;/b&gt; = if (value &lt; 0) 0 else value
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinConstantConditions" defaultSeverity="WARNING" displayName="Constant conditions" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-trivial conditions and values that are statically known to be always true, false, null or zero.
While sometimes intended, often this is a sign of logical error in the program. Additionally,
reports never reachable &lt;code&gt;when&lt;/code&gt; branches and some expressions that are statically known to fail always.
&lt;p&gt;Examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun process(x: Int?) {
  val isNull = x == null
  if (!isNull) {
    if (&lt;span style="background: yellow"&gt;x != null&lt;/span&gt;) {} // condition is always true
    require(&lt;span style="background: yellow"&gt;x!! &amp;lt; 0 &amp;&amp; x &amp;gt; 10&lt;/span&gt;) // condition is always false
  } else {
    println(x&lt;span style="background: yellow"&gt;!!&lt;/span&gt;) // !! operator will always fail
  }
}
fun process(v: Any) {
  when(v) {
    is CharSequence -&amp;gt; println(v &lt;span style="background: yellow"&gt;as&lt;/span&gt; Int) // cast will always fail
    &lt;span style="background: yellow"&gt;is String&lt;/span&gt; -&amp;gt; println(v) // branch is unreachable
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2021.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitNullableNothingType" defaultSeverity="WEAK WARNING" displayName="Implicit 'Nothing?' type" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports variables and functions with the implicit &lt;b&gt;Nothing?&lt;/b&gt; type.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() = null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix specifies the return type explicitly:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): Nothing? = null
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KDocUnresolvedReference" defaultSeverity="WARNING" displayName="Unresolved reference in KDoc" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unresolved references in KDoc comments.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   * [unresolvedLink]
   */
  fun foo() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix the problem make the link valid.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyRange" defaultSeverity="WARNING" displayName="Range with start greater than endInclusive is empty" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports ranges that are empty because the &lt;code&gt;start&lt;/code&gt; value is greater than the &lt;code&gt;endInclusive&lt;/code&gt; value.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val range = 2..1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix changes the &lt;code&gt;..&lt;/code&gt; operator to &lt;code&gt;downTo&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val range = 2 downTo 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SelfReferenceConstructorParameter" defaultSeverity="WARNING" displayName="Constructor can never be complete" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports constructors with a non-null self-reference parameter.
&lt;p&gt;Such constructors never instantiate a class.&lt;/p&gt;
&lt;p&gt;The quick-fix converts the parameter type to nullable.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SelfRef(val ref: SelfRef)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class SelfRef(val ref: SelfRef?)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinCatchMayIgnoreException" defaultSeverity="WARNING" displayName="'catch' block may ignore exception" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;catch&lt;/code&gt; blocks that are empty or may ignore an exception.
&lt;p&gt;While occasionally intended, empty &lt;code&gt;catch&lt;/code&gt; blocks may complicate debugging.
    Also, ignoring a &lt;code&gt;catch&lt;/code&gt; parameter might be wrong.&lt;/p&gt;

&lt;p&gt;
    The inspection won't report any &lt;code&gt;catch&lt;/code&gt; parameters named &lt;code&gt;ignore&lt;/code&gt;, &lt;code&gt;ignored&lt;/code&gt;, or &lt;code&gt;_&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
    You can use a quick-fix to change the exception name to &lt;code&gt;_&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    throwingMethod()
  } catch (ex: IOException) {

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  try {
    throwingMethod()
  } catch (_: IOException) {

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
Use the &lt;b&gt;Do not warn when 'catch' block contains a comment&lt;/b&gt; option to ignore &lt;code&gt;catch&lt;/code&gt; blocks with comments.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedUnaryOperator" defaultSeverity="WARNING" displayName="Unused unary operator" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unary operators for number types on unused expressions.
&lt;p&gt;Unary operators break previous expression if they are used without braces.
As a result, mathematical expressions spanning multi lines can be misleading.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val result = 1 + 2 * 3
                  + 3              // &amp;lt;== note that '+ 3' doesn't belong to the 'result' variable, it is unused
      println("Result = $result")  // The result is '7' and not '10' as it might be expected
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SetterBackingFieldAssignment" defaultSeverity="WARNING" displayName="Existing backing field without assignment" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports property setters that don't update the backing field.
&lt;p&gt;The quick-fix adds an assignment to the backing field.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
      var foo: Int = 1
          set(value) {
          }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
      var foo: Int = 1
          set(value) {
              field = value
          }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinCovariantEquals" defaultSeverity="WARNING" displayName="Covariant 'equals()'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;equals()&lt;/code&gt; that takes an argument type other than &lt;code&gt;Any?&lt;/code&gt;
if the class does not have another &lt;code&gt;equals()&lt;/code&gt; that takes &lt;code&gt;Any?&lt;/code&gt; as its argument type.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      fun equals(other: Foo?): Boolean {
          return true
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix the problem create &lt;code&gt;equals()&lt;/code&gt; method that takes an argument of type &lt;code&gt;Any?&lt;/code&gt;.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspendFunctionOnCoroutineScope" defaultSeverity="WARNING" displayName="Ambiguous coroutineContext due to CoroutineScope receiver of suspend function" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls and accesses of &lt;code&gt;CoroutineScope&lt;/code&gt; extensions or members inside suspend functions with &lt;code&gt;CoroutineScope&lt;/code&gt; receiver.
&lt;p&gt;When a function is &lt;code&gt;suspend&lt;/code&gt; and has &lt;code&gt;CoroutineScope&lt;/code&gt; receiver,
    it has ambiguous access to &lt;code&gt;CoroutineContext&lt;/code&gt; via &lt;code&gt;kotlin.coroutines.coroutineContext&lt;/code&gt; and via &lt;code&gt;CoroutineScope.coroutineContext&lt;/code&gt;,
    and two these contexts are different in general.&lt;/p&gt;
&lt;p&gt;
To improve this situation, one can wrap suspicious call inside &lt;code&gt;coroutineScope { ... }&lt;/code&gt; or
get rid of &lt;code&gt;CoroutineScope&lt;/code&gt; function receiver.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousEqualsCombination" defaultSeverity="WEAK WARNING" displayName="Suspicious combination of == and ===" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt; comparisons that are both used on the same variable within a single expression.
&lt;p&gt;Due to similarities &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt; could be mixed without notice, and
    it takes a close look to check that &lt;code&gt;==&lt;/code&gt; used instead of &lt;code&gt;===&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (type === FIELD || type == METHOD || type == ANNOTATION_METHOD || // Note that "==" is used incorrectly
      type === LAMBDA_EXPRESSION) return
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DeferredResultUnused" defaultSeverity="WARNING" displayName="'@Deferred' result is unused" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports function calls with the &lt;code&gt;Deferred&lt;/code&gt; result type if the return value is not used.
&lt;p&gt;If the &lt;code&gt;Deferred&lt;/code&gt; return value is not used, the call site would not wait to complete this function.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun calcEverythingAsync() = CompletableDeferred(42)

  fun usage() {
      calcEverythingAsync()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix provides a variable with the &lt;code&gt;Deferred&lt;/code&gt; initializer:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun calcEverythingAsync() = CompletableDeferred(42)

  fun usage() {
      val answer = calcEverythingAsync()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedLambdaExpressionBody" defaultSeverity="WARNING" displayName="Unused return value of a function with lambda expression body" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls with an unused return value when the called function returns a lambda from an expression body.
&lt;p&gt;
If there is &lt;code&gt;=&lt;/code&gt; between function header and body block,
code from the function will not be evaluated which can lead to incorrect behavior.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Remove = token from function declaration&lt;/b&gt; can be used to amend the code automatically.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun printHello() = { println("Hello") }

  fun main() {
      printHello() // This function doesn't print anything
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun printHello() { println("Hello") }

  fun main() {
      printHello()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IncompleteDestructuring" defaultSeverity="WARNING" displayName="Incomplete destructuring declaration" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports incomplete destructuring declaration.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Person(val name: String, val age: Int)
  val person = Person("", 0)
  val (name) = person
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix completes destructuring declaration with new variables:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Person(val name: String, val age: Int)
  val person = Person("", 0)
  val (name, age) = person
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinEqualsBetweenInconvertibleTypes" defaultSeverity="WARNING" displayName="'equals()' between objects of inconvertible types" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;equals()&lt;/code&gt; where the receiver and the argument are
of incompatible primitive, enum, or string types.

&lt;p&gt;While such a call might theoretically be useful, most likely it represents a bug.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  5.equals("");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WrapUnaryOperator" defaultSeverity="WEAK WARNING" displayName="Ambiguous unary operator use with number constant" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an unary operator followed by a dot qualifier such as &lt;code&gt;-1.inc()&lt;/code&gt;.
&lt;p&gt;Code like &lt;code&gt;-1.inc()&lt;/code&gt; can be misleading because &lt;code&gt;-&lt;/code&gt; has a lower precedence than &lt;code&gt;.inc()&lt;/code&gt;.
    As a result, &lt;code&gt;-1.inc()&lt;/code&gt; evaluates to &lt;code&gt;-2&lt;/code&gt; and not &lt;code&gt;0&lt;/code&gt; as it might be expected.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Wrap unary operator and value with ()&lt;/b&gt; quick-fix can be used to amend the code automatically.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DataClassPrivateConstructor" defaultSeverity="WARNING" displayName="Private data class constructor is exposed via the 'copy' method" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the &lt;code&gt;private&lt;/code&gt; primary constructor in data classes.
&lt;p&gt;
    &lt;code&gt;data&lt;/code&gt; classes have a &lt;code&gt;copy()&lt;/code&gt; factory method that can be used similarly to a constructor.
    A constructor should not be marked as &lt;code&gt;private&lt;/code&gt; to provide enough safety.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class User private constructor(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix changes the constructor visibility modifier to &lt;code&gt;public&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class User(val name: String)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsOrHashCode" defaultSeverity="WARNING" displayName="'equals()' and 'hashCode()' not paired" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that override &lt;code&gt;equals()&lt;/code&gt; but do not override &lt;code&gt;hashCode()&lt;/code&gt;, or vice versa.
It also reports object declarations that override either &lt;code&gt;equals()&lt;/code&gt; or &lt;code&gt;hashCode()&lt;/code&gt;.
&lt;p&gt;This can lead to undesired behavior when a class is added to a &lt;code&gt;Collection&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C1 {
      override fun equals(other: Any?) = true
  }

  class C2 {
      override fun hashCode() = 0
  }

  object O1 {
      override fun equals(other: Any?) = true
  }

  object O2 {
      override fun hashCode() = 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix overrides &lt;code&gt;equals()&lt;/code&gt; or &lt;code&gt;hashCode()&lt;/code&gt; for classes and deletes these methods for objects:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
   class C1 {
       override fun equals(other: Any?) = true
       override fun hashCode(): Int {
           return javaClass.hashCode()
       }
   }

   class C2 {
       override fun hashCode() = 0
       override fun equals(other: Any?): Boolean {
           if (this === other) return true
           if (javaClass != other?.javaClass) return false
           return true
       }
   }

   object O1 {
   }

   object O2 {
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DestructuringWrongName" defaultSeverity="WARNING" displayName="Variable in destructuring declaration uses name of a wrong data class property" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports entries of destructuring declarations that match the name of a different property of the destructured data class.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Foo(val a: String, val b: Int, val c: String)

  fun bar(f: Foo) {
      val (a, c) = f
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix changes variable's name to match the name of the corresponding class field:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Foo(val a: String, val b: Int, val c: String)

  fun bar(f: Foo) {
      val (a, b) = f
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedEquals" defaultSeverity="WARNING" displayName="Unused equals expression" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unused &lt;code&gt;equals&lt;/code&gt;(&lt;code&gt;==&lt;/code&gt;) expressions.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceArrayEqualityOpWithArraysEquals" defaultSeverity="WARNING" displayName="Arrays comparison via '==' and '!='" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt; operator for arrays that should be replaced with &lt;code&gt;contentEquals()&lt;/code&gt;.
&lt;p&gt;
    The &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;operators compare array references instead of their content.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test() {
      val a = arrayOf(1, 2, 3)
      val b = arrayOf(1, 2, 3)
      println(a == b) // references comparison
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun test() {
      val a = arrayOf(1, 2, 3)
      val b = arrayOf(1, 2, 3)
      println(a.contentEquals(b))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DelegationToVarProperty" defaultSeverity="WARNING" displayName="Delegating to 'var' property" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports interface delegation to a &lt;code&gt;var&lt;/code&gt; property.
&lt;p&gt;Only initial value of a property is used for delegation, any later assignments do not affect it.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example(var text: CharSequence): CharSequence by text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix replaces a property with immutable one:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example(val text: CharSequence): CharSequence by text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternative way, if you rely on mutability for some reason:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Example(text: CharSequence): CharSequence by text {
      var text = text
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RecursiveEqualsCall" defaultSeverity="WARNING" displayName="Recursive equals call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports recursive &lt;code&gt;equals&lt;/code&gt;(&lt;code&gt;==&lt;/code&gt;) calls.&lt;/p&gt;
&lt;p&gt;
    In Kotlin, &lt;code&gt;==&lt;/code&gt; compares object values by calling &lt;code&gt;equals&lt;/code&gt; method under the hood.
    &lt;code&gt;===&lt;/code&gt;, on the other hand, compares objects by reference.
&lt;/p&gt;
&lt;p&gt;
    &lt;code&gt;===&lt;/code&gt; is commonly used in &lt;code&gt;equals&lt;/code&gt; method implementation.
    But &lt;code&gt;===&lt;/code&gt; may be mistakenly mixed up with &lt;code&gt;==&lt;/code&gt; leading to infinite recursion.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
      override fun equals(other: Any?): Boolean {
          if (&lt;b&gt;this == other&lt;/b&gt;) return true
          return false
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class X {
      override fun equals(other: Any?): Boolean {
          if (&lt;b&gt;this === other&lt;/b&gt;) return true
          return false
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UselessCallOnCollection" defaultSeverity="WARNING" displayName="Useless call on collection type" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;filter&lt;/code&gt; calls from the standard library on already filtered collections.
&lt;p&gt;Several functions from the standard library such as &lt;code&gt;filterNotNull()&lt;/code&gt; or &lt;code&gt;filterIsInstance&lt;/code&gt;
    have sense only when they are called on receivers that have types distinct from the resulting one. Otherwise,
    such calls can be omitted as the result will be the same.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Remove redundant call&lt;/b&gt; quick-fix can be used to amend the code automatically.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(list: List&amp;lt;String&amp;gt;) {
      val x = list.filterNotNull() // quick-fix simplifies to 'list'
      val y = list.filterIsInstance&amp;lt;String&amp;gt;() // quick-fix simplifies to 'list'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LeakingThis" defaultSeverity="WARNING" displayName="Leaking 'this' in constructor" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unsafe operations with &lt;code&gt;this&lt;/code&gt; during object construction including:

&lt;ul&gt;
  &lt;li&gt;Accessing a non-final property during class initialization: from a constructor or property initialization&lt;/li&gt;
  &lt;li&gt;Calling a non-final function during class initialization&lt;/li&gt;
  &lt;li&gt;Using &lt;code&gt;this&lt;/code&gt; as a function argument in a constructor of a non-final class&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
    If other classes inherit from the given class,
    they may not be fully initialized at the moment when an unsafe operation is carried out.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;abstract class&lt;/b&gt; Base {
      &lt;b&gt;val&lt;/b&gt; code = calculate()
      &lt;b&gt;abstract fun&lt;/b&gt; calculate(): Int
  }

  &lt;b&gt;class&lt;/b&gt; Derived(&lt;b&gt;private val&lt;/b&gt; x: Int) : Base() {
      &lt;b&gt;override fun&lt;/b&gt; calculate() = x
  }

  &lt;b&gt;fun&lt;/b&gt; testIt() {
      println(Derived(42).code) &lt;i&gt;// Expected: 42, actual: 0&lt;/i&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ForEachParameterNotUsed" defaultSeverity="WEAK WARNING" displayName="Iterated elements are not used in forEach" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;forEach&lt;/code&gt; loops that do not use iterable values.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  listOf(1, 2, 3).forEach { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix introduces anonymous parameter in the &lt;code&gt;forEach&lt;/code&gt; section:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  listOf(1, 2, 3).forEach { _ -&gt; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UselessCallOnNotNull" defaultSeverity="WARNING" displayName="Useless call on not-null type" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls on not-null receiver that make sense only for nullable receiver.
&lt;p&gt;Several functions from the standard library such as &lt;code&gt;orEmpty()&lt;/code&gt; or &lt;code&gt;isNullOrEmpty&lt;/code&gt;
    have sense only when they are called on receivers of nullable types. Otherwise, they can be omitted or simplified as the result will be the same.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Remove redundant call&lt;/b&gt; and &lt;b&gt;Change call to &lt;/b&gt;  quick-fixes can be used to amend the code automatically.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(s: String) {
      val x = s.orEmpty() // quick-fix simplifies to 's'
      val y = s.isNullOrEmpty() // quick-fix simplifies to 's.isEmpty()'
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LateinitVarOverridesLateinitVar" defaultSeverity="WARNING" displayName="'lateinit var' property overrides 'lateinit var' property" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;lateinit var&lt;/code&gt; properties that override other &lt;code&gt;lateinit var&lt;/code&gt; properties.
&lt;p&gt;A subclass instance will have two fields for a single property, and the one from the superclass will remain effectively unused.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    open class BaseClass {
      open lateinit var name: String
    }

    class RealClass : BaseClass() {
      override lateinit var name: String
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousCallableReferenceInLambda" defaultSeverity="WEAK WARNING" displayName="Suspicious callable reference used as lambda result" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports lambda expressions with one callable reference.
&lt;p&gt;It is a common error to replace a lambda with a callable reference without changing curly braces to parentheses.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  listOf(1,2,3).map { it::toString }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  listOf(1,2,3).map(Int::toString)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ArrayInDataClass" defaultSeverity="WEAK WARNING" displayName="Array property in data class" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports properties with an &lt;code&gt;Array&lt;/code&gt; type in a &lt;code&gt;data&lt;/code&gt; class without overridden &lt;code&gt;equals()&lt;/code&gt; or &lt;code&gt;hashCode()&lt;/code&gt;.
&lt;p&gt;
    Array parameters are compared by reference equality, which is likely an unexpected behavior.
    It is strongly recommended to override &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; in such cases.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Text(val lines: Array&amp;lt;String&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix generates missing &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; implementations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  data class Text(val lines: Array&amp;lt;String&amp;gt;) {
      override fun equals(other: Any?): Boolean {
          if (this === other) return true
          if (javaClass != other?.javaClass) return false

          other as Text

          if (!lines.contentEquals(other.lines)) return false

          return true
      }

      override fun hashCode(): Int {
          return lines.contentHashCode()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConvertNaNEquality" defaultSeverity="WARNING" displayName="Convert equality check with 'NaN' to 'isNaN' call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an equality check with &lt;code&gt;Float.NaN&lt;/code&gt; or &lt;code&gt;Double.NaN&lt;/code&gt; that should be replaced with an &lt;code&gt;isNaN()&lt;/code&gt; check.
&lt;p&gt;
    According to IEEE 754, equality check against NaN always returns &lt;code&gt;false&lt;/code&gt;, even for &lt;code&gt;NaN == NaN&lt;/code&gt;.
    Therefore, such a check is likely to be a mistake.
&lt;/p&gt;
&lt;p&gt;A quick-fix replaces comparison with &lt;code&gt;isNaN()&lt;/code&gt; check that uses a different comparison technique and handles &lt;code&gt;NaN&lt;/code&gt; values correctly.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(value: Double): Boolean {
      return Double.NaN == value
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun check(value: Double): Boolean {
      return value.isNaN()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Android Lint: Interoperability" path="Android/Lint/Interoperability"><inspection shortName="AndroidLintLambdaLast" defaultSeverity="WARNING" displayName="Lambda Parameters Last" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Lambda Parameters Last&lt;br&gt;&lt;br&gt;To improve calling this code from Kotlin, parameter types eligible for SAM conversion should be last.&lt;br&gt;&lt;br&gt;Issue id: LambdaLast&lt;br&gt;&lt;br&gt;&lt;a href="https://android.github.io/kotlin-guides/interop.html#lambda-parameters-last"&gt;https://android.github.io/kotlin-guides/interop.html#lambda-parameters-last&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintNoHardKeywords" defaultSeverity="WARNING" displayName="No Hard Kotlin Keywords" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;No Hard Kotlin Keywords&lt;br&gt;&lt;br&gt;Do not use Kotlin&amp;#8217;s hard keywords as the name of methods or fields. These require the use of backticks to escape when calling from Kotlin. Soft keywords, modifier keywords, and special identifiers are allowed.&lt;br/&gt;
&lt;br/&gt;
For example, ActionEvent's &lt;code&gt;getWhen()&lt;/code&gt; method requires backticks when used from Kotlin:
&lt;pre&gt;
val timestamp = event.`when`
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;Issue id: NoHardKeywords&lt;br&gt;&lt;br&gt;&lt;a href="https://android.github.io/kotlin-guides/interop.html#no-hard-keywords"&gt;https://android.github.io/kotlin-guides/interop.html#no-hard-keywords&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintKotlinPropertyAccess" defaultSeverity="WARNING" displayName="Kotlin Property Access" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Kotlin Property Access&lt;br&gt;&lt;br&gt;For a method to be represented as a property in Kotlin, strict &amp;#8220;bean&amp;#8221;-style prefixing must be used.&lt;br/&gt;
&lt;br/&gt;
Accessor methods require a &lt;code&gt;get&lt;/code&gt; prefix or for boolean-returning methods an &lt;code&gt;is&lt;/code&gt; prefix can be used.&lt;br&gt;&lt;br&gt;Issue id: KotlinPropertyAccess&lt;br&gt;&lt;br&gt;&lt;a href="https://android.github.io/kotlin-guides/interop.html#property-prefixes"&gt;https://android.github.io/kotlin-guides/interop.html#property-prefixes&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection><inspection shortName="AndroidLintUnknownNullness" defaultSeverity="WARNING" displayName="Unknown nullness" enabled="false" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Unknown nullness&lt;br&gt;&lt;br&gt;To improve referencing this code from Kotlin, consider adding explicit nullness information here with either &lt;code&gt;@NonNull&lt;/code&gt; or &lt;code&gt;@Nullable&lt;/code&gt;.&lt;br&gt;&lt;br&gt;Issue id: UnknownNullness&lt;br&gt;&lt;br&gt;Available options:&lt;br/&gt;
&lt;br/&gt;
&lt;b&gt;ignore-deprecated&lt;/b&gt; (default is false):&lt;br/&gt;
Whether to ignore classes and members that have been annotated with &lt;code&gt;@Deprecated&lt;/code&gt;.&lt;br/&gt;
&lt;br/&gt;
Normally this lint check will flag all unannotated elements, but by setting this option to &lt;code&gt;true&lt;/code&gt; it will skip any deprecated elements.&lt;br/&gt;
&lt;br/&gt;
To configure this option, use a &lt;code&gt;lint.xml&lt;/code&gt; file with an &amp;lt;option&gt; like this:&lt;br/&gt;

&lt;pre&gt;
&amp;lt;lint&gt;
    &amp;lt;issue id="UnknownNullness"&gt;
        &amp;lt;option name="ignore-deprecated" value="false" /&gt;
    &amp;lt;/issue&gt;
&amp;lt;/lint&gt;
&lt;/pre&gt;
&lt;br&gt;&lt;br&gt;&lt;a href="https://developer.android.com/kotlin/interop#nullability_annotations"&gt;https://developer.android.com/kotlin/interop#nullability_annotations&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</inspection></group><group name="Android &gt; JNI" path="Android"><inspection shortName="KotlinInternalExternalFunction" defaultSeverity="ERROR" displayName="Check internal external function in Kotlin" enabled="true" language="kotlin" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!--
  ~ Copyright (C) 2020 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
Reports Kotlin external function with internal visibility.

Kotlin compiler mangles the name of an internal function with the build variant, which could cause UnsatisfiedLinkError at runtime depending on the build variant.

The inspection offers a quick fix to create a private external function and delegate the internal function to it.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JniFindClass" defaultSeverity="WARNING" displayName="Inspect JNI FindClass calls" enabled="true" language="ObjectiveC" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports errors in calls to JNI &lt;tt&gt;FindClass&lt;/tt&gt; function.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JniGetField" defaultSeverity="WARNING" displayName="Inspect JNI GetObjectField calls and its variants" enabled="true" language="ObjectiveC" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports errors in calls to JNI &lt;tt&gt;Get&amp;lt;Type&amp;gt;Field&lt;/tt&gt; function.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JniOnload" defaultSeverity="WARNING" displayName="Inspect JNI_Onload And JNI_OnUnload" enabled="true" language="ObjectiveC" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
The signature of &lt;tt&gt;JNI_OnLoad&lt;/tt&gt; or &lt;tt&gt;JNI_OnUnload&lt;/tt&gt; is incorrect.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JniFunctionCorrectness" defaultSeverity="ERROR" displayName="Incorrect JNI Function" enabled="true" language="ObjectiveC" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;!--
  ~ Copyright (C) 2018 The Android Open Source Project
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  --&gt;
&lt;html&gt;
&lt;body&gt;
To make sure the C++ compiler uses unmodified names when calling functions in your C code, list your C functions in your C++ code using
&lt;tt&gt;extern "C"&lt;/tt&gt;.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JavaJniMissingFunction" defaultSeverity="ERROR" displayName="Missing JNI function in Java" enabled="true" language="JAVA" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports native method declarations in Java where no corresponding
JNI function is found in the project.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JniGetFieldID" defaultSeverity="WARNING" displayName="Inspect JNI GetFieldID calls" enabled="true" language="ObjectiveC" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports errors in calls to JNI &lt;tt&gt;GetFieldID&lt;/tt&gt; and &lt;tt&gt;GetStaticFieldID&lt;/tt&gt; functions.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JniGetMethod" defaultSeverity="WARNING" displayName="Inspect JNI GetMethodID calls" enabled="true" language="ObjectiveC" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports errors in calls to JNI &lt;tt&gt;GetMethodID&lt;/tt&gt; and &lt;tt&gt;GetStaticMethodID&lt;/tt&gt; functions.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JniNewObject" defaultSeverity="WARNING" displayName="Inspect JNI NewObject calls and its variants" enabled="true" language="ObjectiveC" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports errors in calls to JNI &lt;tt&gt;NewObject&lt;/tt&gt; function.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JniCallMethod" defaultSeverity="WARNING" displayName="Inspect JNI CallObjectMethod calls and its variants" enabled="true" language="ObjectiveC" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports errors in calls to JNI &lt;tt&gt;Call&amp;lt;Type&amp;gt;MethodID&lt;/tt&gt; and &lt;tt&gt;CallStatic&amp;lt;Type&amp;gt;MethodID&lt;/tt&gt; functions.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinJniMissingFunction" defaultSeverity="ERROR" displayName="Missing JNI function in Kotlin" enabled="true" language="kotlin" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports native method declarations in Kotlin where no corresponding
JNI function is found in the project.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JniSetField" defaultSeverity="WARNING" displayName="Inspect JNI SetObjectField calls and its variants" enabled="true" language="ObjectiveC" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports errors in calls to JNI &lt;tt&gt;Get&amp;lt;Type&amp;gt;Field&lt;/tt&gt; function.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JniParameters" defaultSeverity="WARNING" displayName="Inspect JNI Function Signatures" enabled="true" language="ObjectiveC" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
The parameter types or return type does not match the native declaration in Java or Kotlin code.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JniRegisterNatives" defaultSeverity="WARNING" displayName="Inspect JNI RegisterNatives calls" enabled="true" language="ObjectiveC" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports errors in calls to JNI &lt;tt&gt;RegisterNatives&lt;/tt&gt; function.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="JniCallNonvirtualMethod" defaultSeverity="WARNING" displayName="Inspect JNI CallNonvirtualObjectMethod calls and its variants" enabled="true" language="ObjectiveC" pluginId="com.android.tools.ndk" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports errors in calls to JNI &lt;tt&gt;CallNonvirtual&amp;lt;Type&amp;gt;Method&lt;/tt&gt; function.
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="RegExp" path=""><inspection shortName="RegExpDuplicateAlternationBranch" defaultSeverity="WARNING" displayName="Duplicate branch in alternation" enabled="true" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports duplicate branches in a RegExp alternation.
Duplicate branches slow down matching and obscure the intent of the expression.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (alpha|bravo|charlie|alpha)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (alpha|bravo|charlie)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.1&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpSimplifiable" defaultSeverity="WEAK WARNING" displayName="Regular expression can be simplified" enabled="true" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports regular expressions that can be simplified.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [a] [0-9] xx* [ah-hz]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a \d x+ [ahz]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2022.1&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpEmptyAlternationBranch" defaultSeverity="WARNING" displayName="Empty branch in alternation" enabled="true" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports empty branches in a RegExp alternation.
An empty branch will only match the empty string, and in most cases that is not what is desired.
This inspection will not report a single empty branch at the start or the end of an alternation.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (alpha||bravo)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (alpha|bravo)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpSingleCharAlternation" defaultSeverity="WARNING" displayName="Single character alternation" enabled="true" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports single char alternation in a RegExp.
It is simpler to use a character class instead.
This may also provide better matching performance.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a|b|c|d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [abcd]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;small&gt;New in 2017.1&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpAnonymousGroup" defaultSeverity="WARNING" displayName="Anonymous capturing group or numeric back reference" enabled="false" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports anonymous capturing groups and numeric back references in a RegExp.
These are only reported when the RegExp dialect supports named group and named group references.
Named groups and named back references improve code readability and are recommended to use instead.
When a capture is not needed, matching can be more performant and use less memory by using a non-capturing group,
i.e. &lt;code&gt;(?:xxx)&lt;/code&gt; instead of &lt;code&gt;(xxx)&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (\d\d\d\d)\1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A better regex pattern could look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (?&amp;lt;quad&gt;\d\d\d\d)\k&amp;lt;quad&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpUnexpectedAnchor" defaultSeverity="WARNING" displayName="Begin or end anchor in unexpected position" enabled="true" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;\A&lt;/code&gt; anchors not at the beginning of the pattern and
&lt;code&gt;$&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt; or &lt;code&gt;\z&lt;/code&gt; anchors not at the end of the pattern.
In the wrong position these RegExp anchors prevent the pattern from matching anything.
In case of the &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; anchors, most likely the literal character was meant and the escape forgotten.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (Price $10)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;small&gt;New in 2018.1&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpRedundantNestedCharacterClass" defaultSeverity="WARNING" displayName="Redundant nested character class" enabled="true" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary nested character classes.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [a-c[x-z]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [a-cx-z]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2020.2&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpSuspiciousBackref" defaultSeverity="WARNING" displayName="Suspicious back reference" enabled="true" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports back references that will not be resolvable at runtime.
This means that the back reference can never match anything.
A back reference will not be resolvable when the group is defined after the back reference,
or if the group is defined in a different branch of an alternation.
&lt;p&gt;&lt;b&gt;Example of a group defined after its back reference:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \1(abc)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;Example of a group and a back reference in different branches:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  a(b)c|(xy)\1z
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2022.1&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpRepeatedSpace" defaultSeverity="WARNING" displayName="Consecutive spaces" enabled="true" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports multiple consecutive spaces in a RegExp.
Because spaces are not visible by default, it can be hard to see how many spaces are required.
The RegExp can be made more clear by replacing the consecutive spaces with a single space and a counted quantifier.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  (     )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ( {5})
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;small&gt;New in 2017.1&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpDuplicateCharacterInClass" defaultSeverity="WARNING" displayName="Duplicate character in character class" enabled="true" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports duplicate characters inside a RegExp character class.
Duplicate characters are unnecessary and can be removed without changing the semantics of the regex.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [aabc]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  [abc]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpOctalEscape" defaultSeverity="INFORMATION" displayName="Octal escape" enabled="true" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports octal escapes, which are easily confused with back references.
Use hexadecimal escapes to avoid confusion.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \07
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \x07
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.1&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpEscapedMetaCharacter" defaultSeverity="INFORMATION" displayName="Escaped meta character" enabled="true" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports escaped meta characters.
Some RegExp coding styles specify that meta characters should be placed inside a character class,
to make the regular expression easier to understand.
This inspection does not warn about the meta character &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;,
because those would need additional escaping inside a character class.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \d+\.\d+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \d+[.]\d+
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.1&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpRedundantEscape" defaultSeverity="WARNING" displayName="Redundant character escape" enabled="true" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant character escape sequences that can be replaced with unescaped characters preserving the meaning.
Many escape sequences that are redundant inside square brackets &lt;code&gt;[]&lt;/code&gt; of a character class are necessary outside of a character class.
&lt;p&gt;
  Although unescaped opening curly braces &lt;code&gt;{&lt;/code&gt; outside of character classes are allowed in some dialects (JavaScript, Python, and so on),
  it can cause confusion and make the pattern less portable, because there are dialects that require escaping curly braces as characters.
  For this reason the inspection does not report escaped opening curly braces.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  \-\;[\.]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  -;[.]
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
The &lt;b&gt;Ignore escaped closing brackets '}' and ']'&lt;/b&gt; option specifies whether to report &lt;code&gt;\}&lt;/code&gt; and &lt;code&gt;\]&lt;/code&gt; outside of a character class
when they are allowed to be unescaped by the RegExp dialect.
&lt;p&gt;&lt;small&gt;New in 2017.3&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RegExpUnnecessaryNonCapturingGroup" defaultSeverity="WARNING" displayName="Unnecessary non-capturing group" enabled="true" language="RegExp" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary non-capturing groups, which have no influence on the match result.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Everybody be cool, (?:this) is a robbery!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Everybody be cool, this is a robbery!
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2021.1&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Visibility" path="Java"><inspection shortName="TypeParameterHidesVisibleType" defaultSeverity="WARNING" displayName="Type parameter hides visible type" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports type parameters that have the same names as the visible types in the current scope. Such parameter names may be confusing.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  abstract class MyList&amp;lt;T&amp;gt; extends AbstractList&amp;lt;T&amp;gt; {
    private List&amp;lt;T&amp;gt; elements;
    // type parameter 'T' hides type parameter 'T'
    public &amp;lt;T&amp;gt; T[] toArray(T[] array) {
        return elements.toArray(array);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AmbiguousMethodCall" defaultSeverity="WARNING" displayName="Call to inherited method looks like call to local method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to a superclass method from an anonymous, inner or local class,
if a method with the same signature exists in the code surrounding the class.
In this case it may seem that a method from the surrounding code is called,
when in fact it is a call to a method from the superclass.
&lt;p&gt;
  To clarify the intent of the code, it is recommended to add an explicit
  &lt;code&gt;super&lt;/code&gt; qualifier to the method call.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    void ambiguous(){}
  }

  class Example {
    void ambiguous(){}

    class Inner extends Parent {
      void example(){
        ambiguous(); //warning
      }
    }
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    void ambiguous(){}
  }

  class Example {
    void ambiguous(){}

    class Inner extends Parent {
      void example(){
        super.ambiguous();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodOverridesStaticMethod" defaultSeverity="WARNING" displayName="Method tries to override 'static' method of superclass" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;static&lt;/code&gt; methods with a signature identical to a &lt;code&gt;static&lt;/code&gt; method of a superclass.
Such a method may look like an override when in fact it hides the method from the superclass because
&lt;code&gt;static&lt;/code&gt; methods in Java cannot be overridden.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    static void method(){}
  }

  class Example extends Parent {
    static void method(){} //warning
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodOverridesInaccessibleMethodOfSuper" defaultSeverity="WARNING" displayName="Method overrides inaccessible method of superclass" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods with the same signature as an inaccessible method of a superclass,
for example, a private method, or a package-private method of a superclass in another package.
&lt;p&gt;
  Such method names may be confusing because the method in the subclass may look like an override when in fact
  it hides the inaccessible method of the superclass.
  Moreover, if the visibility of the method in the superclass changes later,
  it may either silently change the semantics of the subclass or cause a compilation error.
&lt;/p&gt;
&lt;p&gt;A quick-fix is suggested to rename the method.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Super {
    private void test() {
    }
  }

  public class Sub extends Super {
    void test() { // making 'Super.test()' public causes a compilation error
                  // making 'Super.test()' package-private makes 'Sub.test()' an override
    }
  }&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AmbiguousFieldAccess" defaultSeverity="WARNING" displayName="Access to inherited field looks like access to element from surrounding code" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports access to a superclass field from an anonymous, inner or local class,
if a local variable, parameter, or field with the same name is available in the code surrounding the class.
In this case it may seem that an element from the surrounding code is accessed,
when in fact it is an access to a field from the superclass.
&lt;p&gt;
  To clarify the intent of the code, it is recommended to add an explicit
  &lt;code&gt;super&lt;/code&gt; qualifier to the field access.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    class First {
      protected String ambiguous;
    }
    class Second {
      void foo(String ambiguous) {
        new First() {
          {
            System.out.println(ambiguous); // the field is accessed, not the parameter
          }
        };
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    class First {
      protected String ambiguous;
    }
    class Second {
      void foo(String ambiguous) {
        new First() {
          {
            System.out.println(super.ambiguous);
          }
        };
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InnerClassVariableHidesOuterClassVariable" defaultSeverity="WARNING" displayName="Inner class field hides outer class field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports inner class fields named identically to a field of a surrounding class.
As a result of such naming, you may accidentally use the field from the inner class
when using the identically named field of a surrounding class is intended.
&lt;p&gt;A quick-fix is suggested to rename the inner class field.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Outer {
    private String name;

    class Inner {
      private String name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to choose whether this inspection should report all name clashes,
  or only clashes with fields that are visible from the inner class.
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassEscapesItsScope" defaultSeverity="WARNING" displayName="Non-accessible 'class' is exposed" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of classes in a field or method signature when a class in a signature is less visible than the member itself.
While legal Java, such members are useless outside of the visibility scope.
&lt;p&gt;Example:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;public&lt;/code&gt; method which returns a &lt;code&gt;private&lt;/code&gt; inner &lt;code&gt;class&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;protected&lt;/code&gt; field whose type is a package-local &lt;code&gt;class&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
In Java 9, a module may hide some of its classes by excluding their packages from export.
So, if the signature of exported API contains a non-exported class, such an API is useless outside of the module.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Module's API exposes not exported classes (Java 9+)&lt;/b&gt; option to report about the module API
    that exposes unexported classes.&lt;br&gt;Note that the option works if the language level of the project or module is 9 or higher.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Public API exposes non-accessible classes&lt;/b&gt; option to report about a public API
    that exposes non-accessible classes.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Package-local API exposes private classes&lt;/b&gt; option to report about package-local API
    that exposes &lt;code&gt;private&lt;/code&gt; classes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="FieldHidesSuperclassField" defaultSeverity="WARNING" displayName="Subclass field hides superclass field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields in a derived class that are named identically a field of a superclass.
Java fields cannot be overridden in derived classes,
so the field in the derived class will hide the field from the superclass.
&lt;p&gt;
  As a result of such naming, you may accidentally use the field of the derived class
  where the identically named field of a base class is intended.
&lt;/p&gt;
&lt;p&gt;A quick-fix is suggested to rename the field in the derived class.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Parent {
  Parent parent;
}
class Child extends Parent {
  Child parent;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  You can configure the following options for this inspection:
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;strong&gt;Ignore non-accessible fields&lt;/strong&gt; - indicates whether this inspection should report all name clashes,
    or only clashes with fields which are visible from the subclass.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;Ignore static fields hiding static fields&lt;/strong&gt; - ignore &lt;code&gt;static&lt;/code&gt; fields
    which hide &lt;code&gt;static&lt;/code&gt; fields in base classes.
  &lt;/li&gt;
&lt;/ol&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicConstructorInNonPublicClass" defaultSeverity="WARNING" displayName="'public' constructor in non-public class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports all &lt;code&gt;public&lt;/code&gt; constructors in non-&lt;code&gt;public&lt;/code&gt; classes.
&lt;p&gt;Usually, there is no reason for creating a &lt;code&gt;public&lt;/code&gt; constructor in a class with a lower access level.
  Please note, however, that this inspection changes the behavior of some reflection calls. In particular,
  &lt;code&gt;Class.getConstructor()&lt;/code&gt; won't be able to find the updated constructor
  (&lt;code&gt;Class.getDeclaredConstructor()&lt;/code&gt; should be used instead). Do not use the inspection if your code
  or code of some used frameworks relies on constructor accessibility via &lt;code&gt;getConstructor()&lt;/code&gt;.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java9ModuleExportsPackageToItself" defaultSeverity="WARNING" displayName="Module exports/opens package to itself" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports packages that are exported to, or opened in the same Java 9 module in which they are defined.
The quick-fix removes such directives from &lt;code&gt;module-info.java&lt;/code&gt;.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  module com.mycomp {
    exports com.mycomp.main to com.mycomp;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  module main {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 9 or higher.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MethodOverloadsParentMethod" defaultSeverity="WARNING" displayName="Possibly unintended overload of method from superclass" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instance methods with the same name and the same number of parameters as a method in a superclass,
but where at least one of the parameters is of a different incompatible type.
&lt;p&gt;
  In this case, the method in a subclass will be overloading the method from the superclass
  instead of overriding it. If it is unintended, it may result in latent bugs.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {
    void foo(int x) {}
  }

  public class Bar extends Foo {
    void foo(Number x) {} // Method 'foo()' overloads a compatible method of a superclass,
                          // when overriding might have been intended
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to choose whether the inspection should also report cases where parameter types are not compatible.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AnonymousClassVariableHidesContainingMethodVariable" defaultSeverity="WARNING" displayName="Anonymous class variable hides variable in containing method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields in an anonymous class that are named identically to local variables or parameters of
the containing method or lambda expression.
&lt;p&gt;
  As a result of such naming, you may accidentally use the anonymous class field where
  the identically named variable or parameter from the containing method is intended.
&lt;/p&gt;
&lt;p&gt;A quick-fix is suggested to rename the field.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    public Test(String value) {
      Object foo = new Object() {
        private String value = "TEST";
        public void foo() {
          System.out.println(value); //the field is accessed, not the parameter
        }
      };
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LocalVariableHidingMemberVariable" defaultSeverity="WARNING" displayName="Local variable hides field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local variables named identically a field of a surrounding class.
As a result of such naming, you may accidentally use the variable where the identically named field is intended.
&lt;p&gt;A quick-fix is suggested to rename the variable.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Foo {
    public Object foo;

    void bar() {
      Object o = new Object() {
        void baz() {
          Object foo; // Local variable 'foo' hides field in class 'Foo'
        }
      };
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  You can configure the following options for this inspection:
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Ignore non-accessible fields&lt;/strong&gt; - ignore local variables named identically to superclass fields
    that are not visible (for example, because they are private).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ignore local variables in a static context hiding non-static fields&lt;/strong&gt; -
    for example when the local variable is inside a static method or inside a method which is inside a static inner class.
  &lt;/li&gt;
&lt;/ol&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="LambdaParameterHidingMemberVariable" defaultSeverity="WARNING" displayName="Lambda parameter hides field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports lambda parameters named identically to a field of a surrounding class.
As a result of such naming, you may accidentally use the lambda parameter when using the identically named field is intended.
&lt;p&gt;A quick-fix is suggested to rename the lambda parameter.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class MyClass {
    public Object foo;

    void sort(List&amp;lt;Integer&amp;gt; list) {
      list.sort((foo, bar) -&gt; foo - bar);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the option to choose whether to ignore fields that are not visible from the lambda expression.
  For example, private fields of a superclass.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ParameterHidingMemberVariable" defaultSeverity="WARNING" displayName="Parameter hides field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method parameters named identically to a field of a surrounding class.
As a result of such naming, you may accidentally use the parameter when using the identically named field is intended.
&lt;p&gt;A quick-fix is suggested to rename the parameter.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    private String value;

    public Main(String value) {
      value = value.toUpperCase();
    }
  }
  &lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  You can configure the following options for this inspection:
&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;strong&gt;Ignore for property setters&lt;/strong&gt; - ignore parameters of simple setters.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;Ignore superclass fields not visible from subclass&lt;/strong&gt; - ignore &lt;code&gt;private&lt;/code&gt;
    fields in a superclass, which are not visible from the method.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;Ignore for constructors&lt;/strong&gt; - ignore parameters of constructors.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;Ignore for abstract methods&lt;/strong&gt; - ignore parameters of abstract methods.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;Ignore for static method parameters hiding instance fields&lt;/strong&gt; - ignore parameters
    of &lt;code&gt;static&lt;/code&gt; methods hiding an instance field and to ignore parameters of instance methods in static inner
    classes hiding an instance field of an outer class. While not strictly hiding, such parameters can still be confusing.
  &lt;/li&gt;
&lt;/ol&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Java9UndeclaredServiceUsage" defaultSeverity="WARNING" displayName="Usage of service not declared in 'module-info'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports situations in which a service is loaded with &lt;code&gt;java.util.ServiceLoader&lt;/code&gt; but it isn't declared with the
&lt;code&gt;uses&lt;/code&gt; clause in the &lt;code&gt;module-info.java&lt;/code&gt; file and suggests inserting it.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Java 15" path="Java/Java language level migration aids"><inspection shortName="TextBlockBackwardMigration" defaultSeverity="INFORMATION" displayName="Text block can be replaced with regular string literal" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports text blocks that can be replaced with regular string literals.
&lt;p&gt;Occurrences of such text blocks may appear as results of migrating the code back to a Java version earlier than Java 15.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object obj = engine.eval("""
                           function hello() {
                             print('"Hello, world"');
                           }

                           hello();
                           """);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object obj = engine.eval("function hello() {\n" +
                           "  print('\"Hello, world\"');\n" +
                           "}\n" +
                           "\n" +
                           "hello();\n");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 15 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2019.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TextBlockMigration" defaultSeverity="WARNING" displayName="Text block can be used" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;String&lt;/code&gt; literals and suggests replacing them with text blocks.
&lt;p&gt;Requirements:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;\n&lt;/code&gt; occurs two or more times.&lt;/li&gt;
  &lt;li&gt;Text blocks are not concatenated.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
Use the &lt;b&gt;Apply to single string literals&lt;/b&gt; option to suggest the fix for single literals containing line breaks.
&lt;p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String html = "&amp;lt;html&amp;gt;\n" +
                "    &amp;lt;body&amp;gt;\n" +
                "        &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt;\n" +
                "    &amp;lt;/body&amp;gt;\n" +
                "&amp;lt;/html&amp;gt;\n";
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String html = """
                &amp;lt;html&amp;gt;
                    &amp;lt;body&amp;gt;
                        &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt;
                    &amp;lt;/body&amp;gt;
                &amp;lt;/html&amp;gt;
                """;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 15 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2019.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassCanBeRecord" defaultSeverity="WEAK WARNING" displayName="Class can be a record" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Suggests replacing classes with records.
&lt;p&gt;The inspection can be useful if you need to focus on modeling immutable data rather than extensible behavior.
  Automatic implementation of data-driven methods, such as equals and accessors, helps to get rid of boilerplate.&lt;/p&gt;
&lt;p&gt;
  Note that not every class can be a record. Here are some of the restrictions:
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A class must contain no inheritors and must be a top-level class.&lt;/li&gt;
  &lt;li&gt;All the non-static fields in class must be final.&lt;/li&gt;
  &lt;li&gt;Class must contain no instance initializers, generic constructors, nor native methods.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To get a full list of the restrictions, refer to the
  &lt;a href="https://docs.oracle.com/javase/specs/jls/se15/preview/specs/records-jls.html"&gt;Oracle documentation&lt;/a&gt;.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Point {
    private final double x;
    private final double y;

    Point(double x, double y) {
      this.x = x;
      this.y = y;
    }

    double getX() {
      return x;
    }

    double getY() {
      return y;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  record Point(int x, int y) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Enable the &lt;b&gt;Suggest renaming get/is-accessors&lt;/b&gt; option to allow renaming &lt;code&gt;getX()&lt;/code&gt;/&lt;code&gt;isX()&lt;/code&gt; accessors to &lt;code&gt;x()&lt;/code&gt; automatically.&lt;/p&gt;
&lt;p&gt;
  Use the &lt;b&gt;When conversion makes a member more accessible&lt;/b&gt; options to specify if the conversion may violate class encapsulation:
&lt;ul&gt;
  &lt;li&gt;Choose &lt;b&gt;Do not suggest conversion&lt;/b&gt; option to never violate class encapsulation&lt;/li&gt;
  &lt;li&gt;Choose &lt;b&gt;Show affected members in conflicts view&lt;/b&gt; option to apply conversion with notification about encapsulation violation issues&lt;/li&gt;
  &lt;li&gt;Choose &lt;b&gt;Convert silently&lt;/b&gt; option to apply conversion silently whether encapsulation violation issues exist or not&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Use the &lt;b&gt;Suppress conversion if class is annotated by&lt;/b&gt; list to exclude classes from conversion when annotated by annotations matching the specified patterns.
&lt;/p&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 16 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2020.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PatternVariableCanBeUsed" defaultSeverity="WARNING" displayName="Pattern variable can be used" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local variable declarations that can be replaced with pattern variables, which are usually more compact.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (obj instanceof String) {
    String str = (String) obj;
    System.out.println(str);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Can be replaced with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (obj instanceof String str) {
    System.out.println(str);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 16 or higher&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2020.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InconsistentTextBlockIndent" defaultSeverity="WARNING" displayName="Inconsistent whitespace indentation in text block" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports text blocks that are indented using both spaces and tabs.
&lt;p&gt;Such cases produce unexpected results since spaces and tabs are treated equally during text block processing.&lt;/p&gt;
&lt;p&gt;In the following example, spaces and tabs are visualized as &lt;code&gt;&lt;/code&gt; and &lt;code&gt;&lt;/code&gt; respectively, and a tab is equal to 4 spaces in the editor.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
String colors = """
red
      green
blue""";
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After printing such string, the result will be:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
red
green
blue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the compiler removes 2 spaces or tabs from the beginning of each line, the lines end up with extra whitespaces at the beginning.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the configured language level is 15 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2021.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TrailingWhitespacesInTextBlock" defaultSeverity="WARNING" displayName="Trailing whitespaces in text block" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports text blocks with trailing whitespaces.
&lt;p&gt;Trailing whitespaces are considered incidental and stripped away by the Java compiler.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 15 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2021.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Unused code" path="Objective-C"><inspection shortName="OCUnusedMethod" defaultSeverity="WARNING" displayName="Unused method" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the methods that are never called, for example, in send message expressions, &lt;code&gt;@selector&lt;/code&gt; expressions, and other places like XIB files.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedLocalization" defaultSeverity="WARNING" displayName="Unused localization" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the string localizations in the &lt;b&gt;.strings&lt;/b&gt; files that are never used.&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OCUnusedProperty" defaultSeverity="WARNING" displayName="Unused property" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the properties that are never accessed or written, neither in qualified expressions
nor in accessor method calls.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedImportStatement" defaultSeverity="WARNING" displayName="Unused import statement" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unused or not required imports that can be safely removed.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OCUnusedInstanceVariable" defaultSeverity="WARNING" displayName="Unused instance variable" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the instance variables that are never accessed or written.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OCUnusedClass" defaultSeverity="WARNING" displayName="Unused class" enabled="true" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports Objective-C classes and protocols that are never used.
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="JUnit" path=""><inspection shortName="Junit5MalformedParameterized" defaultSeverity="WARNING" displayName="Malformed parameterized tests" enabled="true" language="UAST" pluginId="JUnit" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports parameterized tests that have malformed sources:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;MethodSource&lt;/code&gt; has an unknown target or the method is not static, &lt;code&gt;no-arg&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ValueSource&lt;/code&gt; and &lt;code&gt;EnumSource&lt;/code&gt; types cannot be converted to method parameters.&lt;/li&gt;
  &lt;li&gt;No sources are defined.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    @MethodSource("parameters")
    @ParameterizedTest
    void foo(String param) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
    private static Stream&amp;lt;Arguments&amp;gt; parameters() {
        return Stream.empty();
    }

    @MethodSource("parameters")
    @ParameterizedTest
    void foo(String param) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="General" path=""><inspection shortName="RedundantSuppression" defaultSeverity="WARNING" displayName="Redundant suppression" enabled="true" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports usages of the following elements that can be safely removed because the inspection they affect is no longer applicable in this context:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;@SuppressWarning&lt;/code&gt; annotation, or&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;// noinspection&lt;/code&gt; line comment, or&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;/** noinspection */&lt;/code&gt; JavaDoc comment&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;b&gt;&lt;font color="#000080"&gt;public class&lt;/font&gt;&lt;/b&gt; C {
 // symbol is already private,
 // but annotation is still around
  @SuppressWarnings({"WeakerAccess"})
 &lt;b&gt;&lt;font color="#000080"&gt;private boolean&lt;/font&gt;&lt;/b&gt; CONST = &lt;b&gt;&lt;font color="#000080"&gt;true&lt;/font&gt;&lt;/b&gt;;
 &lt;b&gt;&lt;font color="#000080"&gt;void&lt;/font&gt;&lt;/b&gt; f() {
    CONST = &lt;b&gt;&lt;font color="#000080"&gt;false&lt;/font&gt;&lt;/b&gt;;
  }
}
&lt;/code&gt;&lt;/pre&gt;


&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SyntaxError" defaultSeverity="ERROR" displayName="Syntax error" enabled="true" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports syntax errors that have been found in the result of a batch code inspection run.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InjectedReferences" defaultSeverity="ERROR" displayName="Injected references" enabled="true" pluginId="org.intellij.intelliLang" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unresolved references injected by
&lt;a href="https://www.jetbrains.com/help/idea/using-language-injections.html"&gt;Language Injections&lt;/a&gt;.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;
    @Language("file-reference")
    String fileName = "/home/user/nonexistent.file"; // highlighted if file doesn't exist
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TodoComment" defaultSeverity="WARNING" displayName="TODO comment" enabled="false" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;b&gt;TODO&lt;/b&gt; comments in your code.
&lt;p&gt;You can configure the format for &lt;b&gt;TODO&lt;/b&gt; comments in &lt;a href="settings://preferences.toDoOptions"&gt;Settings | Editor | TODO&lt;/a&gt;.
Since syntax highlighting for &lt;b&gt;TODO&lt;/b&gt; comments is already provided,
this inspection is intended for use in batch mode or on a continuous integration server.&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProblematicWhitespace" defaultSeverity="WARNING" displayName="Problematic whitespace" enabled="false" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the following problems:
&lt;ul&gt;
  &lt;li&gt;Tabs used for indentation when the code style is configured to use only spaces.&lt;/li&gt;
  &lt;li&gt;Spaces used for indentation when the code style is configured to use only tabs.&lt;/li&gt;
  &lt;li&gt;Spaces used for indentation and tabs used for alignment when the code
    style is configured to use smart tabs.&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="DefaultFileTemplate" defaultSeverity="WARNING" displayName="Default File Template Usage" enabled="true" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of the default File Header template and suggests changing it.
The File Header template can be modified in
&lt;a href="settings://fileTemplates?Includes"&gt;Settings | Editor | File and Code Templates | Includes&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyDirectory" defaultSeverity="WARNING" displayName="Empty directory" enabled="false" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports empty directories.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Available only from &lt;b&gt;Code | Inspect Code&lt;/b&gt; or
  &lt;b&gt;Code | Analyze Code | Run Inspection by Name&lt;/b&gt; and isn't reported in the editor.&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Only report empty directories located under a source folder&lt;/b&gt; option to have only directories under source
  roots reported.&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IncorrectFormatting" defaultSeverity="WEAK WARNING" displayName="Incorrect formatting" enabled="false" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
  Reports formatting issues that appear if your code doesn't
  follow your project's code style settings.
&lt;/p&gt;
&lt;p&gt;
  This inspection is not compatible with languages that require
  third-party formatters for code formatting, for example, Go or
  C with CLangFormat enabled.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="LongLine" defaultSeverity="WARNING" displayName="Line is longer than allowed by code style" enabled="false" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports lines that are longer than the &lt;b&gt;Hard wrap at&lt;/b&gt; parameter specified in
&lt;a href="settings://preferences.sourceCode?Hard%20wrap%20at"&gt;Settings | Editor | Code Style | General&lt;/a&gt;.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Annotator" defaultSeverity="ERROR" displayName="Annotator" enabled="true" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="true">&lt;html&gt;
&lt;body&gt;
Reports problems that are found by language annotators in the result of a batch code inspection run.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InconsistentLineSeparators" defaultSeverity="WARNING" displayName="Inconsistent line separators" enabled="false" pluginId="com.intellij" pluginVersion="221.6008.13" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports files with line separators different from the ones that are specified in the project's settings.
&lt;p&gt;For example, the inspection will be triggered if you set the line separator to &lt;code&gt;\n&lt;/code&gt; in
  &lt;a href="settings://preferences.sourceCode?Line%20separator"&gt;Settings | Editor | Code Style | Line separator&lt;/a&gt;,
  while the file you are editing uses &lt;code&gt;\r\n&lt;/code&gt; as a line separator.&lt;/p&gt;

&lt;p&gt;The inspection also warns you about mixed line separators within a file.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Encapsulation" path="Java"><inspection shortName="PublicField" defaultSeverity="INFORMATION" displayName="'public' field" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;public&lt;/code&gt; fields.
Constants (fields marked with &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;final&lt;/code&gt;) are not reported.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public String name;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore If Annotated By&lt;/b&gt; list to specify annotations to ignore. The inspection will ignore fields with
    any of these annotations.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore 'public final' fields of an enum&lt;/b&gt; option to ignore &lt;code&gt;public final&lt;/code&gt; fields
    of the &lt;code&gt;enum&lt;/code&gt; type.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageVisibleInnerClass" defaultSeverity="WARNING" displayName="Package-visible nested class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports nested classes that are declared without any access modifier (also known as package-private).
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Outer {
    static class Nested {}  // warning
    class Inner {}          // warning
    enum Mode {}            // warning depends on the setting
    interface I {}          // warning depends on the setting
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore package-visible inner enums&lt;/b&gt; option to ignore package-private inner enums.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore package-visible inner interfaces&lt;/b&gt; option to ignore package-private inner interfaces.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PublicInnerClass" defaultSeverity="WARNING" displayName="'public' nested class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;public&lt;/code&gt; nested classes.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Outer {
    public static class Nested {} // warning
    public class Inner {}         // warning
    public enum Mode {}           // warning depends on the setting
    public interface I {}         // warning depends on the setting
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore 'public' inner enums&lt;/b&gt; option to ignore &lt;code&gt;public&lt;/code&gt; inner enums.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore 'public' inner interfaces&lt;/b&gt; option to ignore &lt;code&gt;public&lt;/code&gt; inner interfaces.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProtectedInnerClass" defaultSeverity="WARNING" displayName="Protected nested class" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;protected&lt;/code&gt; nested classes.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Outer {
    protected static class Nested {} // warning
    protected class Inner {}         // warning
    protected enum Mode {}           // warning depends on the setting
    protected interface I {}         // warning depends on the setting
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore 'protected' inner enums&lt;/b&gt; option to ignore &lt;code&gt;protected&lt;/code&gt; inner enums.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore 'protected' inner interfaces&lt;/b&gt; option to ignore &lt;code&gt;protected&lt;/code&gt; inner interfaces.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssignmentOrReturnOfFieldWithMutableType" defaultSeverity="WARNING" displayName="Assignment or return of field with mutable type" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports return of, or assignment from a method parameter to an array or a mutable type like
&lt;code&gt;Collection&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Calendar&lt;/code&gt;, etc.
&lt;p&gt;Because such types are mutable, this construct may
  result in unexpected modifications of an object's state from outside the owning class. Although this construct may be useful for
  performance reasons, it is inherently prone to bugs.&lt;/p&gt;
&lt;p&gt;The following mutable types are reported:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;java.util.Date&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Calendar&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Collection&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Map&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.common.collect.Multimap&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;com.google.common.collect.Table&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The quick-fix adds a call to the field's &lt;code&gt;.clone()&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Log {
    String[] messages;
    ...

    String[] getMessages() {
      return messages; // warning: Return of String[] field 'messages'
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Log {
    String[] messages;
    ...

    String[] getMessages() {
      return messages.clone();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the &lt;b&gt;Ignore assignments in and returns from private methods&lt;/b&gt; option to ignore assignments and returns in &lt;code&gt;private&lt;/code&gt; methods.

  &lt;!--&lt;p&gt;&lt;small&gt;New in 2017.3&lt;/small&gt;--&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ProtectedField" defaultSeverity="WARNING" displayName="Protected field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;protected&lt;/code&gt; fields.
&lt;p&gt;Constants (that is, variables marked &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;final&lt;/code&gt;) are not reported.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class A {
    protected Object object;              // warning
    protected final static int MODE = 0;  // constant, no warning
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PackageVisibleField" defaultSeverity="WARNING" displayName="Package-visible field" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports fields that are declared without any access modifier (also known as package-private).
&lt;p&gt;Constants (that is, fields marked &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;final&lt;/code&gt;) are not reported.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class A {
    Object object;             // warning
    final static int MODE = 0; // constant, no warning
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfAnotherObjectsPrivateField" defaultSeverity="WARNING" displayName="Accessing a non-public field of another object" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports accesses to &lt;code&gt;private&lt;/code&gt; or &lt;code&gt;protected&lt;/code&gt; fields of another object.
Java allows access to such fields for objects of the same class as the current object but
  some coding styles discourage this use. Additionally, such direct access to &lt;code&gt;private&lt;/code&gt; fields
  may fail in component-oriented architectures, such as Spring or Hibernate, that expect all access
  to other objects to be through method calls so the framework can mediate access
  using proxies.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Base {
    protected int bar;

    void increment(Base base) {
      bar++;
      base.bar++; // warning: direct access to another object's non-public field
    }
  }
&lt;/code&gt;&lt;/pre&gt;
A quick-fix to encapsulate the field is available.
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore accesses from the same class&lt;/b&gt; option to ignore access from the same class and only report access
    from inner or outer classes.
    &lt;p&gt;To ignore access from inner classes as well, use the nested &lt;b&gt;Ignore accesses from inner classes&lt;/b&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore accesses from 'equals()' method&lt;/b&gt; to ignore access from an &lt;code&gt;equals()&lt;/code&gt; method.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Other problems" path="Kotlin"><inspection shortName="FloatingPointLiteralPrecision" defaultSeverity="WEAK WARNING" displayName="Floating-point literal exceeds the available precision" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports floating-point literals that cannot be represented with the required precision
using &lt;a href="https://en.wikipedia.org/wiki/IEEE_754"&gt;IEEE 754&lt;/a&gt; &lt;code&gt;Float&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt; types.

&lt;p&gt;
    For example, &lt;code&gt;1.9999999999999999999&lt;/code&gt; has too many significant digits,
    so its representation as a &lt;code&gt;Double&lt;/code&gt; will be rounded to &lt;code&gt;2.0&lt;/code&gt;.
    Specifying excess digits may be misleading as it hides the fact that computations
    use rounded values instead.
&lt;/p&gt;

&lt;p&gt;
    The quick-fix replaces the literal with a rounded value that matches the actual representation
    of the constant.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x: Float = 3.14159265359f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val x: Float = 3.1415927f
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="PublicApiImplicitType" defaultSeverity="WEAK WARNING" displayName="Public API declaration with implicit return type" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;
    Reports &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; functions and properties that have an implicit return type.
    For API stability reasons, it's recommended to specify such types explicitly.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun publicFunctionWhichAbusesTypeInference() =
      otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun publicFunctionWhichAbusesTypeInference(): &lt;b&gt;Api&lt;/b&gt; =
      otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MigrateDiagnosticSuppression" defaultSeverity="WARNING" displayName="Diagnostic name should be replaced" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports suppressions with old diagnostic names, for example &lt;code&gt;@Suppress("HEADER_WITHOUT_IMPLEMENTATION")&lt;/code&gt;.
&lt;p&gt;
    Some of diagnostics from Kotlin 1.2 and earlier are now obsolete, making such suppressions redundant.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@Suppress("HEADER_DECLARATION_WITH_BODY")
expect fun connection() {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@Suppress("EXPECTED_DECLARATION_WITH_BODY")
expect fun connection() {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverridingDeprecatedMember" defaultSeverity="WARNING" displayName="Overriding deprecated member" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports declarations that inherit from deprecated members.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
open class BaseService {
  @Deprecated("obsolete", replaceWith = ReplaceWith("connection"))
  open fun connect() {}

  open fun connection() {}
} 

class SomeService: BaseService() {
  override fun connect() {
    super.connect()
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="DeprecatedCallableAddReplaceWith" defaultSeverity="INFO" displayName="@Deprecated annotation without 'replaceWith' argument" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports deprecated functions and properties that do not have the &lt;code&gt;kotlin.ReplaceWith&lt;/code&gt; argument in its
&lt;code&gt;kotlin.deprecated&lt;/code&gt; annotation and suggests to add one based on their body.
&lt;p&gt;
    Kotlin provides the &lt;code&gt;ReplaceWith&lt;/code&gt; argument to replace deprecated declarations automatically.
    It is recommended to use the argument to fix deprecation issues in code.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Deprecated("Use refined() instead.")
  fun deprecated() = refined()

  fun refined() = 42
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix adds the &lt;code&gt;ReplaceWith()&lt;/code&gt; argument:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @Deprecated("Use refined() instead.", ReplaceWith("refined()"))
  fun deprecated() = refined()

  fun refined() = 42
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReplaceWithEnumMap" defaultSeverity="WARNING" displayName="'HashMap' can be replaced with 'EnumMap'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;hashMapOf&lt;/code&gt; function or &lt;code&gt;HashMap&lt;/code&gt; constructor calls that can be replaced with an &lt;code&gt;EnumMap&lt;/code&gt; constructor call.
&lt;p&gt;Using &lt;code&gt;EnumMap&lt;/code&gt; constructor makes your code simpler.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the function call with the &lt;code&gt;EnumMap&lt;/code&gt; constructor call.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum class E {
      A, B
  }

  fun getMap(): Map&amp;lt;E, String&amp;gt; = hashMapOf()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum class E {
      A, B
  }

  fun getMap(): Map&amp;lt;E, String&amp;gt; = EnumMap(E::class.java)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConvertArgumentToSet" defaultSeverity="WEAK WARNING" displayName="Argument could be converted to 'Set' to improve performance" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Detects the function calls that could work faster with an argument converted to &lt;code&gt;Set&lt;/code&gt;.

&lt;p&gt;
    Operations like 'minus' or 'intersect' are more effective when their argument is a set.
    An explicit conversion of an &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; or an &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;
    into a &lt;code&gt;Set&amp;lt;T&amp;gt;&lt;/code&gt; can often make code more effective.
&lt;/p&gt;

&lt;p&gt;
    The quick-fix adds an explicit conversion to the function call.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun &amp;lt;T&amp;gt; f(a: Iterable&amp;lt;T&amp;gt;, b: Iterable&amp;lt;T&amp;gt;): Int =
      a.intersect(b).size
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun &amp;lt;T&amp;gt; f(a: Iterable&amp;lt;T&amp;gt;, b: Iterable&amp;lt;T&amp;gt;): Int =
      a.intersect(b.toSet()).size
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KDocMissingDocumentation" defaultSeverity="WARNING" displayName="Missing KDoc comments for public declarations" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports public declarations that do not have KDoc comments.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick fix generates the comment block above the declaration:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  /**
   *
   */
  class A
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="GPath" path="Groovy"><inspection shortName="GroovyListGetCanBeKeyedAccess" defaultSeverity="WARNING" displayName="Call to List.get can be keyed access" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.util.List.get()&lt;/code&gt; methods. Such calls could be replaced
by the shorter and clearer keyed access form.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
def str = list.get(0) // list.get(0) could be replaced with list[0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
def str = list[0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMapPutCanBeKeyedAccess" defaultSeverity="WARNING" displayName="Call to Map.put can be keyed access" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.util.Map.put()&lt;/code&gt; methods. Such calls could be replaced
by the shorter and clearer keyed access form.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = ["foo": "bar"]
map.put("foo", "baz") // map.put("foo", "baz") could be replaced with map["foo"] = "baz"
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = ["foo": "bar"]
map["foo"] = "baz"
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyListSetCanBeKeyedAccess" defaultSeverity="WARNING" displayName="Call to List.set can be keyed access" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.util.List.set()&lt;/code&gt; methods. Such calls could be replaced
by the shorter and clearer keyed access form.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
list.set(0, "bar") // list.set(0, "bar") could be replaced with list[0] = "bar"
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def list = ["foo"]
list[0] = "bar"
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="GroovyMapGetCanBeKeyedAccess" defaultSeverity="WARNING" displayName="Call to Map.get can be keyed access" enabled="false" language="Groovy" pluginId="org.intellij.groovy" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.util.Map.get()&lt;/code&gt; methods. Such calls could be replaced
by the shorter and clearer keyed access form.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = ["foo": "bar"]
def str = map.get("foo") // map.get("foo") could be replaced with map["foo"]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
def map = ["foo": "bar"]
def str = map["foo"]
&lt;/code&gt;
&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Probable bugs" path="Java"><inspection shortName="ResultOfObjectAllocationIgnored" defaultSeverity="WARNING" displayName="Result of object allocation ignored" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports object allocations where the allocated object is ignored and neither assigned to a variable nor used in another way.
&lt;p&gt;
  Such allocation expressions are legal in Java, but are usually either unintended, or
  evidence of a very odd object initialization strategy.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the options to list classes whose allocations should be ignored by this inspection.
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverflowingLoopIndex" defaultSeverity="WARNING" displayName="Loop executes zero or billions of times" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports loops that cannot be completed without an index overflow or loops that don't loop at all.
It usually happens because of a mistake in the update operation.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(int s) {
    for (int i = s; i &gt; 12; i++) { // i-- should be here
      System.out.println(i);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2019.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WrongPackageStatement" defaultSeverity="ERROR" displayName="Wrong package statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Detects &lt;code&gt;package&lt;/code&gt; statements that do not correspond to the project directory structure.
Also, reports classes without &lt;code&gt;package&lt;/code&gt; statements if the class is not located directly in
source root directory.
&lt;p&gt;While it's not strictly mandated by Java language, it's good to keep classes 
from package &lt;code&gt;com.example.myapp&lt;/code&gt; inside the &lt;code&gt;com/example/myapp&lt;/code&gt; directory under 
  the source root. Failure to do this may confuse code readers and make some tools working incorrectly.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MismatchedArrayReadWrite" defaultSeverity="WARNING" displayName="Mismatched read and write of array" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports arrays whose contents are read but not updated,
or updated but not read. Such inconsistent reads and writes are pointless and probably indicate
dead, incomplete or erroneous code.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  final int[] bar = new int[3];
  bar[2] = 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantConditions" defaultSeverity="WARNING" displayName="Constant conditions &amp; exceptions" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.
&lt;p&gt;Examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (array.length &amp;lt; index) {
  System.out.println(array[index]);
} // Array index is always out of bounds

if (str == null) System.out.println("str is null");
System.out.println(str.trim());
// the last statement may throw an NPE

@NotNull
Integer square(@Nullable Integer input) {
    // the method contract is violated
    return input == null ? null : input * input;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  The inspection behavior may be controlled by a number of annotations, such as 
  &lt;a href="https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html"&gt;nullability&lt;/a&gt; annotations,
  &lt;code&gt;&lt;a href="https://www.jetbrains.com/help/idea/contract-annotations.html"&gt;@Contract&lt;/a&gt;&lt;/code&gt; annotation, 
  &lt;code&gt;@Range&lt;/code&gt; annotation and so on.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Use the &lt;b&gt;Suggest @Nullable annotation for methods/fields/parameters where nullable values are used&lt;/b&gt; option to warn when a
    nullable value is passed as an argument to a method with a non-annotated parameter,
    stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating
    the &lt;code&gt;@Nullable&lt;/code&gt; annotation. You can also configure nullability annotations using the &lt;b&gt;Configure Annotations&lt;/b&gt; button.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Treat non-annotated members and parameters as @Nullable&lt;/b&gt; option to assume that non-annotated members can be null,
    so they must not be used in non-null context.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Report not-null required parameter with null-literal argument usages&lt;/b&gt; option to report method parameters that cannot be
    null (e.g. immediately dereferenced in the method body), but there are call sites where a &lt;code&gt;null&lt;/code&gt; literal is passed.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Report nullable methods that always return a non-null value&lt;/b&gt; option to report methods that are annotated as
  &lt;code&gt;@Nullable&lt;/code&gt;, but always return non-null value. In this case, it's suggested that you change the annotation to &lt;code&gt;@NotNull&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Don't report assertions with condition statically proven to be always true&lt;/b&gt; option to avoid reporting assertions that were
    statically proven to be always true. This also includes conditions like &lt;code&gt;if (alwaysFalseCondition) throw new IllegalArgumentException();&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Ignore assert statements&lt;/b&gt; option to control how the inspection treats &lt;code&gt;assert&lt;/code&gt; statements. By default, the option
    is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored
    (-da mode).&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Warn when reading a value guaranteed to be constant&lt;/b&gt; option to add warnings on reading variables that contain some constant values,
    for example: &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Use the &lt;b&gt;Report problems that happen only on some code paths&lt;/b&gt; option to control whether to report problems that may happen only
    on some code path. If this option is disabled, warnings like &lt;i&gt;exception is possible&lt;/i&gt; will not be reported. The inspection will report
    only warnings like &lt;i&gt;exception will definitely occur&lt;/i&gt;. This mode may greatly reduce the number of false-positives, especially if the code
    is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most
    important problems in legacy code bases.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousToArrayCall" defaultSeverity="WARNING" displayName="Suspicious 'Collection.toArray()' call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports suspicious calls to &lt;code&gt;Collection.toArray()&lt;/code&gt;.
&lt;p&gt;The following types of calls are considered suspicious:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    when the type of the array
    argument is not the same as the array type to which the result is casted.
  &lt;/li&gt;
  &lt;li&gt;
    when the type of the array argument does not match the type parameter in the collection declaration.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
void m1(List list) {
  Number[] ns = (Number[]) list.toArray(new String[0]);
}

void m2(List&amp;lt;Number&amp;gt; list) {
  Number[] ns = list.toArray(new String[0]);
}
&lt;/code&gt;&lt;/pre&gt;


&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="WriteOnlyObject" defaultSeverity="WARNING" displayName="Write-only object" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports objects that are modified but never queried.
&lt;p&gt;The inspection relies on the method mutation contract, which could be inferred
  or pre-annotated for some library methods. This inspection does not report collections, maps, and string builders, as these types
  are reported by other more precise inspections.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  AtomicReference&amp;lt;String&amp;gt; ref = new AtomicReference&amp;lt;&amp;gt;();
  ref.set("hello"); // ref is never used again
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignore impure constructors&lt;/b&gt; option to control whether to process objects created by constructor or method whose purity is not known.
  Unchecking the option may introduce some false-positives if the object reference is intentionally leaked during the construction.
&lt;/p&gt;
&lt;b&gt;&lt;small&gt;New in 2021.2&lt;/small&gt;&lt;/b&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CopyConstructorMissesField" defaultSeverity="WARNING" displayName="Copy constructor misses field" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports copy constructors that don't copy all the fields of the class.
&lt;p&gt;
  &lt;code&gt;final&lt;/code&gt; fields with initializers and &lt;code&gt;transient&lt;/code&gt; fields are considered unnecessary to copy.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Point {

    private int x;
    private int y;

    Point(int x, int y) {
      this.x = x;
      this.y = y;
    }

    Point(Point other) {
      // fields x and y are not initialized
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.1&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MagicConstant" defaultSeverity="WARNING" displayName="Magic Constant" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports expressions that can be replaced with "magic" constants.
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Bare literal "2" is used, warning:
  Font font = new Font("Arial", 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // Predefined constant is used, good:
  Font font = new Font("Arial", Font.ITALIC)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  When possible, the quick-fix inserts an appropriate predefined constant.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  The behavior of this inspection is controlled by &lt;code&gt;org.intellij.lang.annotations.MagicConstant&lt;/code&gt; annotation.
  Some standard Java library methods are pre-annotated, but you can use this annotation in your code as well.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ArrayEquals" defaultSeverity="WARNING" displayName="'equals()' called on array" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;equals()&lt;/code&gt; calls that compare two arrays.
&lt;p&gt;Calling &lt;code&gt;equals()&lt;/code&gt; on an array compares identity and is equivalent to using &lt;code&gt;==&lt;/code&gt;.
  Use &lt;code&gt;Arrays.equals()&lt;/code&gt; to compare the contents of two arrays, or &lt;code&gt;Arrays.deepEquals()&lt;/code&gt; for
  multi-dimensional arrays.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void sample(int[] first, int[] second){
    if (first.equals(second)) return;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void sample(int[] first, int[] second){
    if (Arrays.equals(first, second)) return;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NewStringBufferWithCharArgument" defaultSeverity="WARNING" displayName="StringBuilder constructor call with 'char' argument" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;StringBuffer&lt;/code&gt; and &lt;code&gt;StringBuilder&lt;/code&gt; constructors with &lt;code&gt;char&lt;/code&gt; as the argument.
In this case, &lt;code&gt;char&lt;/code&gt; is silently cast to an integer and interpreted as the initial capacity of the buffer.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new StringBuilder('(').append("1").append(')');
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new StringBuilder("(").append("1").append(')');
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastConflictsWithInstanceof" defaultSeverity="WARNING" displayName="Cast conflicts with 'instanceof'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports type cast expressions that are preceded by an &lt;code&gt;instanceof&lt;/code&gt; check for a different type.
&lt;p&gt;
  Although this might be intended, such a construct is most likely an error, and will
  result in a &lt;code&gt;java.lang.ClassCastException&lt;/code&gt; at runtime.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    int whenCharSequenceCastToNumber(Object o){
      if (o instanceof CharSequence) {
        return ((Number) o).intValue();
      }
      return 0;
    }

    int earlyReturnWhenNotCharSequence(Object o){
      if (!(o instanceof CharSequence)) return 0;
      return ((Number)o).intValue();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NullArgumentToVariableArgMethod" defaultSeverity="WARNING" displayName="Confusing argument to varargs method" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to variable arity methods that have a single argument
in the vararg parameter position, which is either a &lt;code&gt;null&lt;/code&gt; or an array of a subtype of the vararg parameter.
Such an argument may be confusing as it is unclear if a varargs or non-varargs call is desired.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String[] ss = new String[]{"foo", "bar"};
  System.out.printf("%s", ss);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example only the first element of the array will be printed, not the entire array.&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="VariableNotUsedInsideIf" defaultSeverity="WARNING" displayName="Reference checked for 'null' is not used inside 'if'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports references to variables that are checked for nullability
in the condition of an &lt;code&gt;if&lt;/code&gt; statement or
conditional expression but not used inside that
&lt;code&gt;if&lt;/code&gt; statement.
&lt;p&gt;
  Usually this either means that
  the check is unnecessary or that the variable is not referenced inside the
  &lt;code&gt;if&lt;/code&gt; statement by mistake.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Integer i) {
    if (i != null) { // here 'i' is not used inside 'if' statement
      System.out.println();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousArrayMethodCall" defaultSeverity="WARNING" displayName="Suspicious 'Arrays' method call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to non-generic-array manipulation methods like &lt;code&gt;Arrays.fill()&lt;/code&gt; with mismatched argument types.
Such calls don't do anything useful and are likely to be mistakes.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int foo(String[] strings) {
    return Arrays.binarySearch(strings, 1);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CompareToUsesNonFinalVariable" defaultSeverity="WARNING" displayName="Non-final field referenced in 'compareTo()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports access to a non-&lt;code&gt;final&lt;/code&gt; field inside a &lt;code&gt;compareTo()&lt;/code&gt; implementation.
&lt;p&gt;
  Such access may result in &lt;code&gt;compareTo()&lt;/code&gt;
  returning different results at different points in the object's lifecycle, which may in turn cause problems when
  using the standard collections classes, for example &lt;code&gt;java.util.TreeSet&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  A quick-fix to make the field &lt;code&gt;final&lt;/code&gt; is available
  only when there is no write access to the field, otherwise no fixes are suggested.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo implements Comparable&amp;lt;Foo&amp;gt;{
    private int index;
    Foo(int idx) {
      index = idx;
    }
    @Override
    public int compareTo(Foo foo) {
     return Integer.compare(this.index, foo.index);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo implements Comparable&amp;lt;Foo&amp;gt;{
    private final int index;
    Foo(int idx) {
      index = idx;
    }
    @Override
    public int compareTo(Foo foo) {
      return Integer.compare(this.index, foo.index);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EndlessStream" defaultSeverity="WARNING" displayName="Non-short-circuit operation consumes infinite stream" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-short-circuit operations consuming an infinite stream. Such operations can be completed only by throwing an exception.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Stream.iterate(0, i -&gt; i + 1).collect(Collectors.toList())
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsWhichDoesntCheckParameterClass" defaultSeverity="WARNING" displayName="'equals()' method which does not check class of parameter" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;equals()&lt;/code&gt; methods that do not check the type of their parameter.
&lt;p&gt;Failure to check the type of the parameter
  in the &lt;code&gt;equals()&lt;/code&gt; method may result in latent errors if the object is used in an untyped collection.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
    int x;

    @Override
    public boolean equals(Object obj) {
      // equals method should return false if obj is not MyClass
      return ((MyClass)obj).x == x;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousIndentAfterControlStatement" defaultSeverity="WARNING" displayName="Suspicious indentation after control statement without braces" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports suspicious indentation of statements after a control statement without braces.
&lt;p&gt;
  Such indentation can make it look like the statement is inside the control statement,
  when in fact it will be executed unconditionally after the control statement.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar {
      void foo(int i) {
          if (i == 0)
              System.out.println("foo");
              System.out.println("bar"); // warning
          if (i == 1);
              System.out.println("great"); // warning
          if (i == 42)
              System.out.println("answer");
                  System.out.println("question"); // warning
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StaticCallOnSubclass" defaultSeverity="WARNING" displayName="Static method referenced via subclass" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports static method calls where the call is qualified
by a subclass of the declaring class, rather than by the declaring class itself.
&lt;p&gt;
  Java allows such qualification for classes, but such calls
  may indicate a subtle confusion of inheritance and overriding.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    public static void print(String str) {}
  }
  class Child extends Parent {}

  Child.print("Hello, world!");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Parent.print("Hello, world!");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IteratorHasNextCallsIteratorNext" defaultSeverity="WARNING" displayName="'Iterator.hasNext()' which calls 'next()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports implementations of &lt;code&gt;Iterator.hasNext()&lt;/code&gt; or &lt;code&gt;ListIterator.hasPrevious()&lt;/code&gt; that call
&lt;code&gt;Iterator.next()&lt;/code&gt; or &lt;code&gt;ListIterator.previous()&lt;/code&gt; on the iterator instance. Such calls are almost certainly an error, as methods
like &lt;code&gt;hasNext()&lt;/code&gt; should not modify the iterators state, while &lt;code&gt;next()&lt;/code&gt; should.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyIterator implements Iterator&amp;lt;Integer&amp;gt; {
    public boolean hasNext() {
      return next() != null;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsOnSuspiciousObject" defaultSeverity="WARNING" displayName="'equals()' called on 'StringBuilder'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;equals()&lt;/code&gt; calls on &lt;code&gt;StringBuilder&lt;/code&gt; or &lt;code&gt;StringBuffer&lt;/code&gt; instances.
&lt;p&gt;The &lt;code&gt;equals()&lt;/code&gt; method is not overridden in these classes, so it may return &lt;code&gt;false&lt;/code&gt; even when the contents of the two objects are the same.
If the reference equality is intended, it's better to use &lt;code&gt;==&lt;/code&gt; to avoid confusion.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void test(StringBuilder sb1, StringBuilder sb2) {
    boolean result = sb1.equals(sb2); // Suspicious
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MalformedFormatString" defaultSeverity="WARNING" displayName="Malformed format string" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports format strings that don't comply with the standard Java syntax.
&lt;p&gt;By default, the inspection considers a compile-time constant a format string if it's used as an argument to the corresponding methods on
&lt;code&gt;java.util.Formatter&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;, &lt;code&gt;java.io.PrintWriter&lt;/code&gt; or &lt;code&gt;java.io.PrintStream&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String.format("x = %d, y = %d", 42);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Use the inspection settings to mark additional classes and methods as related to string formatting.&lt;/p&gt;
&lt;p&gt;As an alternative, you can use the &lt;code&gt;org.intellij.lang.annotations.PrintFormat&lt;/code&gt; annotation
  to mark the format string method parameter. In this case,
  the format arguments parameter must immediately follow the format string and be the last method parameter. Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void myFormatMethod(int mode, @PrintFormat String formatString, Object... args) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  Methods annotated in this way will also be recognized by this inspection.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringEquality" defaultSeverity="WARNING" displayName="String comparison using '==', instead of 'equals()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code that uses of &lt;b&gt;==&lt;/b&gt; or &lt;b&gt;!=&lt;/b&gt; to compare strings.
&lt;p&gt;
  These operators determine referential equality instead of comparing content.
  In most cases, strings should be compared using &lt;code&gt;equals()&lt;/code&gt;,
  which does a character-by-character comparison when the strings are different objects.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(String s, String t) {
    final boolean b = t == s;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If &lt;code&gt;t&lt;/code&gt; is known to be non-null, then it's safe to apply the "unsafe" quick-fix and get the result similar to the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(String s, String t) {
    final boolean b = t.equals(s);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ImplicitArrayToString" defaultSeverity="WARNING" displayName="Call to 'toString()' on array" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports arrays used in &lt;code&gt;String&lt;/code&gt; concatenations or passed as parameters to &lt;code&gt;java.io.PrintStream&lt;/code&gt;
methods, such as &lt;code&gt;System.out.println()&lt;/code&gt;.
&lt;p&gt;
  Usually, the content of the array is meant to be used and not the array object itself.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Object[] objects) {
    System.out.println(objects);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void print(Object[] objects) {
    System.out.println(Arrays.toString(objects));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InnerClassReferencedViaSubclass" defaultSeverity="WARNING" displayName="Inner class referenced via subclass" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports accesses of inner and nested classes where the call is qualified
by a subclass of the declaring class, rather than the declaring class itself.
&lt;p&gt;
  Java allows such qualification, but such accesses may indicate a subtle confusion of inheritance and overriding.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    static class Inner {}
  }

  class Sub extends Super {
    void test() {
      Sub.Inner s = new Sub.Inner(); // 'Inner' class is declared in 'Super' class, but referenced via 'Sub' class
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Super {
    static class Inner {}
  }

  class Sub extends Super {
    void test() {
      Super.Inner s = new Super.Inner();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassGetClass" defaultSeverity="WARNING" displayName="Suspicious 'Class.getClass()' call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;getClass()&lt;/code&gt; methods that are called on a &lt;code&gt;java.lang.Class&lt;/code&gt; instance.
&lt;p&gt;This is usually a mistake as the result is always equivalent to &lt;code&gt;Class.class&lt;/code&gt;.
If it's a mistake, then it's better to remove the &lt;code&gt;getClass()&lt;/code&gt; call and use the qualifier directly.
  If the behavior is intended, then it's better to write &lt;code&gt;Class.class&lt;/code&gt; explicitly to avoid confusion.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Class&amp;lt;?&amp;gt; clazz) {
    String name = clazz.getClass().getName();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After one of the possible quick-fixes is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Class&amp;lt;?&amp;gt; clazz) {
    String name = clazz.getName();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenationInFormatCall" defaultSeverity="WARNING" displayName="String concatenation as argument to 'format()' call" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-constant string concatenations used as a format string argument.
&lt;p&gt;
  While occasionally intended, this is usually a misuse of a formatting method
  and may even cause security issues if the variables used in the concatenated string
  contain special characters like &lt;code&gt;%&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  Also, sometimes this could be the result
  of mistakenly concatenating a string format argument by typing a &lt;code&gt;+&lt;/code&gt; when a &lt;code&gt;,&lt;/code&gt; was meant.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  static String formatGreeting(String userName) {
    return String.format("Hello, " + userName);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  Here, the &lt;code&gt;userName&lt;/code&gt; will be interpreted as a part of format string, which may result
  in &lt;code&gt;IllegalFormatException&lt;/code&gt; (for example, if &lt;code&gt;userName&lt;/code&gt; is &lt;code&gt;"%"&lt;/code&gt;) or
  in using an enormous amount of memory (for example, if &lt;code&gt;userName&lt;/code&gt; is &lt;code&gt;"%2000000000%"&lt;/code&gt;).
  The call should be probably replaced with &lt;code&gt;String.format("Hello, %s", userName);&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  This inspection checks calls to formatting methods on
  &lt;code&gt;java.util.Formatter&lt;/code&gt;,
  &lt;code&gt;java.lang.String&lt;/code&gt;,
  &lt;code&gt;java.io.PrintWriter&lt;/code&gt;,
  or &lt;code&gt;java.io.PrintStream&lt;/code&gt;.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MismatchedStringCase" defaultSeverity="WARNING" displayName="Mismatched case in 'String' operation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;String&lt;/code&gt; method calls that always return the same value (&lt;code&gt;-1&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;)
because a lowercase character is searched in an uppercase-only string or vice versa.
&lt;p&gt;Reported methods include &lt;code&gt;equals&lt;/code&gt;, &lt;code&gt;startsWith&lt;/code&gt;, &lt;code&gt;endsWith&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt;,
  &lt;code&gt;indexOf&lt;/code&gt;, and &lt;code&gt;lastIndexOf&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;
  if (columnName.toLowerCase().equals("ID")) {...}
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2019.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringTokenizerDelimiter" defaultSeverity="WARNING" displayName="Duplicated delimiters in 'StringTokenizer'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports either a &lt;code&gt;StringTokenizer&lt;/code&gt; constructor or a &lt;code&gt;nextToken&lt;/code&gt; method call that
contains duplicate characters in the delimiter argument, e.g. &lt;code&gt;tokenizer.nextToken("\n\n")&lt;/code&gt;.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="TextLabelInSwitchStatement" defaultSeverity="WARNING" displayName="Text label in 'switch' statement" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports labeled statements inside of &lt;code&gt;switch&lt;/code&gt; statements.
While occasionally intended, this construction is often the result of a typo.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  switch (x) {
      case 1:
      case2:   //warning: Text label 'case2:' in 'switch' statement
      case 3:
          break;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MathRandomCastToInt" defaultSeverity="WARNING" displayName="'Math.random()' cast to 'int'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;Math.random()&lt;/code&gt; which are immediately
cast to &lt;code&gt;int&lt;/code&gt;. 
&lt;p&gt;Casting a &lt;code&gt;double&lt;/code&gt; between &lt;code&gt;0.0&lt;/code&gt; (inclusive) and
  &lt;code&gt;1.0&lt;/code&gt; (exclusive) to &lt;code&gt;int&lt;/code&gt; will always round down to zero. The value
  should first be multiplied by some factor before casting it to an &lt;code&gt;int&lt;/code&gt; to
  get a value between zero (inclusive) and the multiplication factor (exclusive).
  Another possible solution is to use the &lt;code&gt;nextInt()&lt;/code&gt; method of
  &lt;code&gt;java.util.Random&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;b&gt;int&lt;/b&gt; r = (&lt;b&gt;int&lt;/b&gt;)Math.random() * 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;b&gt;int&lt;/b&gt; r = (&lt;b&gt;int&lt;/b&gt;)(Math.random() * 10);
&lt;/code&gt;&lt;/pre&gt;
  &lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StringConcatenationInMessageFormatCall" defaultSeverity="WARNING" displayName="String concatenation as argument to 'MessageFormat.format()' call" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports non-constant string concatenations used as an argument to a call to
&lt;code&gt;MessageFormat.format()&lt;/code&gt;.
&lt;p&gt;
  While occasionally intended, this is usually a misuse of the formatting method
  and may even cause unexpected exceptions if the variables used in the concatenated string contain
  special characters like &lt;code&gt;{&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  Also, sometimes this could be the result
  of mistakenly concatenating a string format argument by typing a &lt;code&gt;+&lt;/code&gt; when a &lt;code&gt;,&lt;/code&gt; was meant.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String formatGreeting(String userName, int balance) {
    return MessageFormat.format("Hello, " + userName + "! Your balance is {0}.", balance);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  Here, the &lt;code&gt;userName&lt;/code&gt; will be interpreted as a part of the format string, which may result
  in &lt;code&gt;IllegalArgumentException&lt;/code&gt; (for example, if &lt;code&gt;userName&lt;/code&gt; is &lt;code&gt;"{"&lt;/code&gt;).
  This call should be probably replaced with &lt;code&gt;MessageFormat.format("Hello, {0}! Your balance is {1}.", userName, balance)&lt;/code&gt;.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConfusingMainMethod" defaultSeverity="WARNING" displayName="Confusing 'main()' method" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that are named "main", but do not have the
&lt;code&gt;public static void main(String[])&lt;/code&gt; signature.
&lt;p&gt;Such methods may be confusing, as methods named "main"
  are expected to be application entry points.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    void main(String[] args) {} //a warning here because there are no "public static" modifiers
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix that renames such methods is available only in the editor.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SubtractionInCompareTo" defaultSeverity="WARNING" displayName="Subtraction in 'compareTo()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports subtraction in
&lt;code&gt;compareTo()&lt;/code&gt; methods and methods implementing &lt;code&gt;java.util.Comparator.compare()&lt;/code&gt;.
&lt;p&gt;
  While it is a common idiom to
  use the results of integer subtraction as the result of a &lt;code&gt;compareTo()&lt;/code&gt;
  method, this construct may cause subtle and difficult bugs in cases of integer overflow.
  Comparing the integer values directly and returning &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, or &lt;code&gt;1&lt;/code&gt; is a better practice in most cases.
&lt;/p&gt;
&lt;p&gt;
  Subtraction on floating point values that is immediately cast to integral type is also reported because precision loss is possible due to
  rounding.
&lt;/p&gt;
&lt;p&gt;
  The inspection doesn't report when it's statically determined that value ranges are limited, and overflow never occurs.
  Additionally, subtraction on &lt;code&gt;int&lt;/code&gt; numbers greater than or equal to &lt;code&gt;0&lt;/code&gt; will never overflow.
  Therefore, this inspection tries not to warn in those cases.
&lt;/p&gt;
&lt;p&gt;
  Methods that always return zero or greater can be marked with the
  &lt;code&gt;javax.annotation.Nonnegative&lt;/code&gt; annotation or specified in this inspection's options.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class DoubleHolder implements Comparable&amp;lt;DoubleHolder&amp;gt; {
    double d;
    public int compareTo(DoubleHolder that) {
        return (int)(this.d - that.d);
    }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A no-warning example because &lt;code&gt;String.length()&lt;/code&gt; is known to be non-negative:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A implements Comparable&amp;lt;A&amp;gt; {
    final String s = "";
    public int compareTo(A a) {
        return s.length() - a.s.length();
    }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the options to list methods that are safe to use inside a subtraction.
  Methods are safe when they return an &lt;code&gt;int&lt;/code&gt; value that is always greater than or equal to &lt;code&gt;0&lt;/code&gt;.
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousInvocationHandlerImplementation" defaultSeverity="WARNING" displayName="Suspicious 'InvocationHandler' implementation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports implementations of &lt;code&gt;InvocationHandler&lt;/code&gt; that do not proxy standard
&lt;code&gt;Object&lt;/code&gt; methods like &lt;code&gt;hashCode()&lt;/code&gt;, &lt;code&gt;equals()&lt;/code&gt;, and &lt;code&gt;toString()&lt;/code&gt;.
&lt;p&gt;Failing to handle these methods might cause unexpected problems upon calling them on a proxy instance.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  InvocationHandler myHandler = (proxy, method, params) -&amp;gt; {
    System.out.println("Hello World!");
    &lt;b&gt;return&lt;/b&gt; null;
  };
  Runnable myProxy = (Runnable) Proxy.newProxyInstance(
    Thread.currentThread().getContextClassLoader(),
    &lt;b&gt;new&lt;/b&gt; Class[] {Runnable.class}, myHandler
  );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  This code snippet is designed to only proxy the &lt;code&gt;Runnable.run()&lt;/code&gt; method.
  However, calls to any &lt;code&gt;Object&lt;/code&gt; methods, like &lt;code&gt;hashCode()&lt;/code&gt;, are proxied as well.
  This can lead to problems like a &lt;code&gt;NullPointerException&lt;/code&gt;, for example, when adding &lt;code&gt;myProxy&lt;/code&gt; to a &lt;code&gt;HashSet&lt;/code&gt;.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2020.2&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceAllDot" defaultSeverity="WARNING" displayName="Suspicious regex expression argument" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to
&lt;code&gt;String.replaceAll()&lt;/code&gt; or &lt;code&gt;String.split()&lt;/code&gt; where the first argument is a single regex meta character argument.
&lt;p&gt;
  The regex meta characters are one of &lt;code&gt;.$|()[{^?*+\&lt;/code&gt;. They have a special meaning in regular expressions.
  For example, calling &lt;code&gt;"ab.cd".replaceAll(".", "-")&lt;/code&gt; produces &lt;code&gt;"-----"&lt;/code&gt;, because the dot matches any character.
  Most likely the escaped variant &lt;code&gt;"\\."&lt;/code&gt; was intended instead.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  s.replaceAll(".", "-");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  s.replaceAll("\\.", "-");
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ScheduledThreadPoolExecutorWithZeroCoreThreads" defaultSeverity="WARNING" displayName="'ScheduledThreadPoolExecutor' with zero core threads" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any &lt;code&gt;java.util.concurrent.ScheduledThreadPoolExecutor&lt;/code&gt; instances in which
&lt;code&gt;corePoolSize&lt;/code&gt; is set to zero via the &lt;code&gt;setCorePoolSize&lt;/code&gt; method or
the object constructor.
&lt;p&gt;
  A &lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt; with zero core threads will run nothing.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(int corePoolSize) {
      if (corePoolSize != 0) return;
      ThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(corePoolSize); // warning
      executor.setCorePoolSize(corePoolSize); // warning
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="MismatchedStringBuilderQueryUpdate" defaultSeverity="WARNING" displayName="Mismatched query and update of 'StringBuilder'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;StringBuilder&lt;/code&gt; or &lt;code&gt;StringBuffer&lt;/code&gt; objects whose contents are read but not written to,
or written to but not read.
&lt;p&gt;Such inconsistent reads and writes are pointless and probably indicate
  dead, incomplete, or erroneous code.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public void m1() {
    StringBuilder sb = new StringBuilder();
    sb.append("a");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NonShortCircuitBoolean" defaultSeverity="WARNING" displayName="Non-short-circuit boolean expression" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of the non-short-circuit forms of boolean 'and' and 'or' (&lt;code&gt;&amp;amp;&lt;/code&gt;
and &lt;code&gt;|&lt;/code&gt;).
Although the non-short-circuit versions are occasionally useful, in most cases the short-circuit forms (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;
and &lt;code&gt;||&lt;/code&gt;) are intended and such unintentional usages may lead to subtle bugs.
&lt;p&gt;
  A quick-fix is suggested to use the short-circuit versions.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(boolean x, boolean y) {
    if (x | y) { /**/ }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(boolean x, boolean y) {
    if (x || y) { /**/ }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayHashCode" defaultSeverity="WARNING" displayName="'hashCode()' called on array" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports incorrect hash code calculation for arrays.
&lt;p&gt;In order to
  correctly calculate the hash code for an array, use:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Arrays.hashcode()&lt;/code&gt; for linear arrays&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Arrays.deepHashcode()&lt;/code&gt; for multidimensional arrays&lt;/li&gt;
&lt;/ul&gt;
These methods should also be used with &lt;code&gt;Objects.hash()&lt;/code&gt; when
the sequence of input values includes arrays, for example:
&lt;code&gt;Objects.hash(string, Arrays.hashcode(array))&lt;/code&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="EqualsUsesNonFinalVariable" defaultSeverity="WARNING" displayName="Non-final field referenced in 'equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports implementations of &lt;code&gt;equals()&lt;/code&gt; that access
non-&lt;code&gt;final&lt;/code&gt; variables. Such access may result in &lt;code&gt;equals()&lt;/code&gt;
returning different results at different points in the object's lifecycle, which may in turn cause problems when
using the standard collections classes.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public class Person {
    private String lastName;

    @Override
    public boolean equals(Object obj) {
      ...
      Person other = (Person) obj;
      if (lastName == null) {
        if (!lastName.equals(other.lastName)) {
        return false;
      ...
      }
    }
  }
  &lt;/code&gt;
&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstanceofIncompatibleInterface" defaultSeverity="WARNING" displayName="'instanceof' with incompatible interface" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;instanceof&lt;/code&gt; expressions where
the compared type is an interface, and the compared expression has a class type that neither
implements the compared interface, nor has any visible subclasses which implement the compared interface.
&lt;p&gt;
  Although that might be intended, normally such a construct is most likely an error, where
  the resulting &lt;code&gt;instanceof&lt;/code&gt; expression always evaluates to &lt;code&gt;false&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface I1 {}

  interface I2 {}

  interface I3 extends I1 {}

  static class Sub1 implements I1 {}

  static class Sub2 extends Sub1 implements I2 {
    void test(Sub1 sub1) {
      if (sub1 instanceof I3) { // here 'I3' is incompatible interface
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparatorResultComparison" defaultSeverity="WARNING" displayName="Suspicious usage of compare method" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports comparisons of the result of &lt;code&gt;Comparator.compare()&lt;/code&gt; or &lt;code&gt;Comparable.compareTo()&lt;/code&gt; calls with non-zero constants.
By contract, these methods can return any integer (not just -1, 0 or 1),
  so comparing against particular numbers is bad practice. Some widely used comparison methods (e.g. &lt;code&gt;String.compareTo()&lt;/code&gt;)
  actually return values outside the [-1..1] range, and such a comparison may cause incorrect program behavior.
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void validate(String s1, String s2) {
    // Comparing to 1 is incorrect
    if (s1.compareTo(s2) == 1) {
      throw new IllegalArgumentException("Incorrect order");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void validate(String s1, String s2) {
    if (s1.compareTo(s2) &gt; 0) {
      throw new IllegalArgumentException("Incorrect order");
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NumberEquality" defaultSeverity="WARNING" displayName="Number comparison using '==', instead of 'equals()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code that uses &lt;b&gt;==&lt;/b&gt; or &lt;b&gt;!=&lt;/b&gt; instead of &lt;code&gt;equals()&lt;/code&gt; to test for &lt;code&gt;Number&lt;/code&gt; equality.
&lt;p&gt;
  With auto-boxing, it is easy
  to make the mistake of comparing two instances of a wrapper type instead of two primitives, for example &lt;code&gt;Integer&lt;/code&gt; instead of
  &lt;code&gt;int&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void foo(Integer a, Integer b) {
    final boolean bool = a == b;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If &lt;code&gt;a&lt;/code&gt; is known to be non-null, then it's safe to apply the "unsafe" quick-fix and get the result similar to the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  void foo(Integer a, Integer b) {
    final boolean bool = a.equals(b);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OptionalGetWithoutIsPresent" defaultSeverity="WARNING" displayName="Optional.get() is called without isPresent() check" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;get()&lt;/code&gt; on an &lt;code&gt;Optional&lt;/code&gt; without checking that it has a value.
&lt;p&gt;Calling &lt;code&gt;Optional.get()&lt;/code&gt; on an empty &lt;code&gt;Optional&lt;/code&gt; instance will throw an exception.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;void&lt;/b&gt; x(List&amp;lt;Integer&gt; list) {
    &lt;b&gt;final&lt;/b&gt; Optional&amp;lt;Integer&gt; optional =
      list.stream().filter(x -&gt; x &gt; 10).findFirst();
    &lt;b&gt;final&lt;/b&gt; Integer result = optional.get(); // problem here
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsAndHashcode" defaultSeverity="WARNING" displayName="'equals()' and 'hashCode()' not paired" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that override the
&lt;code&gt;equals()&lt;/code&gt; method but do not override the
&lt;code&gt;hashCode()&lt;/code&gt; method or vice versa, which can potentially lead to problems
when the class is added to a &lt;code&gt;Collection&lt;/code&gt; or a &lt;code&gt;HashMap&lt;/code&gt;.
&lt;p&gt;The quick-fix generates the default implementation for an absent method.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class StringHolder {
  String s;

  @Override public int hashCode() {
    return s != null ? s.hashCode() : 0;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class StringHolder {
  String s;

  @Override public int hashCode() {
    return s != null ? s.hashCode() : 0;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof StringHolder)) return false;

    StringHolder holder = (StringHolder)o;

    if (s != null ? !s.equals(holder.s) : holder.s != null) return false;

    return true;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IterableUsedAsVararg" defaultSeverity="WARNING" displayName="Iterable is used as vararg" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports suspicious usages of &lt;code&gt;Collection&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt; in vararg method calls.
&lt;p&gt;For example, in the following method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &amp;lt;T&amp;gt; boolean contains(T needle, T... haystack) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;a call like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if(contains("item", listOfStrings)) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;looks suspicious as the list will be wrapped into a single element array.
  Such code can be successfully compiled and will likely run without
  exceptions, but it's probably used by mistake.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2019.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringEqualsCharSequence" defaultSeverity="WARNING" displayName="'String.equals()' called with 'CharSequence' argument" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;String.equals()&lt;/code&gt; with a &lt;code&gt;CharSequence&lt;/code&gt; as the argument.
&lt;p&gt;
  &lt;code&gt;String.equals()&lt;/code&gt; can only return &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;String&lt;/code&gt; arguments.
  To compare the contents of a &lt;code&gt;String&lt;/code&gt; with a non-&lt;code&gt;String&lt;/code&gt; &lt;code&gt;CharSequence&lt;/code&gt; argument,
  use the &lt;code&gt;contentEquals()&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean equals(String s, CharSequence ch) {
    return s.equals(ch);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  boolean equals(String s, CharSequence ch) {
    return s.contentEquals(ch);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;small&gt;New in 2017.3&lt;/small&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CastToIncompatibleInterface" defaultSeverity="WARNING" displayName="Casting to incompatible interface" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports type cast expressions where
the cast type is an interface and the cast expression has a class type that neither
implements the cast interface, nor has any visible subclasses that implement the cast interface.
&lt;p&gt;
  Although this might be intended, such a construct is most likely an error, and will
  result in a &lt;code&gt;java.lang.ClassCastException&lt;/code&gt; at runtime.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  interface A {}
  interface Z {}
  static class C {}

  void x(C c) {
    if (c instanceof Z) {
      A a = ((A)c); // cast to incompatible interface 'A'
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousTernaryOperatorInVarargsCall" defaultSeverity="WARNING" displayName="Suspicious ternary operator in varargs method call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports vararg method calls that use a ternary operator with mixed array and non-array branches.
&lt;p&gt;
When compiled, both branches are wrapped in arrays. As a result, the array branch is turned into
a two-dimensional array, which may indicate a problem.
&lt;/p&gt;
&lt;p&gt;
The quick-fix wraps the non-array branch in an array to prevent the compiler from doing the conversion.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    static void bar(boolean flag) {
        Object[] a = {1, 2};
        Object b = "hello";
        foo(flag ? a : b);
    }
    static void foo(Object... obj) {
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the quick-fix: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    static void bar(boolean flag) {
        Object[] a = {1, 2};
        Object b = "hello";
        foo(flag ? a : new Object[]{b});
    }
    static void foo(Object... obj) {
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;New in 2020.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UseOfPropertiesAsHashtable" defaultSeverity="WARNING" displayName="Use of 'Properties' object as a 'Hashtable'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to the following methods on &lt;code&gt;java.util.Properties&lt;/code&gt; objects:
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;java.util.Hashtable#put&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Hashtable#putIfAbsent&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Hashtable#putAll&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.util.Hashtable#get&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  For historical reasons, &lt;code&gt;java.util.Properties&lt;/code&gt; inherits &lt;code&gt;java.util.Hashtable&lt;/code&gt;,
  but using those methods is discouraged to prevent corruption of properties values of types other than &lt;code&gt;String&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  Although &lt;code&gt;java.util.Properties#putAll&lt;/code&gt; overrides &lt;code&gt;java.util.Hashtable#putAll&lt;/code&gt; it doesn't get reported when
  both the key and the value parameters in the map are of the &lt;code&gt;String&lt;/code&gt; type.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object f(Properties props) {
    props.put("hello", "world");
    props.putIfAbsent("hello", "world");
    props.putAll(new HashMap&amp;lt;&amp;gt;());
    return props.get("Hello");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Object f(Properties props) {
    props.setProperty("hello", "world");
    props.putIfAbsent("hello", "world");
    props.putAll(new HashMap&amp;lt;&amp;gt;());
    return props.getProperty("hello");
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MeaninglessRecordAnnotationInspection" defaultSeverity="WARNING" displayName="Meaningless record annotation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports annotations used on record components that have no effect.
&lt;p&gt;This can happen in two cases:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The reported annotation has the METHOD target, but the corresponding accessor is explicitly defined.&lt;/li&gt;
  &lt;li&gt;The reported annotation has the PARAMETER target, but the canonical constructor is explicitly defined.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
@Target(ElementType.METHOD)
@interface A { }
  
// The annotation will not appear in bytecode at all,
// as it should be propagated to the accessor but accessor is explicitly defined 
record R(@A int x) {
  public int x() { return x; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2021.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousDateFormat" defaultSeverity="WARNING" displayName="Suspicious date format pattern" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports date format patterns that are likely used by mistake.
&lt;p&gt;The following patterns are reported:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Uppercase "Y", unless "w" appears nearby. It stands for "Week year" that is almost always
    the same as normal "Year" (lowercase "y" pattern), but may point to the next year
    at the end of December.&lt;/li&gt;
  &lt;li&gt;Uppercase "M" (month) close to "H", "K", "h", or "k" (hour). It's likely that a lowercase "m" (minute) was intended.&lt;/li&gt;
  &lt;li&gt;Lowercase "m" (minute) close to "y" (year) or "d" (day in month). It's likely that an uppercase "M" (month) was intended.&lt;/li&gt;
  &lt;li&gt;Uppercase "D" (day in year) close to "M", or "L" (month). It's likely that a lowercase "d" (day in month) was intended.&lt;/li&gt;
  &lt;li&gt;Uppercase "S" (milliseconds) close to "m" (minutes). It's likely that a lowercase "s" (seconds) was intended.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  Examples:&lt;br&gt;
  &lt;code&gt;new SimpleDateFormat("YYYY-MM-dd")&lt;/code&gt;: likely &lt;code&gt;"yyyy-MM-dd"&lt;/code&gt; was intended.&lt;br&gt;
  &lt;code&gt;new SimpleDateFormat("yyyy-MM-DD")&lt;/code&gt;: likely &lt;code&gt;"yyyy-MM-dd"&lt;/code&gt; was intended.&lt;br&gt;
  &lt;code&gt;new SimpleDateFormat("HH:MM")&lt;/code&gt;: likely &lt;code&gt;"HH:mm"&lt;/code&gt; was intended.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2020.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CovariantEquals" defaultSeverity="WARNING" displayName="Covariant 'equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;equals()&lt;/code&gt; methods taking an argument type other than
&lt;code&gt;java.lang.Object&lt;/code&gt; if the containing class does not have other overloads of
&lt;code&gt;equals()&lt;/code&gt; that take &lt;code&gt;java.lang.Object&lt;/code&gt; as
its argument type.
&lt;p&gt;
  A covariant version of &lt;code&gt;equals()&lt;/code&gt; does not override the
  &lt;code&gt;Object.equals(Object)&lt;/code&gt; method. It may cause unexpected
  behavior at runtime. For example, if the class is used to construct
  one of the standard collection classes, which expect that the
  &lt;code&gt;Object.equals(Object)&lt;/code&gt; method is overridden.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      public boolean equals(Foo foo) {  // warning
          return false;
      }
  }
  class Bar {
      public boolean equals(Bar bar) {  // no warning here
          return false;
      }
      @Override
      public boolean equals(Object obj) {
          return false;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="OverwrittenKey" defaultSeverity="WARNING" displayName="Overwritten Map, Set, or array element" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code that overwrites a &lt;code&gt;Map&lt;/code&gt; key, a &lt;code&gt;Set&lt;/code&gt; element, or an array element in a sequence of
&lt;code&gt;add&lt;/code&gt;/&lt;code&gt;put&lt;/code&gt; calls or using a Java 9 factory method like &lt;code&gt;Set.of&lt;/code&gt; (which will result in runtime exception).
&lt;p&gt;This usually occurs due to a copy-paste error.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  map.put("A", 1);
  map.put("B", 2);
  map.put("C", 3);
  map.put("D", 4);
  map.put("A", 5); // duplicating key "A", overwrites the previously written entry
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2017.3&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InfiniteRecursion" defaultSeverity="WARNING" displayName="Infinite recursion" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports methods that call themselves infinitely unless an exception is thrown.
&lt;p&gt;
  Methods reported by this inspection cannot return normally.
  While such behavior may be intended, in many cases this is just an oversight.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  int baz() {
      return baz();
  }&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CapturingCleaner" defaultSeverity="WARNING" displayName="Cleaner captures object reference" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;Runnable&lt;/code&gt; passed to a &lt;code&gt;Cleaner.register()&lt;/code&gt; capturing reference being registered.
If the reference is captured, it will never be phantom reachable and the cleaning action will never be invoked.
&lt;p&gt;Possible sources of this problem:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Lambda using non-static methods, fields, or &lt;code&gt;this&lt;/code&gt; itself&lt;/li&gt;
  &lt;li&gt;Non-static inner class (anonymous or not) always captures this reference in java up to 18 version&lt;/li&gt;
  &lt;li&gt;Instance method reference&lt;/li&gt;
  &lt;li&gt;Access to outer class non-static members from non-static inner class&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Sample of code that will be reported: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int fileDescriptor;
  Cleaner.Cleanable cleanable = Cleaner.create().register(this, () -&gt; {
    System.out.println("adsad");
    //&lt;i&gt;this&lt;/i&gt; is captured via &lt;i&gt;fileDescriptor&lt;/i&gt;
    fileDescriptor = 0;
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This inspection only reports if the language level of the project or module is 9 or higher.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;New in 2018.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousIntegerDivAssignment" defaultSeverity="WARNING" displayName="Suspicious integer division assignment" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignments whose right side is a division that shouldn't be truncated to integer.
&lt;p&gt;While occasionally intended, this construction is often buggy.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int x = 18;
  x *= 3/2; // doesn't change x because of the integer division result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
This code should be replaced with:
&lt;pre&gt;&lt;code&gt;
  int x = 18;
  x *= 3.0/2;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  In the inspection options, you can disable warnings for suspicious but possibly correct divisions,
  for example, when the dividend can't be calculated statically.
&lt;pre&gt;&lt;code&gt;
  void calc(int d) {
     int x = 18;
     x *= d/2;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
  &lt;small&gt;New in 2019.2&lt;/small&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ThrowableNotThrown" defaultSeverity="WARNING" displayName="'Throwable' not thrown" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instantiations of &lt;code&gt;Throwable&lt;/code&gt; or its subclasses, where the created &lt;code&gt;Throwable&lt;/code&gt;
is never actually thrown.
Additionally, this inspection reports method calls that return instances of &lt;code&gt;Throwable&lt;/code&gt; or its subclasses,
when the result of the method call is not thrown.
&lt;p&gt;Calls to methods annotated with the Error Prone's or AssertJ's &lt;code&gt;@CanIgnoreReturnValue&lt;/code&gt; annotation will not be reported.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void leftBehind() throws Throwable {
        RuntimeException e = new RuntimeException("throw me");
        // ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InstantiationOfUtilityClass" defaultSeverity="WARNING" displayName="Instantiation of utility class" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports instantiation of utility classes using the &lt;code&gt;new&lt;/code&gt; keyword.
&lt;p&gt;
  In utility classes, all fields and methods are &lt;code&gt;static&lt;/code&gt;.
  Instantiation of such classes is most likely unnecessary and indicates a mistake.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyUtils {
    public static double cube(double x) {
      return x * x * x;
    }
  }
  class Main {
    public static void main(String[] args) {
      // Instantiation of utility class
      MyUtils utils = new MyUtils();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  To prevent utility classes from being instantiated,
  it's recommended to use a &lt;code&gt;private&lt;/code&gt; constructor.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectEquality" defaultSeverity="INFORMATION" displayName="Object comparison using '==', instead of 'equals()'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code that uses &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt; rather than &lt;code&gt;equals()&lt;/code&gt; to test for &lt;code&gt;Object&lt;/code&gt; equality.
&lt;p&gt;Comparing objects using &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt; is often a bug, because it compares objects by identity instead of
  equality.
  Comparisons to &lt;code&gt;null&lt;/code&gt; are not reported.
  Array, &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; comparisons are reported by separate inspections.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;b&gt;if&lt;/b&gt; (list1 == list2) {
    &lt;b&gt;return&lt;/b&gt;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &lt;b&gt;if&lt;/b&gt; (Object.equals(list1, list2)) {
    &lt;b&gt;return&lt;/b&gt;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;p&gt;Use the inspection settings to configure exceptions for this inspection.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnusedAssignment" defaultSeverity="WARNING" displayName="Unused assignment" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignment values that are not used after the assignment.
If the assignment value is unused, it's better to remove the assignment to shorten the code and avoid redundant allocations.
&lt;p&gt;The following cases are reported:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The variable never gets read after the assignment.&lt;/li&gt;
  &lt;li&gt;The variable is always overwritten with a new value before it is read.&lt;/li&gt;
  &lt;li&gt;The variable initializer is redundant (for one of the two reasons above).&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;
Use the &lt;b&gt;Report redundant initializers&lt;/b&gt; option to report redundant initializers:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int getI() {
    int i = 0; // redundant initialization
    i = 2;
    return i;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
Use the &lt;b&gt;Report ++i when may be replaced with (i + 1)&lt;/b&gt; option to report the cases when &lt;code&gt;++i&lt;/code&gt; expression
may be replaced with &lt;code&gt;i + 1&lt;/code&gt;:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int preInc(int i) {
    int res = i;
    return ++res;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
Use the &lt;b&gt;Report i++ when changed value is not used afterwards&lt;/b&gt; option to report the cases when the result of &lt;code&gt;i++&lt;/code&gt; expression
is not used later:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  int postInc(int i) {
    int res = i;
    return res++;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ReflectionForUnavailableAnnotation" defaultSeverity="WARNING" displayName="Reflective access to a source-only annotation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports attempts to reflectively check for the presence of a non-runtime annotation.
&lt;p&gt;Using &lt;code&gt;Class.isAnnotationPresent()&lt;/code&gt; to test for an annotation
  whose retention policy is set to &lt;code&gt;SOURCE&lt;/code&gt; or &lt;code&gt;CLASS&lt;/code&gt;
  (the default) will always have a negative result. This mistake is easy to overlook.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  {
    getClass().isAnnotationPresent(SourceAnnotation.class); //always false
  }

  @Retention(RetentionPolicy.SOURCE)
  @interface SourceAnnotation {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayObjectsEquals" defaultSeverity="WARNING" displayName="Use of shallow or 'Objects' methods with arrays" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports expressions that seem to use an inappropriate method for determining array equality or calculating their hashcode.
&lt;p&gt;The following method calls are reported:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Object.equals()&lt;/code&gt; for any arrays&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Arrays.equals()&lt;/code&gt; for multidimensional arrays&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Arrays.hashCode()&lt;/code&gt; for multidimensional arrays&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SuspiciousSystemArraycopy" defaultSeverity="WARNING" displayName="Suspicious 'System.arraycopy()' call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports suspicious calls to &lt;code&gt;System.arraycopy()&lt;/code&gt;.
&lt;p&gt;Such calls are suspicious when:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the source or destination is not of an array type
&lt;li&gt;the source and destination are of different types
&lt;li&gt;the copied chunk length is greater than &lt;code&gt;src.length - srcPos&lt;/code&gt;
&lt;li&gt;the copied chunk length is greater than &lt;code&gt;dest.length - destPos&lt;/code&gt;
&lt;li&gt;the ranges always intersect when the source and destination are the same array
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo() {
    int[] src = new int[] { 1, 2, 3, 4 };
    System.arraycopy(src, 0, src, 1, 2); // warning: Copying to the same array with intersecting ranges
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ComparableImplementedButEqualsNotOverridden" defaultSeverity="WARNING" displayName="'Comparable' implemented but 'equals()' not overridden" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports classes that implement &lt;code&gt;java.lang.Comparable&lt;/code&gt;
but do not override &lt;code&gt;equals()&lt;/code&gt;.
&lt;p&gt;
  If &lt;code&gt;equals()&lt;/code&gt;
  is not overridden, the &lt;code&gt;equals()&lt;/code&gt; implementation is not consistent with
  the &lt;code&gt;compareTo()&lt;/code&gt; implementation. If an object of such a class is added
  to a collection such as &lt;code&gt;java.util.SortedSet&lt;/code&gt;, this collection will violate
  the contract of &lt;code&gt;java.util.Set&lt;/code&gt;, which is defined in terms of
  &lt;code&gt;equals()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Length implements Comparable&amp;lt;Length&gt; {
    private int cm = 0;

    @Override
    public int compareTo(@NotNull Length o) {
      if (cm == o.cm) return 0;
      return cm &amp;lt; o.cm ? -1 : 1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Length implements Comparable&amp;lt;Length&gt; {
    private int cm = 0;

    @Override
    public int compareTo(@NotNull Length o) {
      if (cm == o.cm) return 0;
      return cm &amp;lt; o.cm ? -1 : 1;
    }

    @Override
    public boolean equals(Object o) {
      return o instanceof Length &amp;&amp; compareTo((Length) o) == 0;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="InvalidComparatorMethodReference" defaultSeverity="WARNING" displayName="Invalid method reference used for 'Comparator'" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method references mapped to the &lt;code&gt;Comparator&lt;/code&gt; interface that don't fulfill its contract.
&lt;p&gt;
Some method references, like &lt;code&gt;Integer::max&lt;/code&gt;, can be mapped to the &lt;code&gt;Comparator&lt;/code&gt; interface.
However, using them as &lt;code&gt;Comparator&lt;/code&gt; is meaningless and the result might be unpredictable.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ArrayList&amp;lt;Integer&amp;gt; ints = foo();
  ints.sort(Math::min);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ArrayList&amp;lt;Integer&amp;gt; ints = foo();
  ints.sort(Comparator.reverseOrder());
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ClassNewInstance" defaultSeverity="WARNING" displayName="Unsafe call to 'Class.newInstance()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;java.lang.Class.newInstance()&lt;/code&gt;.
&lt;p&gt;
  This method propagates exceptions thrown by
  the no-arguments constructor, including checked exceptions. Usages of this method
  effectively bypass the compile-time exception checking that would
  otherwise be performed by the compiler.
&lt;/p&gt;
&lt;p&gt;
  A quick-fix is suggested to replace the call with a call to the
  &lt;code&gt;java.lang.reflect.Constructor.newInstance()&lt;/code&gt; method, which
  avoids this problem by wrapping any exception thrown by the constructor in a
  (checked) &lt;code&gt;java.lang.reflect.InvocationTargetException&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  clazz.newInstance()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  clazz.getConstructor().newInstance();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="HashCodeUsesNonFinalVariable" defaultSeverity="WARNING" displayName="Non-final field referenced in 'hashCode()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports implementations of &lt;code&gt;hashCode()&lt;/code&gt; that access
non-&lt;code&gt;final&lt;/code&gt; variables.
&lt;p&gt;
  Such access may result in &lt;code&gt;hashCode()&lt;/code&gt;
  returning different values at different points in the object's lifecycle, which may in turn cause problems when
  using the standard collections classes.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Drink {
    String name;
    Drink(String name) { this.name = name; }
    @Override public int hashCode() {
      return Objects.hash(name); //warning
    }
  }
  ...
    Drink coffee = new Drink("Coffee");
    priceMap.put(coffee, 10.0);
    coffee.name = "Tea";
    double coffeePrice = priceMap.get(coffee); //not found
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix is suggested to make the field final:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Drink {
    final String name;
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousArrayCast" defaultSeverity="WARNING" displayName="Suspicious array cast" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports suspicious array casts.
An array cast is considered suspicious when it casts to a more specific array type. Such a cast is legal at compile
time but may fail with a &lt;code&gt;ClassCastException&lt;/code&gt; at runtime.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Number[] numbers = new Number[]{1L, 2L, 4L};
  Long[] longs = (Long[])numbers;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousNameCombination" defaultSeverity="WARNING" displayName="Suspicious variable/parameter name combination" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports assignments and function calls in which the name of the target variable or the function parameter does not match the name of the value assigned to it.
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;int&lt;/b&gt; x = 0;
  &lt;b&gt;int&lt;/b&gt; y = x; // x is used as a y-coordinate
  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;int&lt;/b&gt; x = 0, y = 0;
  // x is used as a y-coordinate and y as an x-coordinate
  Rectangle rc = &lt;b&gt;new&lt;/b&gt; Rectangle(y, x, 20, 20);
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;Configure the inspection:&lt;/p&gt;
&lt;p&gt;Use the &lt;b&gt;Group of names&lt;/b&gt; area to specify the names which should not be used together: an error is reported
if the parameter name or assignment target name contains words from one group and the name of the assigned or passed
variable contains words from a different group.
&lt;p&gt;Use the &lt;b&gt;Ignore methods&lt;/b&gt; area to specify the methods that should not be checked but have a potentially suspicious name.
For example, the &lt;code&gt;Integer.compare()&lt;/code&gt; parameters are named &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; but are unrelated to coordinates.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="Contract" defaultSeverity="WARNING" displayName="Contract issues" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports issues in method &lt;code&gt;@Contract&lt;/code&gt; annotations. The types of issues that can be reported are:
&lt;ul&gt;
&lt;li&gt;Errors in contract syntax&lt;/li&gt;
&lt;li&gt;Contracts that do not conform to the method signature (wrong parameter count)&lt;/li&gt;
&lt;li&gt;Method implementations that contradict the contract (e.g. return &lt;code&gt;true&lt;/code&gt; when the contract says &lt;code&gt;false&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // method has no parameters, but contract expects 1
  @Contract("_ -&gt; fail")
  &lt;b&gt;void&lt;/b&gt; x() {
    &lt;b&gt;throw&lt;/b&gt; new AssertionError();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ConstantAssertCondition" defaultSeverity="WARNING" displayName="Constant condition in 'assert' statement" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;assert&lt;/code&gt; statement conditions that are constants. &lt;code&gt;assert&lt;/code&gt;
statements with constant conditions will either always fail or always succeed.
Such statements might be left over after a refactoring and are probably not intended.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    void foo() {
        assert true;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsWithItself" defaultSeverity="WARNING" displayName="'equals()' called on itself" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;equals()&lt;/code&gt; or &lt;code&gt;compareTo()&lt;/code&gt; where an object is compared for equality
with itself.
&lt;p&gt;According to the method contracts, these operations will always return
  &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;equals()&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; for &lt;code&gt;compareTo()&lt;/code&gt;. The inspection also checks
  the calls to &lt;code&gt;Objects.equals()&lt;/code&gt;, &lt;code&gt;Objects.deepEquals()&lt;/code&gt;,
  &lt;code&gt;Arrays.equals()&lt;/code&gt;, &lt;code&gt;Comparator.compare&lt;/code&gt;, and the like.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
    boolean foo(Object o) {
        return o.equals(o); // warning
    }

    boolean bar(String[] ss) {
        return Arrays.equals(ss, ss); // warning
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="StringConcatenationMissingWhitespace" defaultSeverity="WARNING" displayName="Whitespace may be missing in string concatenation" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports string concatenations with missing whitespaces, that is where the left-hand side
ends with a Unicode letter or digit and the right-hand side starts with a Unicode letter or digit.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String sql = "SELECT column" +
               "FROM table";
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the &lt;b&gt;Ignore concatenations with variable strings&lt;/b&gt; option to only report
  when both the left and right side of the concatenation are literals.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousMethodCalls" defaultSeverity="WARNING" displayName="Suspicious collection method call" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method calls on parameterized collections, where the actual argument type does not
correspond to the collection's elements type.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  List&amp;lt;Integer&amp;gt; list = getListOfElements();
  list.remove(""); // remove is highlighted
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  In the inspection settings, you can disable warnings for potentially correct code like the following:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  public boolean accept(Map&amp;lt;Integer, String&amp;gt; map, Object key) {
    return map.containsKey(key);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="IgnoreResultOfCall" defaultSeverity="WARNING" displayName="Result of method call ignored" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports method calls whose result is ignored.
&lt;p&gt;For many methods, ignoring the result is perfectly
  legitimate, but for some it is almost certainly an error. Examples of methods where ignoring
  the result is likely an error include &lt;code&gt;java.io.inputStream.read()&lt;/code&gt;,
  which returns the number of bytes actually read, and any method on
  &lt;code&gt;java.lang.String&lt;/code&gt; or &lt;code&gt;java.math.BigInteger&lt;/code&gt;. These methods do not produce side-effects and thus pointless
  if their result is ignored.
&lt;/p&gt;
&lt;p&gt;The calls to the following methods are inspected:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Simple getters (which do nothing except return a field)&lt;/li&gt;
  &lt;li&gt;Methods specified in the settings of this inspection&lt;/li&gt;
  &lt;li&gt;Methods annotated with &lt;code&gt;org.jetbrains.annotations.Contract(pure=true)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Methods annotated with .*.&lt;code&gt;CheckReturnValue&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Methods in a class or package annotated with &lt;code&gt;javax.annotation.CheckReturnValue&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Optionally, all non-library methods&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Calls to methods annotated with Error Prone's or AssertJ's &lt;code&gt;@CanIgnoreReturnValue&lt;/code&gt; annotation are not reported.

&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Use the inspection settings to specify the classes to check.
  Methods are matched by name or name pattern using Java regular expression syntax.
  For classes, use fully-qualified names. Each entry applies to both the class and all its inheritors.
&lt;p&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MisspelledEquals" defaultSeverity="WARNING" displayName="'equal()' instead of 'equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports declarations of &lt;code&gt;equal()&lt;/code&gt; with a single parameter.
Normally, this is a typo and &lt;code&gt;equals()&lt;/code&gt; is actually intended.
&lt;p&gt;A quick-fix is suggested to rename the method to &lt;code&gt;equals&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public boolean equal(Object obj) {
      return true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Main {
    public boolean equals(Object obj) {
      return true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SortedCollectionWithNonComparableKeys" defaultSeverity="WARNING" displayName="Sorted collection with non-comparable elements" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports construction of sorted collections, for example &lt;code&gt;TreeSet&lt;/code&gt;, that rely on natural ordering,
whose element type doesn't implement the &lt;code&gt;Comparable&lt;/code&gt; interface.
&lt;p&gt;It's unlikely that such a collection will work properly.&lt;/p&gt;
&lt;p&gt;
  A false positive is possible if the collection element type is a non-comparable super-type,
  but the collection is intended to only hold comparable sub-types. Even if this is the case,
  it's better to narrow the collection element type or declare the super-type as &lt;code&gt;Comparable&lt;/code&gt; because the mentioned approach is error-prone.
&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  The inspection also reports cases when the collection element is a type parameter which is not declared as &lt;code&gt;extends Comparable&lt;/code&gt;.
  You can suppress the warnings on type parameters using the provided option (for example, to keep the API compatibility).
&lt;/p&gt;
&lt;p&gt;
  &lt;small&gt;New in 2018.3&lt;/small&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantOperationOnEmptyContainer" defaultSeverity="WARNING" displayName="Redundant operation on empty container" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant operations on empty collections, maps or arrays.
&lt;p&gt;
  Iterating, removing elements, sorting,
  and some other operations on empty collections have no effect and can be removed. Also, they may be a signal of a bug.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  if (numbers.isEmpty()){
    //error due to the missed negation
    int max = numbers.stream().max(Comparator.naturalOrder()).get();
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2019.1&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EmptyStatementBody" defaultSeverity="WARNING" displayName="Statement with empty body" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, and &lt;code&gt;switch&lt;/code&gt; statements
with empty bodies.
&lt;p&gt;While occasionally intended, such code is confusing and is often the result of a typo.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;This inspection is disabled in JSP files.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="MismatchedCollectionQueryUpdate" defaultSeverity="WARNING" displayName="Mismatched query and update of collection" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports collections whose contents are either queried and
not updated, or updated and not queried.
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  Such inconsistent queries and updates are pointless and may indicate
  either dead code or a typo.
&lt;/p&gt;
&lt;p&gt;
  Use the inspection settings to specify name patterns that correspond to update/query methods.
  Query methods that return an element are automatically detected, and only
  those that write data to an output parameter (for example, an &lt;code&gt;OutputStream&lt;/code&gt;) need to be specified.
&lt;p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;Suppose you have your custom &lt;code&gt;FixedStack&lt;/code&gt; class with method &lt;code&gt;store()&lt;/code&gt;:
&lt;pre&gt;&lt;code&gt;
  public class FixedStack&amp;lt;T&amp;gt; extends Collection&amp;lt;T&amp;gt; {
    public T store(T t) {
      // implementation
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can add &lt;code&gt;store&lt;/code&gt; to the update methods table in order to report mismatched queries like:
&lt;pre&gt;&lt;code&gt;
  void test(int i) {
    FixedStack&amp;lt;Integer&amp;gt; stack = new FixedStack&amp;lt;&amp;gt;();
    stack.store(i);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="IteratorNextDoesNotThrowNoSuchElementException" defaultSeverity="WARNING" displayName="'Iterator.next()' which can't throw 'NoSuchElementException'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports implementations of &lt;code&gt;Iterator.next()&lt;/code&gt;
that cannot throw &lt;code&gt;java.util.NoSuchElementException&lt;/code&gt;.
&lt;p&gt;
  Such implementations violate the contract of &lt;code&gt;java.util.Iterator&lt;/code&gt;,
  and may result in subtle bugs if the iterator is used in a non-standard way.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Numbers implements Iterator&amp;lt;Integer&amp;gt; {
    @Override
    public Integer next() { //warning
        if (hasNext()) {
            return generateNext();
        } else {
            return null; //throw NoSuchElementException instead
        }
    }

    ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ObjectToString" defaultSeverity="WARNING" displayName="Call to default 'toString()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;toString()&lt;/code&gt; that use the default implementation
from &lt;code&gt;java.lang.Object&lt;/code&gt;.
&lt;p&gt;The default implementation is rarely intended but may be used by accident.&lt;/p&gt;
&lt;p&gt;
  Calls to &lt;code&gt;toString()&lt;/code&gt; on objects with &lt;code&gt;java.lang.Object&lt;/code&gt;,
  interface or abstract class type are ignored by this inspection.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar {
      void foo1(Bar bar) {
          String s = bar.toString(); // warning
          /* ... */
      }

      void foo2(Object obj) {
          String s = obj.toString(); // no warning here
          /* ... */
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;

&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ArrayEquality" defaultSeverity="WARNING" displayName="Array comparison using '==', instead of 'Arrays.equals()'" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; used to test for array equality.
In most cases, testing for the equality of array contents is intended,
which can be done with the &lt;code&gt;java.util.Arrays.equals()&lt;/code&gt; method.
&lt;p&gt;
  A quick-fix is suggested to replace &lt;code&gt;==&lt;/code&gt; with &lt;code&gt;java.util.Arrays.equals()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object[] x, Object[] y) {
    boolean comparison = x == y;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void foo(Object[] x, Object[] y) {
    boolean comparison = Arrays.equals(x, y);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="PrimitiveArrayArgumentToVariableArgMethod" defaultSeverity="WARNING" displayName="Confusing primitive array argument to varargs method" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports any calls to a variable arity method where the call has a primitive array in
the variable arity parameter position (for example, &lt;code&gt;System.out.printf("%s", new int[]{1, 2, 3})&lt;/code&gt;).
Such a primitive-array argument may be confusing, as it will be wrapped as a single-element array, rather than each individual
element being boxed, as might be expected.
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String.format("%s", new int[]{1, 2, 3});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String.format("%s", (Object) new int[]{1, 2, 3});
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="NewObjectEquality" defaultSeverity="WARNING" displayName="New object is compared using '=='" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports code that applies &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt; to a newly allocated object
instead of calling &lt;code&gt;equals()&lt;/code&gt;.
&lt;p&gt;
  The references to newly allocated objects cannot point at existing objects,
  thus the comparison will always evaluate to &lt;code&gt;false&lt;/code&gt;. The inspection may also report newly
  created objects returned from simple methods.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Object obj) {
    if (new Object() == obj) {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  void test(Object obj) {
    if (new Object().equals(obj)) {...}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;
  &lt;small&gt;New in 2018.3&lt;/small&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="EqualsBetweenInconvertibleTypes" defaultSeverity="WARNING" displayName="'equals()' between objects of inconvertible types" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;equals()&lt;/code&gt; where the target and argument are
of incompatible types.
&lt;p&gt;While such a call might theoretically be useful, most likely it is a bug.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  new HashSet&amp;lt;String&amp;gt;().equals(new TreeSet&amp;lt;Integer&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="CollectionAddedToSelf" defaultSeverity="WARNING" displayName="Collection added to itself" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports cases where the argument of a method call on a &lt;code&gt;java.util.Collection&lt;/code&gt;
or &lt;code&gt;java.util.Map&lt;/code&gt; is the collection or map itself.
Such situations may occur as a result of copy-paste in code with raw types.

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  ArrayList list = new ArrayList&amp;lt;&amp;gt;();
  list.add(list); // warning here
  return list.hashCode(); // throws StackOverflowError
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="SuspiciousListRemoveInLoop" defaultSeverity="WARNING" displayName="Suspicious 'List.remove()' in loop" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;list.remove(index)&lt;/code&gt; calls inside an ascending counted loop.
&lt;p&gt;
  This is suspicious as the list becomes
  shorter after the removal, and the next element gets skipped. A simple fix is to decrease the index variable
  after the removal,
  but probably removing via an iterator or using the &lt;code&gt;removeIf()&lt;/code&gt; method (Java 8 and later) is a more robust alternative.
  If you don't expect that &lt;code&gt;remove()&lt;/code&gt; will be called more than once in a loop, consider adding a &lt;code&gt;break&lt;/code&gt; after it.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public static void main(String[] args) {
    process(new ArrayList&amp;lt;&gt;(
      Arrays.asList("1", "2", "|", "3", "4")));
  }

  static void process(List&amp;lt;String&amp;gt; list) {
    for (int i = 0; i &amp;lt; list.size(); i++) {
      if (list.get(i).equals("|")) {
        list.remove(i);
        continue;
      }
      System.out.println(list.get(i));
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code looks like &lt;code&gt;1 2 3 4&lt;/code&gt; is going to be printed, but in reality, &lt;code&gt;3&lt;/code&gt; will be skipped in the output.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;p&gt;&lt;small&gt;New in 2018.2&lt;/small&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ResultSetIndexZero" defaultSeverity="WARNING" displayName="Use of index 0 in JDBC ResultSet" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports attempts to access column 0 of &lt;code&gt;java.sql.ResultSet&lt;/code&gt; or &lt;code&gt;java.sql.PreparedStatement&lt;/code&gt;.
For historical reasons, columns of &lt;code&gt;java.sql.ResultSet&lt;/code&gt; and &lt;code&gt;java.sql.PreparedStatement&lt;/code&gt;
are numbered starting with &lt;b&gt;1&lt;/b&gt;, rather than with &lt;b&gt;0&lt;/b&gt;, and accessing column 0 is a common error in JDBC programming.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  String getName(ResultSet rs) {
    &lt;b&gt;return&lt;/b&gt; rs.getString(0);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="AssertWithSideEffects" defaultSeverity="WARNING" displayName="'assert' statement with side effects" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">  &lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;assert&lt;/code&gt; statements that cause side effects.
&lt;p&gt;
  Since assertions can be switched off,
  these side effects are not guaranteed, which can cause subtle bugs. Common unwanted side effects detected by this inspection are
  modifications of variables and fields. When methods calls are involved, they are analyzed one level deep.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  assert i++ &amp;lt; 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ComparatorMethodParameterNotUsed" defaultSeverity="WARNING" displayName="Suspicious 'Comparator.compare()' implementation" enabled="true" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports problems in &lt;code&gt;Comparator.compare()&lt;/code&gt; implementations.
&lt;p&gt;The following cases are reported:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    A parameter is not used. Most likely this is a typo and the other parameter is compared
    with itself, or the method is not implemented correctly.
  &lt;/li&gt;
  &lt;li&gt;
    It's evident that the comparator does not return &lt;code&gt;0&lt;/code&gt; for the same elements. Such a comparator violates the contract
    and can produce unpredictable results when equal elements are encountered. In particular,
    sorting may fail with an exception on some data.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  Comparator&amp;lt;String&amp;gt; lambda =
    (a, b) -&amp;gt; a.length() &amp;gt; b.length()
              ? 0
              : Math.random() &amp;gt; 0.5 ? -1 : 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="StaticFieldReferenceOnSubclass" defaultSeverity="WARNING" displayName="Static field referenced via subclass" enabled="false" language="JAVA" pluginId="com.intellij.java" pluginVersion="221.6008.13.2211.9514443" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports accesses to static fields where the call is
qualified by a subclass of the declaring class, rather than by the declaring class itself.
&lt;p&gt;
  Java allows such qualification, but such accesses may indicate a subtle confusion of inheritance and overriding.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    static int foo = 0;
  }

  class Child extends Parent { }

  void bar() {
    System.out.println(Child.foo);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied, the result looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Parent {
    static int foo = 0;
  }

  class Child extends Parent { }

  void bar() {
    System.out.println(Parent.foo);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection></group><group name="Redundant constructs" path="Kotlin"><inspection shortName="RedundantEnumConstructorInvocation" defaultSeverity="WEAK WARNING" displayName="Redundant enum constructor invocation" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports redundant constructor invocation on an enum entry.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum class Baz(i: Int = 0) {
      A(1),
      B&lt;b&gt;()&lt;/b&gt;,
      C&lt;b&gt;()&lt;/b&gt;,
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  enum class Baz(i: Int = 0) {
      A(1),
      B,
      C,
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantVisibilityModifier" defaultSeverity="WARNING" displayName="Redundant visibility modifier" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports visibility modifiers that match the default visibility of an element
(&lt;code&gt;public&lt;/code&gt; for most elements, &lt;code&gt;protected&lt;/code&gt; for members that override a protected member).
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveEmptySecondaryConstructorBody" defaultSeverity="WEAK WARNING" displayName="Redundant constructor body" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports empty bodies of secondary constructors.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveEmptyParenthesesFromLambdaCall" defaultSeverity="INFO" displayName="Remove unnecessary parentheses from function call with lambda" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant empty parentheses of function calls where the only parameter is a lambda that's outside the parentheses.
&lt;p&gt;Use the 'Remove unnecessary parentheses from function call with lambda' quick-fix to clean up the code.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      listOf(1).forEach() {  }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo() {
      listOf(1).forEach {  }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="NullChecksToSafeCall" defaultSeverity="WEAK WARNING" displayName="Null-checks can be replaced with safe-calls" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports chained null-checks that can be replaced with safe-calls.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(my: My?) {
      if (my != null &amp;&amp; my.foo() != null) {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(my: My?) {
      if (my?.foo() != null) {}
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantModalityModifier" defaultSeverity="WARNING" displayName="Redundant modality modifier" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the modality modifiers that match the default modality of an element
(&lt;code&gt;final&lt;/code&gt; for most elements, &lt;code&gt;open&lt;/code&gt; for members with an &lt;code&gt;override&lt;/code&gt;).
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;final&lt;/b&gt; class Foo

  open class Bar : Comparable&amp;lt;Bar&amp;gt; {
      &lt;b&gt;open&lt;/b&gt; override fun compareTo(other: Bar): Int = 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo

  open class Bar : Comparable&amp;lt;Bar&amp;gt; {
      open override fun compareTo(other: Bar): Int = 0
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantSamConstructor" defaultSeverity="WARNING" displayName="Redundant SAM constructor" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports SAM (Single Abstract Method) constructor usages which can be replaced with lambdas.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      foo(&lt;b&gt;Runnable&lt;/b&gt; { println("Hi!") })
  }

  fun foo(other: Runnable) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      foo( { println("Hi!") })
  }

  fun foo(other: Runnable) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CanBePrimaryConstructorProperty" defaultSeverity="WARNING" displayName="Property is explicitly assigned to constructor parameter" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports properties that are explicitly assigned to primary constructor parameters.
&lt;p&gt;Properties can be declared directly in the primary constructor, reducing the amount of code and increasing code readability.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User(name: String) {
      val name = name
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix joins the parameter and property declaration into a primary constructor parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class User(val name: String) {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantLambdaOrAnonymousFunction" defaultSeverity="WEAK WARNING" displayName="Redundant creation of lambda or anonymous function" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports lambdas or anonymous functions that are created and used immediately.&lt;/p&gt;
&lt;!-- tooltip end --&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;fun&lt;/b&gt; test() {
      ({ println() })() // redundant
      (&lt;b&gt;fun&lt;/b&gt;() { println() })() // redundant
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantCompanionReference" defaultSeverity="WARNING" displayName="Redundant 'Companion' reference" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports redundant &lt;code&gt;Companion&lt;/code&gt; reference.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
      &lt;b&gt;companion object&lt;/b&gt; {
          fun create() = A()
      }
  }
  fun test() {
      val s = A.&lt;b&gt;Companion&lt;/b&gt;.create()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class A {
      &lt;b&gt;companion object&lt;/b&gt; {
          fun create() = A()
      }
  }
  fun test() {
      val s = A.create()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveExplicitSuperQualifier" defaultSeverity="WEAK WARNING" displayName="Unnecessary supertype qualification" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;super&lt;/code&gt; member calls with redundant supertype qualification.
&lt;p&gt;
    Code in a derived class can call its superclass functions and property accessors implementations using the &lt;code&gt;super&lt;/code&gt; keyword.
    To specify the supertype from which the inherited implementation is taken, &lt;code&gt;super&lt;/code&gt; can be qualified by the supertype name in
    angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;. Sometimes this qualification is redundant and can be omitted.
    Use the 'Remove explicit supertype qualification' quick-fix to clean up the code.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  open class B {
      open fun foo(){}
  }

  class A : B() {
      override fun foo() {
         super&amp;lt;B&amp;gt;.foo() // &amp;lt;== redundant because 'B' is the only supertype
      }
  }

  interface I {
      fun foo() {}
  }

  class C : B(), I {
      override fun foo() {
          super&amp;lt;B&amp;gt;.foo() // &amp;lt;== here &amp;lt;B&amp;gt; qualifier is needed to distinguish 'B.foo()' from 'I.foo()'
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  open class B {
      open fun foo(){}
  }

  class A : B() {
      override fun foo() {
         super.foo() // &amp;lt;== Updated
      }
  }

  interface I {
      fun foo() {}
  }

  class C : B(), I {
      override fun foo() {
          super&amp;lt;B&amp;gt;.foo()
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveToStringInStringTemplate" defaultSeverity="WEAK WARNING" displayName="Redundant call to 'toString()' in string template" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports calls to &lt;code&gt;toString()&lt;/code&gt; in string templates that can be safely removed.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun foo(a: Int, b: Int) = a + b

  fun test(): String {
      return "Foo: ${foo(0, 4).toString()}" // 'toString()' is redundant
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  fun foo(a: Int, b: Int) = a + b

  fun test(): String {
      return "Foo: ${foo(0, 4)}"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantIf" defaultSeverity="WEAK WARNING" displayName="Redundant 'if' statement" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports &lt;code&gt;if&lt;/code&gt; statements which can be simplified to a single statement.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      if (foo()) {
         return true
      } else {
         return false
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      return foo()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantSetter" defaultSeverity="WEAK WARNING" displayName="Redundant property setter" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant property setters.
&lt;p&gt;
Setter is considered to be redundant in one of the following cases:
&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;
        Setter has no body. Accessor visibility isn't changed, declaration isn't &lt;code&gt;external&lt;/code&gt; and has no annotations.
        &lt;pre&gt;&lt;code&gt;
  var myPropWithRedundantSetter: Int = 0
      set // redundant

  var myPropA: Int = 0
      private set // OK - property visibility is changed to private

  var myPropB: Int = 0
      external set // OK - implemented not in Kotlin (external)

  var myPropC: Int = 0
      @Inject set // OK - accessor is annotated
        &lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    &lt;li&gt;
        Setter body is a block with a single statement assigning the parameter to the backing field.
        &lt;pre&gt;&lt;code&gt;
  var prop: Int = 0
      set(value) { // redundant
          field = value
      }
       &lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
&lt;/ol&gt;

&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimpleRedundantLet" defaultSeverity="WARNING" displayName="Redundant receiver-based 'let' call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant receiver-based &lt;code&gt;let&lt;/code&gt; calls.
&lt;p&gt;The quick-fix removes the redundant &lt;code&gt;let&lt;/code&gt; call.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(s: String?): Int? = s?.let { it.length }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test(s: String?): Int? = s?.length
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveSingleExpressionStringTemplate" defaultSeverity="WARNING" displayName="Redundant string template" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports single-expression string templates that can be safely removed.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  val x = "Hello"
  val y = "$x"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  val x = "Hello"
  val y = x // &amp;lt;== Updated
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveSetterParameterType" defaultSeverity="WARNING" displayName="Redundant setter parameter type" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports explicitly specified parameter types in property setters.
&lt;p&gt;
    Setter parameter type always matches the property type, so it's not required to be explicit.
    The 'Remove explicit type specification' quick-fix allows amending the code accordingly.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun process(x: Int) {}

  var x: Int = 0
      set(value: Int) = process(value) // &amp;lt;== 'Int' specification can be safely omitted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun process(x: Int) {}

  var x: Int = 0
      set(value) = process(value)
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantSemicolon" defaultSeverity="WARNING" displayName="Redundant semicolon" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
    Reports redundant semicolons (&lt;code&gt;;&lt;/code&gt;) that can be safely removed.
&lt;p&gt;
    Kotlin does not require a semicolon at the end of each statement or expression.
    A quick-fix is suggested to remove redundant semicolons.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val myMap = mapOf("one" to 1, "two" to 2);
  myMap.forEach { (key, value) -&gt;  print("$key -&gt; $value")};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  val myMap = mapOf("one" to 1, "two" to 2)
  myMap.forEach { (key, value) -&gt;  print("$key -&gt; $value")}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two cases though where a semicolon is required:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;
        Several statements placed on a single line need to be separated with semicolons:
&lt;pre&gt;&lt;code&gt;
  map.forEach { val (key, value) = it; println("$key -&gt; $value") }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;code&gt;enum&lt;/code&gt; classes that also declare properties or functions, require a semicolon after the list of enum constants:
        &lt;pre&gt;&lt;code&gt;
  enum class Mode {
      SILENT, VERBOSE;

      fun isSilent(): Boolean = this == SILENT
  }
        &lt;/code&gt;&lt;/pre&gt;
    &lt;/li&gt;
&lt;/ol&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveRedundantCallsOfConversionMethods" defaultSeverity="WARNING" displayName="Redundant call of conversion method" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant calls to conversion methods (for example, &lt;code&gt;toString()&lt;/code&gt; on a &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;toDouble()&lt;/code&gt;
on a &lt;code&gt;Double&lt;/code&gt;).
&lt;p&gt;Use the 'Remove redundant calls of the conversion method' quick-fix to clean up the code.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnnecessaryVariable" defaultSeverity="WEAK WARNING" displayName="Unnecessary local variable" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports local variables that used only in the very next &lt;code&gt;return&lt;/code&gt; statement or exact copies of other variables.
&lt;p&gt;Such variables can be safely inlined to make the code more clear.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="SimplifyWhenWithBooleanConstantCondition" defaultSeverity="WEAK WARNING" displayName="Simplifiable 'when'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;when&lt;/code&gt; expressions with the constant &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; branches.
&lt;p&gt;&lt;b&gt;Simplify "when"&lt;/b&gt; quick-fix can be used to amend the code automatically.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundant() {
      when { // &amp;lt;== redundant, quick-fix simplifies the when expression to "println("true")"
          true -&gt; println("true")
          else -&gt; println("false")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="CanBeParameter" defaultSeverity="WARNING" displayName="Constructor parameter is never used as a property" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports primary constructor parameters that can have &lt;code&gt;val&lt;/code&gt; or &lt;code&gt;var&lt;/code&gt; removed.
&lt;p&gt;
    Class properties declared in the constructor increase memory consumption.
    If the parameter value is only used in the constructor, you can omit them.
&lt;/p&gt;
&lt;p&gt;Note that the referenced object might be garbage-collected earlier.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Task(val name: String) {
      init {
          print("Task created: $name")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix removes the extra &lt;code&gt;val&lt;/code&gt; or &lt;code&gt;var&lt;/code&gt; keyword:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Task(name: String) {
      init {
          print("Task created: $name")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantSuspendModifier" defaultSeverity="WARNING" displayName="Redundant 'suspend' modifier" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;suspend&lt;/code&gt; modifier as redundant if no other suspending functions are called inside.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedSymbol" defaultSeverity="WARNING" displayName="Unused symbol" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports symbols that are not used or not reachable from entry points.
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveRedundantSpreadOperator" defaultSeverity="WARNING" displayName="Redundant spread operator" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the use of a redundant spread operator for a family of &lt;code&gt;arrayOf&lt;/code&gt; function calls.
&lt;p&gt;Use the 'Remove redundant spread operator' quick-fix to clean up the code.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(vararg s: String) { }

  fun bar(ss: Array&amp;lt;String&amp;gt;) {
      foo(*arrayOf("abc"))       // for the both calls of 'foo', array creation
      foo(*arrayOf(*ss, "zzz"))  // and its subsequent "spreading" is redundant
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(vararg s: String) { }

  fun bar(ss: Array&amp;lt;String&amp;gt;) {
      foo("abc")
      foo(*ss, "zzz")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveForLoopIndices" defaultSeverity="WARNING" displayName="Unused loop index" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;for&lt;/code&gt; loops iterating over a collection using the &lt;code&gt;withIndex()&lt;/code&gt; function and not using the index variable.
&lt;p&gt;Use the "Remove indices in 'for' loop" quick-fix to clean up the code.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(bar: List&amp;lt;String&amp;gt;) {
     for ((index : Int, value: String) in bar.withIndex()) { // &amp;lt;== 'index' is unused
         println(value)
     }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(bar: List&amp;lt;String&amp;gt;) {
      for (value: String in bar) { // &amp;lt;== '.withIndex()' and 'index' are removed
          println(value)
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveCurlyBracesFromTemplate" defaultSeverity="WEAK WARNING" displayName="Redundant curly braces in string template" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports usages of curly braces in string templates around simple identifiers.
&lt;p&gt;Use the 'Remove curly braces' quick-fix to remove the redundant braces.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundant() {
     val x = 4
     val y = "${x}" // &amp;lt;== redundant
  }

  fun correctUsage() {
      val x = "x"
      val y = "${x.length}" // &amp;lt;== Ok
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundant() {
     val x = 4
     val y = "$x"
  }

  fun correctUsage() {
      val x = "x" &amp;lt;== Updated
      val y = "${x.length}"
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ConstantConditionIf" defaultSeverity="WEAK WARNING" displayName="Condition of 'if' expression is constant" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;if&lt;/code&gt; expressions that have &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;
constant literal condition and can be simplified.
&lt;p&gt;While occasionally intended, this construction is confusing and often the result of a typo
    or previous refactoring.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      if (true) {
          throw IllegalStateException("Unexpected state")
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix removes the &lt;code&gt;if&lt;/code&gt; condition:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      throw IllegalStateException("Unexpected state")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="WhenWithOnlyElse" defaultSeverity="WEAK WARNING" displayName="'when' has only 'else' branch and can be simplified" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports &lt;code&gt;when&lt;/code&gt; expressions with only an &lt;code&gt;else&lt;/code&gt; branch that can be simplified.
&lt;p&gt;&lt;b&gt;Simplify expression&lt;/b&gt; quick-fix can be used to amend the code automatically.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundant() {
      val x = when { // &amp;lt;== redundant, a quick-fix simplifies the when expression to "val x = 1"
          else -&gt; 1
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantEmptyInitializerBlock" defaultSeverity="INFO" displayName="Redundant empty initializer block" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports redundant empty initializer blocks.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      init {
          // Empty init block
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantWith" defaultSeverity="WEAK WARNING" displayName="Redundant 'with' call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant &lt;code&gt;with&lt;/code&gt; function calls that don't access anything from the receiver.
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClass {
      fun f(): String = ""
  }

  fun testRedundant() {
      with(c) { // &amp;lt;== 'with' is redundant since 'c' isn't used
          println("1")
      }
  }

  fun testOk() {
      val c = MyClass()
      with(c) { // &amp;lt;== OK because 'f()' is effectively 'c.f()'
          println(f())
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="UnnecessaryOptInAnnotation" defaultSeverity="WEAK WARNING" displayName="Unnecessary '@OptIn' annotation" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports unnecessary opt-in annotations that can be safely removed.

&lt;p&gt;&lt;code&gt;@OptIn&lt;/code&gt; annotation is required for the code using experimental APIs that can change
    any time in the future. This annotation becomes useless and possibly misleading if no such API is used
    (e.g., when the experimental API becomes stable and does not require opting in its usage anymore).
&lt;/p&gt;
&lt;p&gt;
    &lt;b&gt;Remove annotation&lt;/b&gt; quick-fix can be used to remove the unnecessary &lt;code&gt;@OptIn&lt;/code&gt; annotation.
&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  @OptIn(ExperimentalApi::class)
  fun foo(x: Bar) {
      x.baz()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(x: Bar) {
      x.baz()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ReplaceWithIgnoreCaseEquals" defaultSeverity="WEAK WARNING" displayName="Should be replaced with 'equals(..., ignoreCase = true)'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports case-insensitive comparisons that can be replaced with &lt;code&gt;equals(..., ignoreCase = true)&lt;/code&gt;.
&lt;p&gt;By using &lt;code&gt;equals()&lt;/code&gt; you don't have to allocate extra strings with &lt;code&gt;toLowerCase()&lt;/code&gt; or &lt;code&gt;toUpperCase()&lt;/code&gt; to compare strings.&lt;/p&gt;
&lt;p&gt;The quick-fix replaces the case-insensitive comparison that uses &lt;code&gt;toLowerCase()&lt;/code&gt; or &lt;code&gt;toUpperCase()&lt;/code&gt; with &lt;code&gt;equals(..., ignoreCase = true)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; May change semantics for some locales.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val a = &amp;quot;KoTliN&amp;quot;
      val b = &amp;quot;KOTLIN&amp;quot;
      println(a.toLowerCase() == b.toLowerCase())
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun main() {
      val a = &amp;quot;KoTliN&amp;quot;
      val b = &amp;quot;KOTLIN&amp;quot;
      println(a.equals(b, ignoreCase = true))
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="KotlinDoubleNegation" defaultSeverity="WEAK WARNING" displayName="Redundant double negation" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant double negations.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  val truth = !!true&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="ComplexRedundantLet" defaultSeverity="INFO" displayName="Redundant argument-based 'let' call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a redundant argument-based &lt;code&gt;let&lt;/code&gt; call.
&lt;p&gt;&lt;code&gt;let&lt;/code&gt; is redundant when the lambda parameter is only used as a qualifier in a call expression.&lt;/p&gt;
&lt;p&gt;If you need to give a name to the qualifying expression, declare a local variable.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun splitNumbers() {
      "1,2,3".let { it.split(',') }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick-fix removes the extra &lt;code&gt;let()&lt;/code&gt; call:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun example() {
      "1,2,3".split(',')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternative:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun splitNumbers() {
      val numbers = "1,2,3"
      numbers.split(',')
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- tooltip end --&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinUnusedImport" defaultSeverity="WARNING" displayName="Unused import directive" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant &lt;code&gt;import&lt;/code&gt; statements.

&lt;p&gt;Default and unused imports can be safely removed.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  import kotlin.*
  import kotlin.collections.*
  import kotlin.comparisons.*
  import kotlin.io.*
  import kotlin.ranges.*
  import kotlin.sequences.*
  import kotlin.text.*

  // jvm specific
  import java.lang.*
  import kotlin.jvm.*

  // js specific
  import kotlin.js.*

  import java.io.* // this import is unused and could be removed
  import java.util.*

  fun foo(list: ArrayList&amp;lt;String&amp;gt;) {
      list.add("")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantNullableReturnType" defaultSeverity="WARNING" displayName="Redundant nullable return type" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports functions and variables with nullable return type which never return or become &lt;code&gt;null&lt;/code&gt;.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun greeting(user: String): String? = "Hello, $user!"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun greeting(user: String): String = "Hello, $user!"
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantRequireNotNullCall" defaultSeverity="WEAK WARNING" displayName="Redundant 'requireNotNull' or 'checkNotNull' call" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports redundant &lt;code&gt;requireNotNull&lt;/code&gt; or &lt;code&gt;checkNotNull&lt;/code&gt; call on non-nullable expressions.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(i: Int) {
      requireNotNull(i) // This 'i' is always not null, so this 'requireNotNull' call is redundant.
      ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(i: Int) {
      ...
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantInnerClassModifier" defaultSeverity="WARNING" displayName="Redundant 'inner' modifier" enabled="false" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports the &lt;code&gt;inner&lt;/code&gt; modifier on a class as redundant if it doesn't reference members of its outer class.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      &lt;b&gt;inner&lt;/b&gt; class InnerClass { // redundant `inner` modifier
          fun hello() {
              println("Hi!")
          }
      }
  }

  class List {
      val objects = Array&amp;lt;Any&amp;gt;(42) { Any() }

      &lt;b&gt;inner&lt;/b&gt; class Iterator { // Not redundant `inner` modifier
          fun next(): Any {
              return objects[0]
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Foo {
      class InnerClass { // redundant `inner` modifier
          fun hello() {
              println("Hi!")
          }
      }
  }

  class List {
      val objects = Array&amp;lt;Any&amp;gt;(42) { Any() }

      &lt;b&gt;inner&lt;/b&gt; class Iterator { // Not redundant `inner` modifier
          fun next(): Any {
              return objects[0]
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantElvisReturnNull" defaultSeverity="WARNING" displayName="Redundant '?: return null'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports redundant &lt;code&gt;?: return null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): Int? {
      ...
  }

  fun test() : Int? {
      return foo() &lt;b&gt;?: return null&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): Int? {
      ...
  }

  fun test() : Int? {
      return foo()
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="ExplicitThis" defaultSeverity="INFORMATION" displayName="Redundant explicit 'this'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports an explicit &lt;code&gt;this&lt;/code&gt; when it can be omitted.
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
      private val i = 1
      fun f() = this.i
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick-fix removes the redundant &lt;code&gt;this&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class C {
      private val i = 1
      fun f() = i
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveRedundantBackticks" defaultSeverity="WARNING" displayName="Redundant backticks" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant backticks in references.
&lt;p&gt;
    Some of the Kotlin keywords are valid identifiers in Java, for example: &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;.
    If a Java library uses a Kotlin keyword for a method, you can still call the method escaping it
    with the backtick character (&lt;code&gt;`&lt;/code&gt;), for example, &lt;code&gt;foo.`is`(bar)&lt;/code&gt;.
    Sometimes this escaping is redundant and can be safely omitted. The inspection discovers and reports such cases and is
    paired with the 'Remove redundant backticks' quick-fix, which allows you to amend the highlighted code.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun `is`(x: String) {}
  fun foo() {
      `is`("bar") // 'is' is a keyword, backticks are required
  }

  fun `test that smth works as designed`() {} // OK, complex identifier for readability improvement

  val `a` = 1  // no need for backticks
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantUnitReturnType" defaultSeverity="WARNING" displayName="Redundant 'Unit' return type" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports a redundant &lt;code&gt;Unit&lt;/code&gt; return type which can be omitted.
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantUnitExpression" defaultSeverity="WARNING" displayName="Redundant 'Unit'" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant &lt;code&gt;Unit&lt;/code&gt; expressions.
&lt;p&gt;
    &lt;code&gt;Unit&lt;/code&gt; in Kotlin can be used as the return type of functions that do not return anything meaningful.
    The &lt;code&gt;Unit&lt;/code&gt; type has only one possible value, which is the &lt;code&gt;Unit&lt;/code&gt; object.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun redundantA(): Unit {
      return Unit // redundant, 'Unit' is returned by default and matches the expected return type
  }

  fun requiredA(condition: Boolean): Any {
      if (condition) return "hello"
      return Unit // explicit 'Unit' is required since the expected type is 'Any'
  }

  fun redundantB(condition: Boolean): Any = if (condition) {
      fun ancillary(): Int = 1
      println("${ancillary()}")
      Unit // redundant since the last expression is already of type 'Unit'
  } else {
      println("else")
  }

  fun requiredB(condition: Boolean): Any = if (condition) {
      1024
      Unit // required, otherwise '1024' (Int) would be the return value
  } else {
      println("else")
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveRedundantQualifierName" defaultSeverity="WARNING" displayName="Redundant qualifier name" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant qualifiers (or their parts) on class names, functions, and properties.
&lt;p&gt;
    A fully qualified name is an unambiguous identifier that specifies which object, function, or property a call refers to.
    In the contexts where the name can be shortened, the inspection informs on the opportunity and the associated
    'Remove redundant qualifier name' quick-fix allows amending the code.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package my.simple.name
  import kotlin.Int.Companion.MAX_VALUE

  class Foo

  fun main() {
      val a = my.simple.name.Foo()    // 'Foo' resides in the declared 'my.simple.name' package, qualifier is redundant
      val b = kotlin.Int.MAX_VALUE    // Can be replaced with 'MAX_VALUE' since it's imported
      val c = kotlin.Double.MAX_VALUE // Can be replaced with 'Double.MAX_VALUE' since built-in types are imported automatically
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  package my.simple.name
  import kotlin.Int.Companion.MAX_VALUE

  class Foo

  fun main() {
      val a = Foo()
      val b = MAX_VALUE
      val c = Double.MAX_VALUE
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantExplicitType" defaultSeverity="WARNING" displayName="Obvious explicit type" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports local variables' explicitly given types which are obvious and thus redundant, like &lt;code&gt;val f: Foo = Foo()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Point(val x: Int, val y: Int)

  fun foo() {
      val t: &lt;b&gt;Boolean&lt;/b&gt; = true
      val p: &lt;b&gt;Point&lt;/b&gt; = Point(1, 2)
      val i: &lt;b&gt;Int&lt;/b&gt; = 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Point(val x: Int, val y: Int)

  fun foo() {
      val t = true
      val p = Point(1, 2)
      val i = 42
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantReturnLabel" defaultSeverity="WEAK WARNING" displayName="Redundant 'return' label" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports redundant return labels outside of lambda expressions.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      return@test
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun test() {
      return
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveEmptyPrimaryConstructor" defaultSeverity="WEAK WARNING" displayName="Redundant empty primary constructor" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports empty primary constructors when they are implicitly available anyway.
&lt;p&gt;
    A primary constructor is redundant and can be safely omitted when it does not have any annotations or visibility modifiers.
    Use the 'Remove empty primary constructor' quick-fix to clean up the code.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class MyClassA constructor() //  redundant, can be replaced with 'class MyClassA'

  annotation class MyAnnotation
  class MyClassB @MyAnnotation constructor() //  required because of annotation

  class MyClassC private constructor() // required because of visibility modifier
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RedundantGetter" defaultSeverity="WEAK WARNING" displayName="Redundant property getter" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports redundant property getters.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
      val a = 1
          &lt;b&gt;get&lt;/b&gt;
      val b = 1
          &lt;b&gt;get() = field&lt;/b&gt;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Test {
      val a = 1
      val b = 1
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="KotlinRedundantOverride" defaultSeverity="WEAK WARNING" displayName="Redundant overriding method" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports redundant overriding declarations.
&lt;p&gt;
    An override can be omitted if it does not modify the inherited signature semantics, for example, by changing visibility.
&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  &lt;b&gt;open class&lt;/b&gt; Foo {
      open fun singleExpression() {
      }
  }

  class Bar : Foo() {
      &lt;b&gt;override&lt;/b&gt; fun singleExpression() = super.singleExpression()
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class Bar : Foo() {
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;</inspection><inspection shortName="RemoveEmptyClassBody" defaultSeverity="INFO" displayName="Replace empty class body" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports declarations of classes and objects with an empty body.
&lt;p&gt;Use the 'Remove redundant empty class body' quick-fix to clean up the code.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EmptyA() {} // &amp;lt;== empty body

  class EmptyB {
      companion object {} // &amp;lt;== empty body
  }

  fun emptyC() {
     object {} // &amp;lt;== anonymous object, it's ok (not reported)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  class EmptyA()

  class EmptyB {
      companion object
  }

  fun emptyC() {
     object {}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RedundantLambdaArrow" defaultSeverity="WEAK WARNING" displayName="Redundant lambda arrow" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Reports redundant lambda arrows in lambdas without parameters.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(f: () -&gt; Unit) = f()

  fun bar() {
      foo { &lt;b&gt;-&gt;&lt;/b&gt; println("Hi!") }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(f: () -&gt; Unit) = f()

  fun bar() {
      foo { println("Hi!") }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="RemoveExplicitTypeArguments" defaultSeverity="WEAK WARNING" displayName="Unnecessary type argument" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports function calls with type arguments that can be automatically inferred. Such type arguments are redundant and can be safely omitted.
&lt;p&gt;Use the 'Remove explicit type arguments' quick-fix to clean up the code.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  // 'String' type can be inferred here
  fun foo(): MutableList&amp;lt;String&amp;gt; = mutableListOf&amp;lt;String&amp;gt;()

  // Here 'String' cannot be inferred, type argument is required.
  fun bar() = mutableListOf&amp;lt;String&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the quick-fix is applied:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  fun foo(): MutableList&amp;lt;String&amp;gt; = mutableListOf() &amp;lt;== Updated

  fun bar() = mutableListOf&amp;lt;String&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection><inspection shortName="UnusedReceiverParameter" defaultSeverity="WARNING" displayName="Unused receiver parameter" enabled="true" language="kotlin" pluginId="org.jetbrains.kotlin" pluginVersion="221-1.8.0-release-for-android-studio-AS5591.52" isGlobalTool="false">&lt;html&gt;
&lt;body&gt;
Reports receiver parameter of extension functions and properties that is not used.
&lt;p&gt;&lt;b&gt;Remove redundant receiver parameter&lt;/b&gt; can be used to amend the code automatically.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</inspection></group><group name="Android Lint: Lint Implementation Issues" path="Android/Lint"><inspection shortName="AndroidLintUastImplementation" defaultSeverity="WARNING" displayName="Avoid using UAST implementation" enabled="true" pluginId="org.jetbrains.android" pluginVersion="2022.1.1 Patch 1" isGlobalTool="true">&lt;html&gt;&lt;body&gt;Avoid using UAST implementation&lt;br&gt;&lt;br&gt;Use UAST interface whenever possible, and do not rely on UAST implementation, which is subject to change. If language-specific information is needed, the next option is to use PSI directly (though these APIs are less stable and can depend on compiler internals, especially in the case of Kotlin).&lt;br&gt;&lt;br&gt;Issue id: UastImplementation&lt;/body&gt;&lt;/html&gt;</inspection></group></inspections>